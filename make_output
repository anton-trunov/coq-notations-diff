/Users/antontrunov/.opam/coq.local/bin/coq_makefile  -f Make -o Makefile.coq
/Applications/Xcode.app/Contents/Developer/usr/bin/make -f Makefile.coq --no-print-directory
COQDEP VFILES
COQC ssreflect.v
COQC ssrbool.v
COQC ssrnotations.v
COQC ssrfun.v
COQC eqtype.v
1 subgoal
  
  T : eqType
  x : T
  ============================
  eq_op x = Equality.op (Equality.class T) x
1 subgoal
  
  T : eqType
  ============================
  Equality.axiom (eq_op (T:=T))
1 subgoal
  
  T : eqType
  x : T
  ============================
  x == x
1 subgoal
  
  T : eqType
  x, y : T
  ============================
  (x == y) = (y == x)
1 subgoal
  
  T1, T2 : eqType
  b : bool
  x, y : T1
  ============================
  (x != y -> ~~ b) -> b -> x = y
1 subgoal
  
  T1, T2 : eqType
  b : bool
  x, y : T1
  ============================
  (x != y -> b) -> ~~ b -> x = y
1 subgoal
  
  T1, T2 : eqType
  b : bool
  x, y : T1
  ============================
  (x != y -> b) -> b = false -> x = y
1 subgoal
  
  T1, T2 : eqType
  b : bool
  x, y : T1
  ============================
  (x = y -> ~~ b) -> b -> x != y
1 subgoal
  
  T1, T2 : eqType
  b : bool
  x, y : T1
  ============================
  (x = y -> b) -> ~~ b -> x != y
1 subgoal
  
  T1, T2 : eqType
  b : bool
  x, y : T1
  ============================
  (x = y -> b) -> b = false -> x != y
1 subgoal
  
  T1, T2 : eqType
  b : bool
  x, y : T1
  ============================
  (b -> x != y) -> x = y -> ~~ b
1 subgoal
  
  T1, T2 : eqType
  b : bool
  x, y : T1
  ============================
  (b -> x != y) -> x = y -> b = false
1 subgoal
  
  T1, T2 : eqType
  b : bool
  x, y : T1
  ============================
  (~~ b -> x != y) -> x = y -> b
1 subgoal
  
  T1, T2 : eqType
  z1, z2 : T2
  x1, x2 : T1
  ============================
  (x1 != x2 -> z1 != z2) -> z1 = z2 -> x1 = x2
1 subgoal
  
  T1, T2 : eqType
  z1, z2 : T2
  x1, x2 : T1
  ============================
  (x1 = x2 -> z1 = z2) -> z1 != z2 -> x1 != x2
1 subgoal
  
  T1, T2 : eqType
  A : pred T1
  x : T1
  ============================
  reflect {in A, forall y : T1, y != x} (x \notin A)
1 subgoal
  
  T1, T2 : eqType
  A : pred T1
  x : T1
  ============================
  reflect {in A, forall y : T1, x != y} (x \notin A)
1 subgoal
  
  T1, T2 : eqType
  R : Type
  x, y : T1
  vT, vF : R
  ============================
  x != y -> (if x == y then vT else vF) = vF
1 subgoal
  
  T1, T2 : eqType
  R : Type
  x, y : T1
  vT, vF : R
  ============================
  x != y -> (if y == x then vT else vF) = vF
1 subgoal
  
  T : eqType
  x, y : T
  ============================
  forall e1 e2 : x = y, e1 = e2
1 subgoal
  
  T : eqType
  x : T
  ============================
  all_equal_to (erefl x)
1 subgoal
  
  ============================
  Equality.axiom (fun _ : unit => xpredT)
1 subgoal
  
  ============================
  Equality.axiom eqb
1 subgoal
  
  ============================
  eqb = eq_op
1 subgoal
  
  b : bool
  p1, p2 : b
  ============================
  p1 = p2
1 subgoal
  
  b1, b2 : bool
  ============================
  ~~ (b1 (+) b2) = (b1 == b2)
1 subgoal
  
  b1, b2 : bool_eqType
  ============================
  (b1 != b2) = b1 (+) b2
1 subgoal
  
  b : bool_eqType
  ============================
  (b == true) = b
1 subgoal
  
  b : bool_eqType
  ============================
  (b == false) = ~~ b
1 subgoal
  
  b1 : bool
  b2 : bool_eqType
  ============================
  (~~ b1 == b2) = (b1 == ~~ b2)
1 subgoal
  
  T : eqType
  ============================
  (fun a1 : T => pred1 a1) =2 eq_op
1 subgoal
  
  T, T2 : eqType
  x, y : T
  z, u : T2
  b : bool
  ============================
  reflect (x = y \/ b) ((x == y) || b)
1 subgoal
  
  T, T2 : eqType
  x, y : T
  z, u : T2
  b : bool
  ============================
  reflect (x = y \/ z = u) ((x == y) || (z == u))
1 subgoal
  
  T, T2 : eqType
  x, y : T
  z, u : T2
  b : bool
  ============================
  reflect (x <> y /\ b) ((x != y) && b)
1 subgoal
  
  T, T2 : eqType
  x, y : T
  z, u : T2
  b : bool
  ============================
  x = y -> (x == y) || b
1 subgoal
  
  T, T2 : eqType
  x, y : T
  z, u : T2
  b : bool
  ============================
  b -> (x == y) || b
1 subgoal
  
  T, T2 : eqType
  x, y : T
  z, u : T2
  b : bool
  ============================
  {x = y} + {x != y}
1 subgoal
  
  aT, rT : eqType
  D : pred aT
  f : aT -> rT
  g : rT -> aT
  ============================
  injective f -> forall x y : aT, (f x == f y) = (x == y)
1 subgoal
  
  aT, rT : eqType
  D : pred aT
  f : aT -> rT
  g : rT -> aT
  ============================
  cancel f g -> forall x y : aT, (f x == f y) = (x == y)
1 subgoal
  
  aT, rT : eqType
  D : pred aT
  f : aT -> rT
  g : rT -> aT
  ============================
  bijective f -> forall x y : aT, (f x == f y) = (x == y)
1 subgoal
  
  aT, rT : eqType
  D : pred aT
  f : aT -> rT
  g : rT -> aT
  ============================
  cancel f g ->
  cancel g f -> forall (x : aT) (y : rT), (f x == y) = (x == g y)
1 subgoal
  
  aT, rT : eqType
  D : pred aT
  f : aT -> rT
  g : rT -> aT
  ============================
  {in D &, injective f} -> {in D &, forall x y : aT, (f x == f y) = (x == y)}
1 subgoal
  
  aT, rT : eqType
  D : pred aT
  f : aT -> rT
  g : rT -> aT
  ============================
  {in D, cancel f g} -> {in D &, forall x y : aT, (f x == f y) = (x == y)}
1 subgoal
  
  T : eqType
  f : T -> T
  ============================
  involutive f -> forall x y : T, (f x == y) = (x == f y)
1 subgoal
  
  T : eqType
  f, f' : T -> T
  ============================
  f =1 f' -> frel f =2 frel f'
1 subgoal
  
  aT : Type
  rT1, rT2 : eqType
  f : aT -> aT
  h : rT1 -> rT2
  k : aT -> rT1
  ============================
  subpred (invariant f k) (invariant f (h \o k))
1 subgoal
  
  aT : Type
  rT1, rT2 : eqType
  f : aT -> aT
  h : rT1 -> rT2
  k : aT -> rT1
  ============================
  injective h -> invariant f (h \o k) =1 invariant f k
1 subgoal
  
  T : Type
  compare_T : comparable
  ============================
  Equality.axiom compareb
1 subgoal
  
  T : Type
  P : pred T
  ============================
  forall x : T, P x -> x = x
1 subgoal
  
  T : Type
  P : pred T
  sT : subType
  u : sT
  ============================
  Sub_spec u
1 subgoal
  
  T : Type
  P : pred T
  sT : subType
  x : T
  Px : P x
  ============================
  val (Sub x Px) = x
1 subgoal
  
  T : Type
  P : pred T
  sT : subType
  x : T
  ============================
  insub_spec x (insub x)
1 subgoal
  
  T : Type
  P : pred T
  sT : subType
  x : T
  Px : P x
  ============================
  insub x = Some (Sub x Px)
1 subgoal
  
  T : Type
  P : pred T
  sT : subType
  x : T
  ============================
  P x = false -> insub x = None
1 subgoal
  
  T : Type
  P : pred T
  sT : subType
  x : T
  ============================
  ~~ P x -> insub x = None
1 subgoal
  
  T : Type
  P : pred T
  sT : subType
  ============================
  ((fun x : T => insub x) : pred T) =1 P
1 subgoal
  
  T : Type
  P : pred T
  sT : subType
  ============================
  ocancel insub val
1 subgoal
  
  T : Type
  P : pred T
  sT : subType
  u : sT
  ============================
  P (val u)
1 subgoal
  
  T : Type
  P : pred T
  sT : subType
  ============================
  pcancel val insub
1 subgoal
  
  T : Type
  P : pred T
  sT : subType
  ============================
  injective val
1 subgoal
  
  T : Type
  P : pred T
  sT : subType
  u0 : sT
  ============================
  cancel val (insubd u0)
1 subgoal
  
  T : Type
  P : pred T
  sT : subType
  u0 : sT
  x : T
  ============================
  val (insubd u0 x) = (if P x then x else val u0)
1 subgoal
  
  T : Type
  P : pred T
  sT : subType
  u0 : sT
  ============================
  {in P, cancel (insubd u0) val}
1 subgoal
  
  T : Type
  P : pred T
  sT : subType
  insub_eq_aux := fun (x : T) (isPx : bool) =>
                  if isPx as b return (P x = b -> option sT)
                  then fun Px : P x = true => Some (Sub x Px)
                  else fun _ : P x = false => None
   : forall (x : T) (isPx : bool), P x = isPx -> option sT
  ============================
  insub_eq =1 insub
1 subgoal
  
  T : Type
  nT : subType predT
  ============================
  cancel val innew
1 subgoal
  
  T : Type
  P, Q : T -> Prop
  ============================
  forall u : {x : T | P x}, P (sval u)
1 subgoal
  
  T : Type
  P, Q : T -> Prop
  u : {x : T | P x & Q x}
  ============================
  P (s2val u)
1 subgoal
  
  T : Type
  P, Q : T -> Prop
  u : {x : T | P x & Q x}
  ============================
  Q (s2val u)
1 subgoal
  
  T : Type
  eT : eqType
  f : T -> eT
  ============================
  injective f -> Equality.axiom (fun x y : T => f x == f y)
1 subgoal
  
  T : eqType
  P : pred T
  sT : subType P
  ============================
  ev_ax sT val
1 subgoal
  
  T : eqType
  P : pred T
  sT : subType P
  u, v : sT
  ============================
  (val u == val v) = (u == v)
1 subgoal
  
  T1, T2 : eqType
  ============================
  Equality.axiom pair_eq
1 subgoal
  
  T1, T2 : eqType
  ============================
  pair_eq = eq_op
1 subgoal
  
  T1, T2 : eqType
  x1, y1 : T1
  x2, y2 : T2
  ============================
  ((x1, x2) == (y1, y2)) = (x1 == y1) && (x2 == y2)
1 subgoal
  
  T1, T2 : eqType
  u, v : T1 * T2
  ============================
  u == v -> u.1 == v.1
1 subgoal
  
  T1, T2 : eqType
  u, v : T1 * T2
  ============================
  u == v -> u.2 == v.2
1 subgoal
  
  T : eqType
  ============================
  Equality.axiom opt_eq
1 subgoal
  
  I : eqType
  T_ : I -> Type
  u : {i : I & T_ i}
  x : T_ (tag u)
  ============================
  tagged_as u (Tagged T_ x) = x
1 subgoal
  
  I : eqType
  T_ : I -> eqType
  ============================
  Equality.axiom tag_eq
1 subgoal
  
  I : eqType
  T_ : I -> eqType
  ============================
  tag_eq = eq_op
1 subgoal
  
  I : eqType
  T_ : I -> eqType
  u, v : {i : I & T_ i}
  ============================
  u == v -> tag u = tag v
1 subgoal
  
  I : eqType
  T_ : I -> eqType
  u : {i : I & T_ i}
  x : (fun x : I => Equality.sort (T_ x)) (tag u)
  ============================
  (u == Tagged (fun x0 : I => T_ x0) x) = (tagged u == x)
1 subgoal
  
  T1, T2 : eqType
  ============================
  Equality.axiom sum_eq
1 subgoal
  
  T1, T2 : eqType
  ============================
  sum_eq = eq_op
COQC ssrnat.v
1 subgoal
  
  ============================
  cancel succn predn
1 subgoal
  
  ============================
  injective succn
1 subgoal
  
  ============================
  Equality.axiom eqn
1 subgoal
  
  ============================
  eqn = eq_op
1 subgoal
  
  m, n : nat
  ============================
  (m.+1 == n.+1) = (m == n)
1 subgoal
  
  x, y : nat
  E, E' : x = y
  ============================
  E = E'
1 subgoal
  
  ============================
  addn = addn_rec
1 subgoal
  
  ============================
  Nat.add = addn
1 subgoal
  
  ============================
  left_id 0 addn
1 subgoal
  
  m, n : nat
  ============================
  m.+1 + n = (m + n).+1
1 subgoal
  
  n : nat
  ============================
  1 + n = n.+1
1 subgoal
  
  ============================
  right_id 0 addn
1 subgoal
  
  m, n : nat
  ============================
  m + n.+1 = (m + n).+1
1 subgoal
  
  m, n : nat
  ============================
  m.+1 + n = m + n.+1
1 subgoal
  
  ============================
  left_commutative addn
1 subgoal
  
  ============================
  commutative addn
1 subgoal
  
  n : nat
  ============================
  n + 1 = n.+1
1 subgoal
  
  ============================
  associative addn
1 subgoal
  
  ============================
  right_commutative addn
1 subgoal
  
  ============================
  interchange addn addn
1 subgoal
  
  m, n : nat
  ============================
  (m + n == 0) = (m == 0) && (n == 0)
1 subgoal
  
  p, m, n : nat
  ============================
  (p + m == p + n) = (m == n)
1 subgoal
  
  p, m, n : nat
  ============================
  (m + p == n + p) = (m == n)
1 subgoal
  
  ============================
  right_injective addn
1 subgoal
  
  ============================
  left_injective addn
1 subgoal
  
  m : nat
  ============================
  m + 2 = m.+2
1 subgoal
  
  m : nat
  ============================
  2 + m = m.+2
1 subgoal
  
  m : nat
  ============================
  m + 3 = m.+3
1 subgoal
  
  m : nat
  ============================
  3 + m = m.+3
1 subgoal
  
  m : nat
  ============================
  m + 4 = m.+4
1 subgoal
  
  m : nat
  ============================
  4 + m = m.+4
1 subgoal
  
  ============================
  subn = subn_rec
1 subgoal
  
  ============================
  Nat.sub = subn
1 subgoal
  
  ============================
  left_zero 0 subn
1 subgoal
  
  ============================
  right_id 0 subn
1 subgoal
  
  ============================
  self_inverse 0 subn
1 subgoal
  
  n, m : nat
  ============================
  m.+1 - n.+1 = m - n
1 subgoal
  
  n : nat
  ============================
  n - 1 = n.-1
1 subgoal
  
  n : nat
  ============================
  n - 2 = n.-2
1 subgoal
  
  p, m, n : nat
  ============================
  p + m - (p + n) = m - n
1 subgoal
  
  p, m, n : nat
  ============================
  m + p - (n + p) = m - n
1 subgoal
  
  n : nat
  ============================
  cancel (addn n) (subn^~ n)
1 subgoal
  
  n : nat
  ============================
  cancel (addn^~ n) (subn^~ n)
1 subgoal
  
  n : nat
  ============================
  n.+1 - n = 1
1 subgoal
  
  m, n, p : nat
  ============================
  n - (m + p) = n - m - p
1 subgoal
  
  ============================
  right_commutative subn
1 subgoal
  
  m, n : nat
  ============================
  m - n.+1 = (m - n).-1
1 subgoal
  
  m, n : nat
  ============================
  (m.+1 - n).-1 = m - n
1 subgoal
  
  m, n : nat
  ============================
  (m < n.+1) = (m <= n)
1 subgoal
  
  n : nat
  ============================
  0 <= n
1 subgoal
  
  n : nat
  ============================
  0 < n.+1
1 subgoal
  
  n : nat
  ============================
  (n < 0) = false
1 subgoal
  
  n : nat
  ============================
  n <= n
1 subgoal
  
  n : nat
  ============================
  n < n.+1
1 subgoal
  
  m, n : nat
  ============================
  m = n -> m <= n
1 subgoal
  
  n : nat
  ============================
  n <= n.+1
1 subgoal
  
  n : nat
  ============================
  n.-1 <= n
1 subgoal
  
  n : nat
  ============================
  n <= n.-1.+1
1 subgoal
  
  m, n : nat
  ============================
  m < n -> n.-1.+1 = n
1 subgoal
  
  n : nat
  ============================
  0 < n -> n.-1.+1 = n
1 subgoal
  
  m, n : nat
  ============================
  (m <= n) = ~~ (n < m)
1 subgoal
  
  m, n : nat
  ============================
  (m < n) = ~~ (n <= m)
1 subgoal
  
  n : nat
  ============================
  (n < n) = false
1 subgoal
  
  n : nat
  ============================
  (n <= 0) = (n == 0)
1 subgoal
  
  n : nat
  ============================
  (0 < n) = (n != 0)
1 subgoal
  
  n : nat
  ============================
  0 < n -> n != 0
1 subgoal
  
  n : nat_eqType
  ============================
  (n == 0) = ~~ (0 < n)
1 subgoal
  
  n : nat_eqType
  ============================
  (n == 0) = false -> 0 < n
1 subgoal
  
  m, n : nat_eqType
  ============================
  (m == n) = (m <= n) && (n <= m)
1 subgoal
  
  ============================
  antisymmetric leq
1 subgoal
  
  m, n : nat_eqType
  ============================
  (m != n) = (m < n) || (n < m)
1 subgoal
  
  m, n : nat
  ============================
  m < n -> (n == m) = false
1 subgoal
  
  m, n : nat
  ============================
  m < n -> (m == n) = false
1 subgoal
  
  m, n : nat
  ============================
  (m <= n) = (m == n) || (m < n)
1 subgoal
  
  m, n : nat
  ============================
  (m < n) = (m != n) && (m <= n)
1 subgoal
  
  n, m, p : nat
  ============================
  m <= n -> n <= p -> m <= p
1 subgoal
  
  n, m, p : nat
  ============================
  m <= n -> n < p -> m < p
1 subgoal
  
  m, n : nat
  ============================
  m < n -> m <= n
1 subgoal
  
  m, n : nat
  ============================
  m <= n -> m <= n.+1
1 subgoal
  
  n, m, p : nat
  ============================
  m < n -> n < p -> m < p
1 subgoal
  
  m, n : nat
  ============================
  (m <= n) || (n <= m)
1 subgoal
  
  m, n : nat
  ============================
  reflect (m <= n) (m <= n)
1 subgoal
  
  m, n : nat
  le_mn1, le_mn2 : m <= n
  ============================
  le_mn1 = le_mn2
1 subgoal
  
  m, n : nat
  ============================
  reflect (m < n) (m < n)
1 subgoal
  
  m, n : nat
  lt_mn1, lt_mn2 : m < n
  ============================
  lt_mn1 = lt_mn2
1 subgoal
  
  m, n : nat
  ============================
  leq_xor_gtn m n (m <= n) (n < m)
1 subgoal
  
  m, n : nat
  ============================
  ltn_xor_geq m n (n <= m) (m < n)
1 subgoal
  
  n : nat
  ============================
  eqn0_xor_gt0 n (n == 0) (0 < n)
1 subgoal
  
  m, n : nat
  ============================
  compare_nat m n (m <= n) (n <= m) (m < n) (n < m) (n == m) (m == n)
1 subgoal
  
  p, m, n : nat
  ============================
  (p + m <= p + n) = (m <= n)
1 subgoal
  
  p, m, n : nat
  ============================
  (p + m < p + n) = (m < n)
1 subgoal
  
  p, m, n : nat
  ============================
  (m + p <= n + p) = (m <= n)
1 subgoal
  
  p, m, n : nat
  ============================
  (m + p < n + p) = (m < n)
1 subgoal
  
  m1, m2, n1, n2 : nat
  ============================
  m1 <= n1 -> m2 <= n2 -> m1 + m2 <= n1 + n2
1 subgoal
  
  m, n : nat
  ============================
  n <= n + m
1 subgoal
  
  m, n : nat
  ============================
  n <= m + n
1 subgoal
  
  m, n, p : nat
  ============================
  m < n -> m < n + p
1 subgoal
  
  m, n, p : nat
  ============================
  m < n -> m < p + n
1 subgoal
  
  m, n : nat
  ============================
  (0 < m + n) = (0 < m) || (0 < n)
1 subgoal
  
  m, n : nat
  ============================
  (0 < n - m) = (m < n)
1 subgoal
  
  m, n : nat
  ============================
  (m - n == 0) = (m <= n)
1 subgoal
  
  m, n, p : nat
  ============================
  (m - n <= p) = (m <= n + p)
1 subgoal
  
  m, n : nat
  ============================
  n - m <= n
1 subgoal
  
  m, n : nat
  ============================
  m <= n -> m + (n - m) = n
1 subgoal
  
  m, n : nat
  ============================
  m <= n -> n - m + m = n
1 subgoal
  
  m, n, p : nat
  ============================
  p <= n -> m + (n - p) = m + n - p
1 subgoal
  
  m, n, p : nat
  ============================
  n <= m -> m - n + p = m + p - n
1 subgoal
  
  m, n, p : nat
  ============================
  p <= m -> p <= n -> m + (n - p) = n + (m - p)
1 subgoal
  
  m, n, p : nat
  ============================
  p <= m -> p <= n -> m + (n - p) = m - p + n
1 subgoal
  
  m, n, p : nat
  ============================
  p <= n -> m - (n - p) = m + p - n
1 subgoal
  
  m, n : nat
  ============================
  m <= n -> n - (n - m) = m
1 subgoal
  
  m, n : nat
  ============================
  m <= n -> n.+1 - m = (n - m).+1
1 subgoal
  
  m, n : nat
  ============================
  m < n -> (n - m.+1).+1 = n - m
1 subgoal
  
  p, m, n : nat
  ============================
  m <= n -> m - p <= n - p
1 subgoal
  
  p, m, n : nat
  ============================
  m <= n -> p - n <= p - m
1 subgoal
  
  m1, m2, n1, n2 : nat
  ============================
  m1 <= m2 -> n2 <= n1 -> m1 - n1 <= m2 - n2
1 subgoal
  
  p, m, n : nat
  ============================
  p < n -> m < n -> m - p < n - p
1 subgoal
  
  p, m, n : nat
  ============================
  m < p -> m < n -> p - n < p - m
1 subgoal
  
  m, n, p : nat
  ============================
  (n < p - m) = (m + n < p)
1 subgoal
  
  T : Type
  m, n : nat
  F : nat -> T
  E : T
  ============================
  match m.+1 - n with
  | 0 => E
  | m'.+1 => F m'
  end = (if n <= m then F (m - n) else E)
1 subgoal
  
  ============================
  left_id 0 maxn
1 subgoal
  
  ============================
  right_id 0 maxn
1 subgoal
  
  ============================
  commutative maxn
1 subgoal
  
  m, n : nat
  ============================
  maxn m n = m + (n - m)
1 subgoal
  
  ============================
  right_commutative maxn
1 subgoal
  
  ============================
  associative maxn
1 subgoal
  
  ============================
  left_commutative maxn
1 subgoal
  
  ============================
  interchange maxn maxn
1 subgoal
  
  m, n : nat
  ============================
  reflect (maxn m n = m) (n <= m)
1 subgoal
  
  m, n : nat
  ============================
  reflect (maxn m n = n) (m <= n)
1 subgoal
  
  ============================
  idempotent maxn
1 subgoal
  
  m, n1, n2 : nat
  ============================
  (m <= maxn n1 n2) = (m <= n1) || (m <= n2)
1 subgoal
  
  m, n : nat
  ============================
  m <= maxn m n
1 subgoal
  
  m, n : nat
  ============================
  n <= maxn m n
1 subgoal
  
  m, n1, n2 : nat
  ============================
  (maxn n1 n2 < m) = (n1 < m) && (n2 < m)
1 subgoal
  
  m, n1, n2 : nat
  ============================
  (maxn n1 n2 <= m) = (n1 <= m) && (n2 <= m)
1 subgoal
  
  m, n : nat
  ============================
  maxn m.+1 n.+1 = (maxn m n).+1
1 subgoal
  
  ============================
  left_distributive addn maxn
1 subgoal
  
  ============================
  right_distributive addn maxn
1 subgoal
  
  ============================
  left_zero 0 minn
1 subgoal
  
  ============================
  right_zero 0 minn
1 subgoal
  
  ============================
  commutative minn
1 subgoal
  
  m, n : nat
  ============================
  minn m n + maxn m n = m + n
1 subgoal
  
  m, n : nat
  ============================
  minn m n = m - (m - n)
1 subgoal
  
  ============================
  right_commutative minn
1 subgoal
  
  ============================
  associative minn
1 subgoal
  
  ============================
  left_commutative minn
1 subgoal
  
  ============================
  interchange minn minn
1 subgoal
  
  m, n : nat
  ============================
  reflect (minn m n = m) (m <= n)
1 subgoal
  
  m, n : nat
  ============================
  reflect (minn m n = n) (n <= m)
1 subgoal
  
  ============================
  idempotent minn
1 subgoal
  
  m, n1, n2 : nat
  ============================
  (m <= minn n1 n2) = (m <= n1) && (m <= n2)
1 subgoal
  
  m, n1, n2 : nat
  ============================
  (minn n1 n2 < m) = (n1 < m) || (n2 < m)
1 subgoal
  
  m, n1, n2 : nat
  ============================
  (minn n1 n2 <= m) = (n1 <= m) || (n2 <= m)
1 subgoal
  
  m, n : nat
  ============================
  minn m n <= m
1 subgoal
  
  m, n : nat
  ============================
  minn m n <= n
1 subgoal
  
  ============================
  right_distributive addn minn
1 subgoal
  
  ============================
  left_distributive addn minn
1 subgoal
  
  m, n : nat
  ============================
  minn m.+1 n.+1 = (minn m n).+1
1 subgoal
  
  m, n : nat
  ============================
  minn (maxn m n) m = m
1 subgoal
  
  m, n : nat
  ============================
  minn n (maxn m n) = n
1 subgoal
  
  m, n : nat
  ============================
  maxn (minn m n) m = m
1 subgoal
  
  m, n : nat
  ============================
  maxn n (minn m n) = n
1 subgoal
  
  ============================
  left_distributive maxn minn
1 subgoal
  
  ============================
  right_distributive maxn minn
1 subgoal
  
  ============================
  left_distributive minn maxn
1 subgoal
  
  ============================
  right_distributive minn maxn
1 subgoal
  
  P : pred nat
  exP : exists n : nat, P n
  ============================
  {m : nat | P m & forall n : nat, P n -> m <= n}
1 subgoal
  
  P : pred nat
  exP : exists n : nat, P n
  ============================
  ex_minn_spec ex_minn
1 subgoal
  
  P : pred nat
  m : nat
  exP : exists i : nat, P i
  ubP : forall i : nat, P i -> i <= m
  ============================
  exists i : nat, P (m - i)
1 subgoal
  
  P : pred nat
  m : nat
  exP : exists i : nat, P i
  ubP : forall i : nat, P i -> i <= m
  ============================
  ex_maxn_spec ex_maxn
1 subgoal
  
  P, Q : nat -> bool
  exP : exists n : nat, P n
  exQ : exists n : nat, Q n
  ============================
  P =1 Q -> ex_minn exP = ex_minn exQ
1 subgoal
  
  P, Q : pred nat
  m, n : nat
  exP : exists i : nat, P i
  ubP : forall i : nat, P i -> i <= m
  exQ : exists i : nat, Q i
  ubQ : forall i : nat, Q i -> i <= n
  ============================
  P =1 Q -> ex_maxn exP ubP = ex_maxn exQ ubQ
1 subgoal
  
  T : Type
  n : nat
  f : T -> T
  x : T
  ============================
  iter n.+1 f x = iter n f (f x)
1 subgoal
  
  T : Type
  n : nat
  f : T -> T
  x : T
  ============================
  iter n.+1 f x = f (iter n f x)
1 subgoal
  
  T : Type
  n, m : nat
  f : T -> T
  x : T
  ============================
  iter (n + m) f x = iter n f (iter m f x)
1 subgoal
  
  T : Type
  n : nat
  f : nat -> T -> T
  x : T
  ============================
  iteri n.+1 f x = f n (iteri n f x)
1 subgoal
  
  T : Type
  idx : T
  n : nat
  op : T -> T -> T
  x : T
  ============================
  iterop n.+1 op x idx = iter n (op x) x
1 subgoal
  
  T : Type
  f, f' : T -> T
  ============================
  f =1 f' -> forall n : nat, iter n f =1 iter n f'
1 subgoal
  
  T : Type
  f, f' : nat -> T -> T
  ============================
  f =2 f' -> forall n : nat, iteri n f =1 iteri n f'
1 subgoal
  
  T : Type
  n : nat
  op, op' : T -> T -> T
  ============================
  op =2 op' -> iterop n op =2 iterop n op'
1 subgoal
  
  m, n : nat
  ============================
  iter n succn m = m + n
1 subgoal
  
  n : nat
  ============================
  iter n succn 0 = n
1 subgoal
  
  m, n : nat
  ============================
  iter n predn m = m - n
1 subgoal
  
  ============================
  Nat.mul = muln
1 subgoal
  
  ============================
  muln = muln_rec
1 subgoal
  
  ============================
  left_zero 0 muln
1 subgoal
  
  ============================
  right_zero 0 muln
1 subgoal
  
  ============================
  left_id 1 muln
1 subgoal
  
  m, n : nat
  ============================
  m.+1 * n = n + m * n
1 subgoal
  
  m, n : nat
  ============================
  m.+1 * n = m * n + n
1 subgoal
  
  m, n : nat
  ============================
  m * n.+1 = m + m * n
1 subgoal
  
  m, n : nat
  ============================
  m * n.+1 = m * n + m
1 subgoal
  
  m, n, p : nat
  ============================
  iter n (addn m) p = m * n + p
1 subgoal
  
  m, n : nat
  ============================
  iter n (addn m) 0 = m * n
1 subgoal
  
  ============================
  right_id 1 muln
1 subgoal
  
  ============================
  commutative muln
1 subgoal
  
  ============================
  left_distributive muln addn
1 subgoal
  
  ============================
  right_distributive muln addn
1 subgoal
  
  ============================
  left_distributive muln subn
1 subgoal
  
  ============================
  right_distributive muln subn
1 subgoal
  
  ============================
  associative muln
1 subgoal
  
  ============================
  left_commutative muln
1 subgoal
  
  ============================
  right_commutative muln
1 subgoal
  
  ============================
  interchange muln muln
1 subgoal
  
  m, n : nat
  ============================
  (m * n == 0) = (m == 0) || (n == 0)
1 subgoal
  
  m, n : nat
  ============================
  (m * n == 1) = (m == 1) && (n == 1)
1 subgoal
  
  m, n : nat
  ============================
  (0 < m * n) = (0 < m) && (0 < n)
1 subgoal
  
  m, n : nat
  ============================
  0 < n -> m <= n * m
1 subgoal
  
  m, n : nat
  ============================
  0 < n -> m <= m * n
1 subgoal
  
  m, n1, n2 : nat
  ============================
  (m * n1 <= m * n2) = (m == 0) || (n1 <= n2)
1 subgoal
  
  m, n1, n2 : nat
  ============================
  (n1 * m <= n2 * m) = (m == 0) || (n1 <= n2)
1 subgoal
  
  m1, m2, n1, n2 : nat
  ============================
  m1 <= n1 -> m2 <= n2 -> m1 * m2 <= n1 * n2
1 subgoal
  
  m, n1, n2 : nat
  ============================
  (m * n1 == m * n2) = (m == 0) || (n1 == n2)
1 subgoal
  
  m, n1, n2 : nat
  ============================
  (n1 * m == n2 * m) = (m == 0) || (n1 == n2)
1 subgoal
  
  m, n1, n2 : nat
  ============================
  0 < m -> (m * n1 <= m * n2) = (n1 <= n2)
1 subgoal
  
  m, n1, n2 : nat
  ============================
  0 < m -> (n1 * m <= n2 * m) = (n1 <= n2)
1 subgoal
  
  m, n1, n2 : nat
  ============================
  0 < m -> (m * n1 == m * n2) = (n1 == n2)
1 subgoal
  
  m, n1, n2 : nat
  ============================
  0 < m -> (n1 * m == n2 * m) = (n1 == n2)
1 subgoal
  
  m, n1, n2 : nat
  ============================
  (m * n1 < m * n2) = (0 < m) && (n1 < n2)
1 subgoal
  
  m, n1, n2 : nat
  ============================
  (n1 * m < n2 * m) = (0 < m) && (n1 < n2)
1 subgoal
  
  m, n1, n2 : nat
  ============================
  0 < m -> (m * n1 < m * n2) = (n1 < n2)
1 subgoal
  
  m, n1, n2 : nat
  ============================
  0 < m -> (n1 * m < n2 * m) = (n1 < n2)
1 subgoal
  
  m, n : nat
  ============================
  1 < n -> 0 < m -> m < n * m
1 subgoal
  
  m, n : nat
  ============================
  1 < n -> 0 < m -> m < m * n
1 subgoal
  
  m1, m2, n1, n2 : nat
  ============================
  m1 < n1 -> m2 < n2 -> m1 * m2 < n1 * n2
1 subgoal
  
  ============================
  right_distributive muln maxn
1 subgoal
  
  ============================
  left_distributive muln maxn
1 subgoal
  
  ============================
  right_distributive muln minn
1 subgoal
  
  ============================
  left_distributive muln minn
1 subgoal
  
  ============================
  expn = expn_rec
1 subgoal
  
  m : nat
  ============================
  m ^ 0 = 1
1 subgoal
  
  m : nat
  ============================
  m ^ 1 = m
1 subgoal
  
  m, n : nat
  ============================
  m ^ n.+1 = m * m ^ n
1 subgoal
  
  m, n : nat
  ============================
  m ^ n.+1 = m ^ n * m
1 subgoal
  
  m, n, p : nat
  ============================
  iter n (muln m) p = m ^ n * p
1 subgoal
  
  m, n : nat
  ============================
  iter n (muln m) 1 = m ^ n
1 subgoal
  
  n : nat
  ============================
  0 < n -> 0 ^ n = 0
1 subgoal
  
  n : nat
  ============================
  1 ^ n = 1
1 subgoal
  
  m, n1, n2 : nat
  ============================
  m ^ (n1 + n2) = m ^ n1 * m ^ n2
1 subgoal
  
  m1, m2, n : nat
  ============================
  (m1 * m2) ^ n = m1 ^ n * m2 ^ n
1 subgoal
  
  m, n1, n2 : nat
  ============================
  m ^ (n1 * n2) = (m ^ n1) ^ n2
1 subgoal
  
  m, n1, n2 : nat
  ============================
  (m ^ n1) ^ n2 = (m ^ n2) ^ n1
1 subgoal
  
  m, n : nat
  ============================
  (0 < m ^ n) = (0 < m) || (n == 0)
1 subgoal
  
  m, e : nat
  ============================
  (m ^ e == 0) = (m == 0) && (0 < e)
1 subgoal
  
  m, n : nat
  ============================
  1 < m -> n < m ^ n
1 subgoal
  
  m, n1, n2 : nat
  ============================
  1 < m -> (m ^ n1 <= m ^ n2) = (n1 <= n2)
1 subgoal
  
  m, n1, n2 : nat
  ============================
  1 < m -> (m ^ n1 < m ^ n2) = (n1 < n2)
1 subgoal
  
  m, n1, n2 : nat
  ============================
  1 < m -> (m ^ n1 == m ^ n2) = (n1 == n2)
1 subgoal
  
  m : nat
  ============================
  1 < m -> injective (expn m)
1 subgoal
  
  m, n1, n2 : nat
  ============================
  0 < m -> n1 <= n2 -> m ^ n1 <= m ^ n2
1 subgoal
  
  m, n1, n2 : nat
  ============================
  0 < m -> m ^ n1 < m ^ n2 -> n1 < n2
1 subgoal
  
  m, n, e : nat
  ============================
  0 < e -> (m ^ e < n ^ e) = (m < n)
1 subgoal
  
  m, n, e : nat
  ============================
  0 < e -> (m ^ e <= n ^ e) = (m <= n)
1 subgoal
  
  m, n, e : nat
  ============================
  0 < e -> (m ^ e == n ^ e) = (m == n)
1 subgoal
  
  e : nat
  ============================
  0 < e -> injective (expn^~ e)
1 subgoal
  
  ============================
  factorial = fact_rec
1 subgoal
  
  ============================
  0`! = 1
1 subgoal
  
  n : nat
  ============================
  (n.+1)`! = n.+1 * n`!
1 subgoal
  
  n : nat
  ============================
  0 < n`!
1 subgoal
  
  b : bool
  ============================
  b <= 1
1 subgoal
  
  b : bool
  ============================
  ~~ b + b = 1
1 subgoal
  
  b : bool
  ============================
  (b == 0 :> nat) = ~~ b
1 subgoal
  
  b : bool
  ============================
  (b == 1 :> nat) = b
1 subgoal
  
  b : bool
  ============================
  (0 < b) = b
1 subgoal
  
  b : bool
  ============================
  1 - b = ~~ b
1 subgoal
  
  b1, b2 : bool
  ============================
  b1 * b2 = b1 && b2
1 subgoal
  
  b : bool
  n : nat
  ============================
  b * n = (if b then n else 0)
1 subgoal
  
  b : bool
  n : nat
  ============================
  n * b = (if b then n else 0)
1 subgoal
  
  b : bool
  ============================
  odd b = b
1 subgoal
  
  m, n : nat
  ============================
  odd (m + n) = odd m (+) odd n
1 subgoal
  
  m, n : nat
  ============================
  n <= m -> odd (m - n) = odd m (+) odd n
1 subgoal
  
  i, m : nat
  ============================
  odd m = false -> i <= m -> odd (m - i) = odd i
1 subgoal
  
  m, n : nat
  ============================
  odd (m * n) = odd m && odd n
1 subgoal
  
  m, n : nat
  ============================
  odd (m ^ n) = (n == 0) || odd m
1 subgoal
  
  ============================
  double = double_rec
1 subgoal
  
  ============================
  0.*2 = 0
1 subgoal
  
  n : nat
  ============================
  (n.+1).*2 = n.*2.+2
1 subgoal
  
  n : nat
  ============================
  n + n = n.*2
1 subgoal
  
  m : nat
  ============================
  2 * m = m.*2
1 subgoal
  
  m : nat
  ============================
  m * 2 = m.*2
1 subgoal
  
  m, n : nat
  ============================
  (m + n).*2 = m.*2 + n.*2
1 subgoal
  
  m, n : nat
  ============================
  (m - n).*2 = m.*2 - n.*2
1 subgoal
  
  m, n : nat
  ============================
  (m.*2 <= n.*2) = (m <= n)
1 subgoal
  
  m, n : nat
  ============================
  (m.*2 < n.*2) = (m < n)
1 subgoal
  
  m, n : nat
  ============================
  (m.*2.+1 < n.*2) = (m < n)
1 subgoal
  
  m, n : nat
  ============================
  (m.*2 <= n.*2.+1) = (m <= n)
1 subgoal
  
  n : nat
  ============================
  odd n.*2 = false
1 subgoal
  
  n : nat
  ============================
  (0 < n.*2) = (0 < n)
1 subgoal
  
  n : nat
  ============================
  (n.*2 == 0) = (n == 0)
1 subgoal
  
  m, n : nat
  ============================
  (m * n).*2 = m.*2 * n
1 subgoal
  
  m, n : nat
  ============================
  (m * n).*2 = m * n.*2
1 subgoal
  
  ============================
  cancel double half
1 subgoal
  
  n : nat
  ============================
  uphalf n.*2 = n
1 subgoal
  
  n : nat
  ============================
  uphalf n = odd n + n./2
1 subgoal
  
  n : nat
  ============================
  odd n + (n./2).*2 = n
1 subgoal
  
  n : nat
  b : bool
  ============================
  (b + n.*2)./2 = n
1 subgoal
  
  m, n : nat
  ============================
  (m + n)./2 = odd m && odd n + (m./2 + n./2)
1 subgoal
  
  m, n : nat
  ============================
  m <= n -> m./2 <= n./2
1 subgoal
  
  n : nat
  ============================
  (0 < n./2) = (1 < n)
1 subgoal
  
  m, n : nat
  ============================
  odd n -> (m <= n) = ((m./2).*2 <= n)
1 subgoal
  
  m, n : nat
  ============================
  odd n -> (n < m) = (n < (m./2).*2)
1 subgoal
  
  n : nat
  ============================
  odd n -> 0 < n
1 subgoal
  
  n : nat
  ============================
  odd n -> 1 < n -> 2 < n
1 subgoal
  
  m : nat
  ============================
  m * m = m ^ 2
1 subgoal
  
  m, n : nat
  ============================
  (m + n) ^ 2 = m ^ 2 + n ^ 2 + 2 * (m * n)
1 subgoal
  
  m, n : nat
  ============================
  n <= m -> (m - n) ^ 2 = m ^ 2 + n ^ 2 - 2 * (m * n)
1 subgoal
  
  m, n : nat
  ============================
  n <= m -> (m + n) ^ 2 - 4 * (m * n) = (m - n) ^ 2
1 subgoal
  
  m, n : nat
  ============================
  m ^ 2 - n ^ 2 = (m - n) * (m + n)
1 subgoal
  
  m, n : nat
  ============================
  (m ^ 2 < n ^ 2) = (m < n)
1 subgoal
  
  m, n : nat
  ============================
  (m ^ 2 <= n ^ 2) = (m <= n)
1 subgoal
  
  n : nat
  ============================
  (0 < n ^ 2) = (0 < n)
1 subgoal
  
  m, n : nat
  ============================
  (m ^ 2 == n ^ 2) = (m == n)
1 subgoal
  
  ============================
  injective (expn^~ 2)
1 subgoal
  
  m, n : nat
  C : bool
  ============================
  reflect (m <= n ?= iff C) (if C then m == n else m < n)
1 subgoal
  
  m : nat
  C : bool
  ============================
  reflect (m <= m ?= iff C) C
1 subgoal
  
  m1, m2, m3 : nat
  C12, C23 : bool
  ============================
  m1 <= m2 ?= iff C12 -> m2 <= m3 ?= iff C23 -> m1 <= m3 ?= iff C12 && C23
1 subgoal
  
  f : nat -> nat
  ============================
  {mono f : m n / m <= n} ->
  forall (m n : nat) (C : bool), (f m <= f n ?= iff C) = (m <= n ?= iff C)
1 subgoal
  
  m, n : nat
  ============================
  m <= n -> m <= n ?= iff (n <= m)
1 subgoal
  
  m, n : nat
  ============================
  m <= n -> m <= n ?= iff (m == n)
1 subgoal
  
  a, b : nat
  C : bool
  ============================
  a <= b ?= iff C -> (b <= a) = C
1 subgoal
  
  a, b : nat
  C : bool
  ============================
  a <= b ?= iff C -> (a < b) = ~~ C
1 subgoal
  
  m1, n1 : nat
  C1 : bool
  m2, n2 : nat
  C2 : bool
  ============================
  m1 <= n1 ?= iff C1 ->
  m2 <= n2 ?= iff C2 -> m1 + m2 <= n1 + n2 ?= iff C1 && C2
1 subgoal
  
  m1, n1 : nat
  C1 : bool
  m2, n2 : nat
  C2 : bool
  ============================
  m1 <= n1 ?= iff C1 ->
  m2 <= n2 ?= iff C2 -> m1 * m2 <= n1 * n2 ?= iff (n1 * n2 == 0) || C1 && C2
1 subgoal
  
  m, n : nat
  ============================
  2 * (m * n) <= m ^ 2 + n ^ 2 ?= iff (m == n)
1 subgoal
  
  m, n : nat
  ============================
  4 * (m * n) <= (m + n) ^ 2 ?= iff (m == n)
1 subgoal
  
  ============================
  add =2 addn
1 subgoal
  
  ============================
  double =1 doublen
1 subgoal
  
  n, m, s : nat
  ============================
  add_mul n m s = n * m + s
1 subgoal
  
  ============================
  mul =2 muln
1 subgoal
  
  m, n, p : nat
  ============================
  mul_exp m n p = m ^ n * p
1 subgoal
  
  ============================
  exp =2 expn
1 subgoal
  
  ============================
  odd =1 oddn
1 subgoal
  
  ============================
  Equality.axiom N.eqb
1 subgoal
  
  ============================
  cancel bin_of_nat nat_of_bin
1 subgoal
  
  ============================
  cancel nat_of_bin bin_of_nat
1 subgoal
  
  p : positive
  ============================
  Pos.succ p = p.+1
1 subgoal
  
  p, q : positive
  ============================
  (p + q)%positive = p + q
1 subgoal
  
  b1, b2 : N
  ============================
  (b1 + b2)%num = b1 + b2
1 subgoal
  
  b1, b2 : N
  ============================
  (b1 * b2)%num = b1 * b2
1 subgoal
  
  n : nat
  b : N
  ============================
  n ^ b = pow_N 1 muln n b
1 subgoal
  
  ============================
  semi_ring_theory 0 1 addn muln eq
1 subgoal
  
  ============================
  semi_morph 0 1 addn muln eq 0%num 1%num N.add N.mul
    (fun a1 : N => pred1 a1) nat_of_bin
1 subgoal
  
  ============================
  power_theory 1 muln eq nat_of_bin expn
COQC seq.v
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  size s = 0 -> s = [::]
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  reflect (s = [::]) (nilp s)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  size (behead s) = (size s).-1
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  n : nat
  x : T
  s : seq T
  ============================
  size (ncons n x s) = n + size s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  n : nat
  x : T
  ============================
  size (nseq n x) = n
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  [::] ++ s = s
1 subgoal
  
  n0 : nat
  T : Type
  x0, x : T
  s : seq T
  ============================
  [:: x] ++ s = x :: s
1 subgoal
  
  n0 : nat
  T : Type
  x0, x : T
  s1, s2 : seq T
  ============================
  (x :: s1) ++ s2 = x :: s1 ++ s2
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  n : nat
  x : T
  s : seq T
  ============================
  nseq n x ++ s = ncons n x s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  s ++ [::] = s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s1, s2, s3 : seq T
  ============================
  s1 ++ s2 ++ s3 = (s1 ++ s2) ++ s3
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s1, s2 : seq T
  ============================
  size (s1 ++ s2) = size s1 + size s2
1 subgoal
  
  n0 : nat
  T : Type
  x0, x : T
  s : seq T
  z : T
  ============================
  rcons (x :: s) z = x :: rcons s z
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  z : T
  ============================
  s ++ [:: z] = rcons s z
1 subgoal
  
  n0 : nat
  T : Type
  x0, x : T
  s : seq T
  ============================
  x :: s = rcons (belast x s) (last x s)
1 subgoal
  
  n0 : nat
  T : Type
  x0, x, y : T
  s : seq T
  ============================
  last x (y :: s) = last y s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  x : T
  ============================
  size (rcons s x) = (size s).+1
1 subgoal
  
  n0 : nat
  T : Type
  x0, x : T
  s : seq T
  ============================
  size (belast x s) = size s
1 subgoal
  
  n0 : nat
  T : Type
  x0, x : T
  s1, s2 : seq T
  ============================
  last x (s1 ++ s2) = last (last x s1) s2
1 subgoal
  
  n0 : nat
  T : Type
  x0, x : T
  s : seq T
  z : T
  ============================
  last x (rcons s z) = z
1 subgoal
  
  n0 : nat
  T : Type
  x0, x : T
  s1, s2 : seq T
  ============================
  belast x (s1 ++ s2) = belast x s1 ++ belast (last x s1) s2
1 subgoal
  
  n0 : nat
  T : Type
  x0, x : T
  s : seq T
  z : T
  ============================
  belast x (rcons s z) = x :: s
1 subgoal
  
  n0 : nat
  T : Type
  x0, x : T
  s1, s2 : seq T
  ============================
  rcons s1 x ++ s2 = s1 ++ x :: s2
1 subgoal
  
  n0 : nat
  T : Type
  x0, x : T
  s1, s2 : seq T
  ============================
  rcons (s1 ++ s2) x = s1 ++ rcons s2 x
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  last_spec s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  P : seq T -> Type
  ============================
  P [::] ->
  (forall (s : seq T) (x : T), P s -> P (rcons s x)) -> forall s : seq T, P s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  nth s 0 = head s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  n : nat
  ============================
  size s <= n -> nth s n = x0
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  n : nat
  ============================
  nth [::] n = x0
1 subgoal
  
  n0 : nat
  T : Type
  x0, x : T
  s : seq T
  ============================
  last x s = nth (x :: s) (size s)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  nth s (size s).-1 = last x0 s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  n : nat
  ============================
  nth (behead s) n = nth s n.+1
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s1, s2 : seq T
  n : nat
  ============================
  nth (s1 ++ s2) n = (if n < size s1 then nth s1 n else nth s2 (n - size s1))
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  x : T
  n : nat
  ============================
  nth (rcons s x) n =
  (if n < size s then nth s n else if n == size s then x else x0)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  m : nat
  x : T
  s : seq T
  n : nat
  ============================
  nth (ncons m x s) n = (if n < m then x else nth s (n - m))
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  m : nat
  x : T
  n : nat
  ============================
  nth (nseq m x) n = (if n < m then x else x0)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s1, s2 : seq T
  ============================
  size s1 = size s2 ->
  (forall i : nat, i < size s1 -> nth s1 i = nth s2 i) -> s1 = s2
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  n : nat
  y : T
  ============================
  size (set_nth s n y) = maxn n.+1 (size s)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  n : nat
  y : T
  ============================
  set_nth [::] n y = ncons n x0 [:: y]
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  n : nat
  y : T
  ============================
  nth (set_nth s n y) =1 [eta nth s with n |-> y]
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  n1 : nat
  y1 : T
  n2 : nat
  y2 : T
  s2 := set_nth s n2 y2 : seq T
  ============================
  set_nth (set_nth s n1 y1) n2 y2 =
  (if n1 == n2 then s2 else set_nth s2 n1 y1)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s : seq T
  ============================
  size (filter s) = count s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s : seq T
  ============================
  has s = (0 < count s)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s : seq T
  ============================
  count s <= size s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s : seq T
  ============================
  all s = (count s == size s)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s : seq T
  ============================
  all (filter s)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s : seq T
  ============================
  reflect (filter s = s) (all s)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s : seq T
  ============================
  filter (filter s) = filter s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s : seq T
  ============================
  has s = (find s < size s)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s : seq T
  ============================
  find s <= size s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s1, s2 : seq T
  ============================
  find (s1 ++ s2) = (if has s1 then find s1 else size s1 + find s2)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  ============================
  has [::] = false
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  x : T
  ============================
  has [:: x] = a x
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  n : nat
  x : T
  ============================
  has (nseq n x) = (0 < n) && a x
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  b : bool
  x : T
  ============================
  has (nseq b x) = b && a x
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  ============================
  all [::] = true
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  x : T
  ============================
  all [:: x] = a x
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  n : nat
  x : T
  ============================
  all (nseq n x) = (n == 0) || a x
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  b : bool
  x : T
  ============================
  all (nseq b x) = b ==> a x
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  n : nat
  x : T
  ============================
  find (nseq n x) = ~~ a x * n
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s : seq T
  ============================
  has s -> a (nth s (find s))
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s : seq T
  i : nat
  ============================
  i < find s -> a (nth s i) = false
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s1, s2 : seq T
  ============================
  filter (s1 ++ s2) = filter s1 ++ filter s2
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s : seq T
  x : T
  ============================
  filter (rcons s x) = (if a x then rcons (filter s) x else filter s)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s1, s2 : seq T
  ============================
  count (s1 ++ s2) = count s1 + count s2
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s1, s2 : seq T
  ============================
  has (s1 ++ s2) = has s1 || has s2
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s : seq T
  x : T
  ============================
  has (rcons s x) = a x || has s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s1, s2 : seq T
  ============================
  all (s1 ++ s2) = all s1 && all s2
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s : seq T
  x : T
  ============================
  all (rcons s x) = a x && all s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a1, a2 : T -> bool
  ============================
  a1 =1 a2 -> find a1 =1 find a2
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a1, a2 : T -> bool
  ============================
  a1 =1 a2 -> filter a1 =1 filter a2
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a1, a2 : T -> bool
  ============================
  a1 =1 a2 -> count a1 =1 count a2
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a1, a2 : T -> bool
  ============================
  a1 =1 a2 -> has a1 =1 has a2
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a1, a2 : T -> bool
  ============================
  a1 =1 a2 -> all a1 =1 all a2
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a1, a2 : pred T
  s12 : subpred a1 a2
  s : seq T
  ============================
  find a2 s <= find a1 s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a1, a2 : pred T
  s12 : subpred a1 a2
  s : seq T
  ============================
  has a1 s -> has a2 s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a1, a2 : pred T
  s12 : subpred a1 a2
  s : seq T
  ============================
  count a1 s <= count a2 s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a1, a2 : pred T
  s12 : subpred a1 a2
  s : seq T
  ============================
  all a1 s -> all a2 s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  filter pred0 s = [::]
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  filter predT s = s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a1, a2 : pred T
  s : seq T
  ============================
  filter (predI a1 a2) s = filter a1 (filter a2 s)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  count pred0 s = 0
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  count predT s = size s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a1, a2 : pred T
  s : seq T
  ============================
  count (predU a1 a2) s + count (predI a1 a2) s = count a1 s + count a2 s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s : seq T
  ============================
  count a s + count (predC a) s = size s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a1, a2 : pred T
  s : seq T
  ============================
  count a1 (filter a2 s) = count (predI a1 a2) s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  has pred0 s = false
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  has predT s = (0 < size s)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s : seq T
  ============================
  has (predC a) s = ~~ all a s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a1, a2 : pred T
  s : seq T
  ============================
  has (predU a1 a2) s = has a1 s || has a2 s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  all pred0 s = (size s == 0)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  all predT s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a : pred T
  s : seq T
  ============================
  all (predC a) s = ~~ has a s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  a1, a2 : pred T
  s : seq T
  ============================
  all (predI a1 a2) s = all a1 s && all a2 s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  ============================
  drop n0 =1 iter n0 behead
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  drop 0 s = s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  ============================
  drop 1 =1 behead
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  n : nat
  s : seq T
  ============================
  size s <= n -> drop n s = [::]
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  drop (size s) s = [::]
1 subgoal
  
  n0 : nat
  T : Type
  x0, x : T
  s : seq T
  ============================
  drop n0 (x :: s) = match n0 with
                     | 0 => x :: s
                     | n.+1 => drop n s
                     end
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  size (drop n0 s) = size s - n0
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s1, s2 : seq T
  ============================
  drop n0 (s1 ++ s2) =
  (if n0 < size s1 then drop n0 s1 ++ s2 else drop (n0 - size s1) s2)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  n : nat
  s1, s2 : seq T
  ============================
  size s1 = n -> drop n (s1 ++ s2) = s2
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  n : nat
  x : T
  ============================
  cancel (ncons n x) (drop n)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  n1, n2 : nat
  ============================
  drop n1 (drop n2 s) = drop (n1 + n2) s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  take 0 s = [::]
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  n : nat
  s : seq T
  ============================
  size s <= n -> take n s = s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  take (size s) s = s
1 subgoal
  
  n0 : nat
  T : Type
  x0, x : T
  s : seq T
  ============================
  take n0 (x :: s) = match n0 with
                     | 0 => [::]
                     | n.+1 => x :: take n s
                     end
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  n0 <= size s -> forall x : T, drop n0 (rcons s x) = rcons (drop n0 s) x
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  take n0 s ++ drop n0 s = s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  n0 <= size s -> size (take n0 s) = n0
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  size (take n0 s) = (if n0 < size s then n0 else size s)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s1, s2 : seq T
  ============================
  take n0 (s1 ++ s2) =
  (if n0 < size s1 then take n0 s1 else s1 ++ take (n0 - size s1) s2)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  n : nat
  s1, s2 : seq T
  ============================
  size s1 = n -> take n (s1 ++ s2) = s1
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s1 : seq T
  ============================
  n0 <= size s1 -> forall s2 : seq T, take n0 (s1 ++ s2) = take n0 s1
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  i : nat
  ============================
  nth (drop n0 s) i = nth s (n0 + i)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  i : nat
  ============================
  i < n0 -> forall s : seq T, nth (take n0 s) i = nth s i
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  n : nat
  s : seq T
  ============================
  n < size s -> drop n s = nth s n :: drop n.+1 s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  n : nat
  s : seq T
  ============================
  n < size s -> take n.+1 s = rcons (take n s) (nth s n)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  rot 0 s = s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  size (rot n0 s) = size s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  n : nat
  s : seq T
  ============================
  size s <= n -> rot n s = s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  ============================
  rot (size s) s = s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s : seq T
  a : pred T
  ============================
  has a (rot n0 s) = has a s
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  s1, s2 : seq T
  ============================
  rot (size s1) (s1 ++ s2) = s2 ++ s1
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  ============================
  cancel (rot n0) (rotr n0)
1 subgoal
  
  n0 : nat
  T : Type
  x0 : T
  ============================
  injective (rot n0)
1 subgoal
  
  n0 : nat
  T : Type
  x0, x : T
  s : seq T
  ============================
  rot 1 (x :: s) = rcons s x
1 subgoal
  
  T1 : Type
  T2 : Type
  P : seq T1 -> seq T2 -> Type
  ============================
  P [::] [::] ->
  (forall (x1 : T1) (x2 : T2) (s1 : seq T1) (s2 : seq T2),
   P s1 s2 -> P (x1 :: s1) (x2 :: s2)) ->
  forall (s1 : seq T1) (s2 : seq T2), size s1 = size s2 -> P s1 s2
1 subgoal
  
  T : Type
  s, t, u : seq T
  ============================
  catrev (s ++ t) u = catrev t (catrev s u)
1 subgoal
  
  T : Type
  s, t, u : seq T
  ============================
  catrev s (t ++ u) = catrev s t ++ u
1 subgoal
  
  T : Type
  s, t : seq T
  ============================
  catrev s t = rev s ++ t
1 subgoal
  
  T : Type
  x : T
  s : seq T
  ============================
  rev (x :: s) = rcons (rev s) x
1 subgoal
  
  T : Type
  s : seq T
  ============================
  size (rev s) = size s
1 subgoal
  
  T : Type
  s, t : seq T
  ============================
  rev (s ++ t) = rev t ++ rev s
1 subgoal
  
  T : Type
  s : seq T
  x : T
  ============================
  rev (rcons s x) = x :: rev s
1 subgoal
  
  T : Type
  ============================
  involutive rev
1 subgoal
  
  T : Type
  x0 : T
  n : nat
  s : seq T
  ============================
  n < size s -> nth x0 (rev s) n = nth x0 s (size s - n.+1)
1 subgoal
  
  T : Type
  a : pred T
  s : seq T
  ============================
  [seq x <- rev s | a x] = rev [seq x <- s | a x]
1 subgoal
  
  T : Type
  a : pred T
  s : seq T
  ============================
  count a (rev s) = count a s
1 subgoal
  
  T : Type
  a : pred T
  s : seq T
  ============================
  has a (rev s) = has a s
1 subgoal
  
  T : Type
  a : pred T
  s : seq T
  ============================
  all a (rev s) = all a s
1 subgoal
  
  T : Type
  s : seq T
  n : nat
  ============================
  take n (rev s) = rev (drop (size s - n) s)
1 subgoal
  
  T : Type
  s : seq T
  n : nat
  ============================
  drop n (rev s) = rev (take (size s - n) s)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  ============================
  Equality.axiom eqseq
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  ============================
  eqseq = eq_op
1 subgoal
  
  n0 : nat
  T : eqType
  x0, x1, x2 : T
  s1, s2 : seq T
  ============================
  (x1 :: s1 == x2 :: s2) = (x1 == x2) && (s1 == s2)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  s1, s2, s3, s4 : seq T
  ============================
  size s1 = size s2 -> (s1 ++ s3 == s2 ++ s4) = (s1 == s2) && (s3 == s4)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  s1, s2 : seq T
  x1, x2 : T
  ============================
  (rcons s1 x1 == rcons s2 x2) = (s1 == s2) && (x1 == x2)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  s : seq T
  ============================
  (size s == 0) = (s == [::])
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  a : pred T
  s : seq T
  ============================
  has a s = ([seq x <- s | a x] != [::])
1 subgoal
  
  n0 : nat
  T : eqType
  x0, y : T
  s : seq T
  x : T
  ============================
  (x \in y :: s) = (x == y) || (x \in s)
1 subgoal
  
  n0 : nat
  T : eqType
  x0, x : T
  ============================
  (x \in [::]) = false
1 subgoal
  
  n0 : nat
  T : eqType
  x0, x, y : T
  ============================
  (x \in [:: y]) = (x == y)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  x, y1, y2 : T
  ============================
  (x \in [:: y1; y2]) = xpred2 y1 y2 x
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  x, y1, y2, y3 : T
  ============================
  (x \in [:: y1; y2; y3]) = xpred3 y1 y2 y3 x
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  x, y1, y2, y3, y4 : T
  ============================
  (x \in [:: y1; y2; y3; y4]) = xpred4 y1 y2 y3 y4 x
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  x : T
  s1, s2 : seq T
  ============================
  (x \in s1 ++ s2) = (x \in s1) || (x \in s2)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  y : T
  ============================
  rcons s y =i y :: s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  x : T
  s : seq T
  ============================
  x \in x :: s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  x : T
  s : seq T
  ============================
  last x s \in x :: s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  ============================
  {subset behead s <= s}
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  y : T
  ============================
  {subset belast y s <= y :: s}
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  n : nat
  ============================
  n < size s -> nth s n \in s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  x : T
  ============================
  x \in take n0 s -> x \in s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  x : T
  ============================
  x \in drop n0 s -> x \in s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  z, x, y : T
  ============================
  x != y -> z != y -> (last x s == y) = (last z s == y)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  a : pred T
  s : seq T
  ============================
  reflect (exists2 x : T, x \in s & a x) (has a s)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  a : pred T
  s : seq T
  aP : T -> Prop
  ============================
  (forall x : T, reflect (aP x) (a x)) ->
  reflect (exists2 x : T, x \in s & aP x) (has a s)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  a : pred T
  s : seq T
  ============================
  reflect (forall x : T, x \in s -> ~~ a x) (~~ has a s)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  a : pred T
  s : seq T
  ============================
  reflect (forall x : T, x \in s -> a x) (all a s)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  a : pred T
  s : seq T
  aP : T -> Prop
  ============================
  (forall x : T, reflect (aP x) (a x)) ->
  reflect (forall x : T, x \in s -> aP x) (all a s)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  a : pred T
  s : seq T
  ============================
  reflect (exists2 x : T, x \in s & ~~ a x) (~~ all a s)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  a : pred T
  x : T
  s : seq T
  ============================
  (x \in [seq x <- s | a x]) = a x && (x \in s)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  a1, a2 : pred T
  s : seq T
  ============================
  {in s, a1 =1 a2} -> [seq x <- s | a1 x] = [seq x <- s | a2 x]
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  a1, a2 : pred T
  s : seq T
  ============================
  {in s, a1 =1 a2} -> find a1 s = find a2 s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  a1, a2 : pred T
  s : seq T
  ============================
  {in s, a1 =1 a2} -> count a1 s = count a2 s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  a1, a2 : pred T
  s : seq T
  ============================
  {in s, a1 =1 a2} -> all a1 s = all a2 s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  a1, a2 : pred T
  s : seq T
  ============================
  {in s, a1 =1 a2} -> has a1 s = has a2 s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s1, s2 : seq T
  ============================
  s1 =i s2 -> has^~ s1 =1 has^~ s2
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s1, s2 : seq T
  ============================
  s1 =i s2 -> all^~ s1 =1 all^~ s2
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s1, s2 : seq T
  ============================
  has (mem s1) s2 = has (mem s2) s1
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  x : T
  s : seq T
  ============================
  has (pred1 x) s = (x \in s)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  ============================
  rev s =i s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  x : T
  s : seq T
  ============================
  reflect (s = nseq (size s) x) (all (pred1 x) s)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  x : T
  s : seq T
  ============================
  all (pred1 x) s -> constant s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  x : T
  n : nat
  ============================
  all (pred1 x) (nseq n x)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  n : nat
  x, y : T
  ============================
  reflect (y = x /\ 0 < n) (y \in nseq n x)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  n : nat
  x : T
  ============================
  constant (nseq n x)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  ============================
  reflect (exists x : T, s = nseq (size s) x) (constant s)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  x : T
  s : seq T
  ============================
  uniq (x :: s) = (x \notin s) && uniq s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s1, s2 : seq T
  ============================
  uniq (s1 ++ s2) = [&& uniq s1, ~~ has (mem s1) s2 & uniq s2]
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s1, s2 : seq T
  ============================
  uniq (s1 ++ s2) = uniq (s2 ++ s1)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s1, s2, s3 : seq T
  ============================
  uniq (s1 ++ s2 ++ s3) = uniq (s2 ++ s1 ++ s3)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  x : T
  ============================
  uniq (rcons s x) = (x \notin s) && uniq s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  a : pred T
  ============================
  uniq s -> uniq [seq x <- s | a x]
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  ============================
  uniq (rot n0 s) = uniq s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  ============================
  uniq (rev s) = uniq s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  x : T
  s : seq T
  ============================
  reflect ((count_mem x) s = 0) (x \notin s)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  x : T
  ============================
  uniq s -> (count_mem x) s = (x \in s)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  x : T
  ============================
  uniq s -> x \in s -> [seq x0 <- s | (pred1 x) x0] = [:: x]
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  ============================
  size (undup s) <= size s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  ============================
  undup s =i s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  ============================
  uniq (undup s)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  ============================
  uniq s -> undup s = s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  ============================
  (size (undup s) < size s) = ~~ uniq s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  p : pred T
  s : seq T
  ============================
  [seq x <- undup s | p x] = undup [seq x <- s | p x]
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  ============================
  undup s = [::] -> s = [::]
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  x : T
  s : seq T
  ============================
  index x s <= size s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  x : T
  s : seq T
  ============================
  (index x s < size s) = (x \in s)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  x : T
  s : seq T
  ============================
  x \in s -> nth s (index x s) = x
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  x : T
  s1, s2 : seq T
  ============================
  index x (s1 ++ s2) =
  (if x \in s1 then index x s1 else size s1 + index x s2)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  i : nat
  s : seq T
  ============================
  i < size s -> uniq s -> index (nth s i) s = i
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  x : T
  s : seq T
  ============================
  index x (x :: s) = 0
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  x : T
  s : seq T
  ============================
  uniq (x :: s) -> index (last x s) (x :: s) = size s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  i, j : nat
  ============================
  i < size s -> j < size s -> uniq s -> (nth s i == nth s j) = (i == j)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  ============================
  reflect (exists i j : nat, [/\ i < j, j < size s & nth s i = nth s j])
    (~~ uniq s)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  ============================
  reflect {in [pred i | i < size s] &, injective (nth s)} (uniq s)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  ============================
  rot n0 s =i s
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s1, s2 : seq T
  ============================
  (rot n0 s1 == rot n0 s2) = (s1 == s2)
1 subgoal
  
  n0 : nat
  T : eqType
  x0 : T
  inE := (mem_seq1, in_cons, ssrbool.inE)
   : (forall x y : T, (x \in [:: y]) = (x == y)) *
     (forall (y : T) (s : seq T) (x : T),
      (x \in y :: s) = (x == y) || (x \in s)) *
     (forall T : Type,
      (forall (x : T) (p : pred T) (amp : applicative_mem_pred p),
       in_mem x amp = p x) *
      (forall (x : T) (p : pred T) (msp : manifest_simpl_pred p),
       in_mem x (Mem [eta msp : simpl_pred T]) = p x) *
      (forall p : pred T, [pred x | p x] =1 p))
  s : seq T
  x : T
  ============================
  x \in s -> rot_to_spec s x
1 subgoal
  
  T : eqType
  s : seq T
  x, x0 : T
  ============================
  reflect (exists2 i : nat, i < size s & nth x0 s i = x) (x \in s)
1 subgoal
  
  T : Type
  a : pred T
  s : seq T
  x0 : T
  ============================
  reflect (exists2 i : nat, i < size s & a (nth x0 s i)) (has a s)
1 subgoal
  
  T : Type
  a : pred T
  s : seq T
  x0 : T
  ============================
  reflect (forall i : nat, i < size s -> a (nth x0 s i)) (all a s)
1 subgoal
  
  T : Type
  s : seq T
  y0, x0 : T
  n : nat
  ============================
  n < size s -> nth x0 s n = nth y0 s n
1 subgoal
  
  T : Type
  s : seq T
  x : T
  ============================
  rcons s x = head x s :: behead (rcons s x)
1 subgoal
  
  v : seq nat
  i, j : nat
  ============================
  nth 0 (incr_nth v i) j = (i == j) + nth 0 v j
1 subgoal
  
  v : seq nat
  i : nat
  ============================
  size (incr_nth v i) = (if i < size v then size v else i.+1)
1 subgoal
  
  v : seq nat
  ============================
  injective (incr_nth v)
1 subgoal
  
  v : seq nat
  i, j : nat
  ============================
  incr_nth (incr_nth v i) j = incr_nth (incr_nth v j) i
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  reflect (count^~ s1 =1 count^~ s2) (perm_eq s1 s2)
1 subgoal
  
  T : eqType
  s : seq T
  ============================
  perm_eq s s
1 subgoal
  
  T : eqType
  ============================
  symmetric perm_eq
1 subgoal
  
  T : eqType
  ============================
  transitive perm_eq
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  perm_eql s1 s2 -> perm_eq s1 s2
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  reflect (perm_eql s1 s2) (perm_eq s1 s2)
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  reflect (perm_eqr s1 s2) (perm_eq s1 s2)
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  perm_eql (s1 ++ s2) (s2 ++ s1)
1 subgoal
  
  T : eqType
  s1, s2, s3 : seq T
  ============================
  perm_eq (s1 ++ s2) (s1 ++ s3) = perm_eq s2 s3
1 subgoal
  
  T : eqType
  x : T
  s1, s2 : seq T
  ============================
  perm_eq (x :: s1) (x :: s2) = perm_eq s1 s2
1 subgoal
  
  T : eqType
  s1, s2, s3 : seq T
  ============================
  perm_eq (s2 ++ s1) (s3 ++ s1) = perm_eq s2 s3
1 subgoal
  
  T : eqType
  s1, s2, s3 : seq T
  ============================
  perm_eql ((s1 ++ s2) ++ s3) ((s1 ++ s3) ++ s2)
1 subgoal
  
  T : eqType
  s1, s2, s3 : seq T
  ============================
  perm_eql (s1 ++ s2 ++ s3) (s2 ++ s1 ++ s3)
1 subgoal
  
  T : eqType
  x : T
  s : seq T
  ============================
  perm_eql (rcons s x) (x :: s)
1 subgoal
  
  T : eqType
  n : nat
  s : seq T
  ============================
  perm_eql (rot n s) s
1 subgoal
  
  T : eqType
  n : nat
  s : seq T
  ============================
  perm_eql (rotr n s) s
1 subgoal
  
  T : eqType
  s : seq T
  ============================
  perm_eq s (rev s)
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  P : pred T
  ============================
  perm_eq s1 s2 -> perm_eq [seq x <- s1 | P x] [seq x <- s2 | P x]
1 subgoal
  
  T : eqType
  a : pred T
  s : seq T
  ============================
  perm_eql ([seq x <- s | a x] ++ [seq x <- s | (predC a) x]) s
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  perm_eq s1 s2 -> s1 =i s2
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  P : pred T
  ============================
  perm_eq s1 s2 -> all P s1 = all P s2
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  perm_eq s1 s2 -> size s1 = size s2
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  size s2 <= 1 -> perm_eq s1 s2 -> s1 = s2
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  uniq s1 -> {subset s1 <= s2} -> size s1 <= size s2
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  uniq s1 -> {subset s1 <= s2} -> size s2 <= size s1 -> uniq s2
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  uniq s1 -> s1 =i s2 -> uniq s2 = (size s2 == size s1)
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  uniq s1 ->
  {subset s1 <= s2} -> size s2 <= size s1 -> s1 =i s2 /\ size s1 = size s2
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  s1 =i s2 -> size s1 = size s2 -> uniq s1 = uniq s2
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  perm_eq s1 s2 -> uniq s1 = uniq s2
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  uniq s1 -> uniq s2 -> s1 =i s2 -> perm_eq s1 s2
1 subgoal
  
  T : eqType
  s : seq T
  ============================
  (forall x : T, (count_mem x) s = (x \in s)) -> uniq s
1 subgoal
  
  T : eqType
  P : seq T -> Type
  ============================
  (forall s1 s2 s3 : seq T, P (s1 ++ s2 ++ s3) -> P (s2 ++ s1 ++ s3)) ->
  forall s1 s2 : seq T, perm_eq s1 s2 -> P s1 -> P s2
1 subgoal
  
  T : eqType
  R : Type
  F : seq T -> R
  ============================
  (forall s1 s2 s3 : seq T, F (s1 ++ s2 ++ s3) = F (s2 ++ s1 ++ s3)) ->
  forall s1 s2 : seq T, perm_eq s1 s2 -> F s1 = F s2
1 subgoal
  
  n0 : nat
  T : Type
  T' : eqType
  s : seq T
  ============================
  size (rotr n0 s) = size s
1 subgoal
  
  n0 : nat
  T : Type
  T' : eqType
  s : seq T'
  ============================
  rotr n0 s =i s
1 subgoal
  
  n0 : nat
  T : Type
  T' : eqType
  s1, s2 : seq T
  ============================
  rotr (size s2) (s1 ++ s2) = s2 ++ s1
1 subgoal
  
  n0 : nat
  T : Type
  T' : eqType
  x : T
  s : seq T
  ============================
  rotr 1 (rcons s x) = x :: s
1 subgoal
  
  n0 : nat
  T : Type
  T' : eqType
  a : pred T
  s : seq T
  ============================
  has a (rotr n0 s) = has a s
1 subgoal
  
  n0 : nat
  T : Type
  T' : eqType
  s : seq T'
  ============================
  uniq (rotr n0 s) = uniq s
1 subgoal
  
  n0 : nat
  T : Type
  T' : eqType
  ============================
  cancel (rotr n0) (rot n0)
1 subgoal
  
  n0 : nat
  T : Type
  T' : eqType
  ============================
  injective (rotr n0)
1 subgoal
  
  n0 : nat
  T : Type
  T' : eqType
  s : seq T
  ============================
  rev (rotr n0 s) = rot n0 (rev s)
1 subgoal
  
  n0 : nat
  T : Type
  T' : eqType
  s : seq T
  ============================
  rev (rot n0 s) = rotr n0 (rev s)
1 subgoal
  
  T : Type
  m, n : nat
  s : seq T
  ============================
  m + n <= size s -> rot (m + n) s = rot m (rot n s)
1 subgoal
  
  T : Type
  n : nat
  s : seq T
  ============================
  n < size s -> rot n.+1 s = rot 1 (rot n s)
1 subgoal
  
  T : Type
  m, n : nat
  s : seq T
  ============================
  n <= size s ->
  m <= size s ->
  rot m (rot n s) = rot (if m + n <= size s then m + n else m + n - size s) s
1 subgoal
  
  T : Type
  m, n : nat
  s : seq T
  ============================
  rot m (rot n s) = rot n (rot m s)
1 subgoal
  
  T : Type
  m, n : nat
  s : seq T
  ============================
  rot m (rotr n s) = rotr n (rot m s)
1 subgoal
  
  T : Type
  m, n : nat
  s : seq T
  ============================
  rotr m (rotr n s) = rotr n (rotr m s)
1 subgoal
  
  n0 : nat
  T : Type
  s : seq T
  n : nat
  ============================
  mask (nseq n false) s = [::]
1 subgoal
  
  n0 : nat
  T : Type
  s : seq T
  n : nat
  ============================
  size s <= n -> mask (nseq n true) s = s
1 subgoal
  
  n0 : nat
  T : Type
  m : bitseq
  ============================
  mask m [::] = [::]
1 subgoal
  
  n0 : nat
  T : Type
  b : bool
  x : T
  ============================
  mask [:: b] [:: x] = nseq b x
1 subgoal
  
  n0 : nat
  T : Type
  b : bool
  m : bitseq
  x : T
  s : seq T
  ============================
  mask (b :: m) (x :: s) = nseq b x ++ mask m s
1 subgoal
  
  n0 : nat
  T : Type
  m : bitseq
  s : seq T
  ============================
  size m = size s -> size (mask m s) = count id m
1 subgoal
  
  n0 : nat
  T : Type
  m1, m2 : bitseq
  s1, s2 : seq T
  ============================
  size m1 = size s1 -> mask (m1 ++ m2) (s1 ++ s2) = mask m1 s1 ++ mask m2 s2
1 subgoal
  
  n0 : nat
  T : Type
  a : pred T
  b : bool
  m : bitseq
  x : T
  s : seq T
  ============================
  has a (mask (b :: m) (x :: s)) = b && a x || has a (mask m s)
1 subgoal
  
  n0 : nat
  T : Type
  a : pred T
  m : bitseq
  s : seq T
  ============================
  has a (mask m s) -> has a s
1 subgoal
  
  n0 : nat
  T : Type
  m : bitseq
  s : seq T
  ============================
  size m = size s ->
  mask (rot n0 m) (rot n0 s) = rot (count id (take n0 m)) (mask m s)
1 subgoal
  
  n0 : nat
  T : Type
  m : bitseq
  s : seq T
  ============================
  {m1 : seq bool | size m1 = size s & mask m s = mask m1 s}
1 subgoal
  
  n0 : nat
  T : eqType
  x : T
  b : bool
  m : bitseq
  y : T
  s : seq T
  ============================
  (x \in mask (b :: m) (y :: s)) = b && (x == y) || (x \in mask m s)
1 subgoal
  
  n0 : nat
  T : eqType
  x : T
  m : bitseq
  s : seq T
  ============================
  x \in mask m s -> x \in s
1 subgoal
  
  n0 : nat
  T : eqType
  s : seq T
  ============================
  uniq s -> forall m : bitseq, uniq (mask m s)
1 subgoal
  
  n0 : nat
  T : eqType
  m : bitseq
  s : seq T
  ============================
  size m = size s -> mask (rot n0 m) (rot n0 s) =i mask m s
1 subgoal
  
  T : eqType
  s : seq T
  ============================
  subseq [::] s
1 subgoal
  
  T : eqType
  s : seq T
  ============================
  subseq s [::] = (s == [::])
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  reflect (exists2 m : seq bool, size m = size s2 & s1 = mask m s2)
    (subseq s1 s2)
1 subgoal
  
  T : eqType
  m : bitseq
  s : seq T
  ============================
  subseq (mask m s) s
1 subgoal
  
  T : eqType
  ============================
  transitive subseq
1 subgoal
  
  T : eqType
  s : seq T
  ============================
  subseq s s
1 subgoal
  
  T : eqType
  s1, s2, s3, s4 : seq T
  ============================
  subseq s1 s3 -> subseq s2 s4 -> subseq (s1 ++ s2) (s3 ++ s4)
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  subseq s1 (s1 ++ s2)
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  subseq s2 (s1 ++ s2)
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  subseq s1 s2 -> {subset s1 <= s2}
1 subgoal
  
  T : eqType
  x : T
  s : seq T
  ============================
  subseq [:: x] s = (x \in s)
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  subseq s1 s2 -> size s1 <= size s2
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  subseq s1 s2 -> size s1 <= size s2 ?= iff (s1 == s2)
1 subgoal
  
  T : eqType
  s : seq T
  x : T
  ============================
  subseq s (x :: s)
1 subgoal
  
  T : eqType
  s : seq T
  x : T
  ============================
  subseq s (rcons s x)
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  subseq s1 s2 -> uniq s2 -> uniq s1
1 subgoal
  
  T : eqType
  x : T
  s : seq_predType T
  ============================
  x \notin s -> rem s = s
1 subgoal
  
  T : eqType
  x : T
  s : seq_predType T
  ============================
  x \in s -> perm_eq s (x :: rem s)
1 subgoal
  
  T : eqType
  x : T
  s : seq_predType T
  ============================
  x \in s -> size (rem s) = (size s).-1
1 subgoal
  
  T : eqType
  x : T
  s : seq T
  ============================
  subseq (rem s) s
1 subgoal
  
  T : eqType
  x : T
  s : seq T
  ============================
  uniq s -> uniq (rem s)
1 subgoal
  
  T : eqType
  x : T
  s : seq T
  ============================
  {subset rem s <= s}
1 subgoal
  
  T : eqType
  x : T
  s : seq T
  ============================
  uniq s -> rem s = [seq x0 <- s | (predC1 x) x0]
1 subgoal
  
  T : eqType
  x : T
  s : seq T
  ============================
  uniq s -> rem s =i [predD1 s & x]
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  x : T1
  s : seq T1
  ============================
  map (x :: s) = f x :: map s
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  x : T1
  ============================
  map (nseq n0 x) = nseq n0 (f x)
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  s1, s2 : seq T1
  ============================
  map (s1 ++ s2) = map s1 ++ map s2
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  s : seq T1
  ============================
  size (map s) = size s
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  s : seq T1
  ============================
  behead (map s) = map (behead s)
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  n : nat
  s : seq T1
  ============================
  n < size s -> nth x2 (map s) n = f (nth x1 s n)
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  s : seq T1
  x : T1
  ============================
  map (rcons s x) = rcons (map s) (f x)
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  s : seq T1
  x : T1
  ============================
  last (f x) (map s) = f (last x s)
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  s : seq T1
  x : T1
  ============================
  belast (f x) (map s) = map (belast x s)
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  a : pred T2
  s : seq T1
  ============================
  [seq x <- map s | a x] = map [seq x <- s | (preim f a) x]
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  a : pred T2
  s : seq T1
  ============================
  find a (map s) = find (preim f a) s
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  a : pred T2
  s : seq T1
  ============================
  has a (map s) = has (preim f a) s
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  a : pred T2
  s : seq T1
  ============================
  all a (map s) = all (preim f a) s
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  a : pred T2
  s : seq T1
  ============================
  count a (map s) = count (preim f a) s
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  s : seq T1
  ============================
  map (take n0 s) = take n0 (map s)
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  s : seq T1
  ============================
  map (drop n0 s) = drop n0 (map s)
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  s : seq T1
  ============================
  map (rot n0 s) = rot n0 (map s)
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  s : seq T1
  ============================
  map (rotr n0 s) = rotr n0 (map s)
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  s : seq T1
  ============================
  map (rev s) = rev (map s)
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  m : bitseq
  s : seq T1
  ============================
  map (mask m s) = mask m (map s)
1 subgoal
  
  n0 : nat
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T2
  ============================
  injective f -> injective map
1 subgoal
  
  T : Type
  a : pred T
  s : seq T
  ============================
  [seq x <- s | a x] = mask [seq a i | i <- s] s
1 subgoal
  
  T : eqType
  a : pred T
  s : seq T
  ============================
  subseq [seq x <- s | a x] s
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  a : pred T
  ============================
  subseq s1 [seq x <- s2 | a x] = all a s1 && subseq s1 s2
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  uniq s2 -> reflect (s1 = [seq x <- s2 | (mem s1) x]) (subseq s1 s2)
1 subgoal
  
  T : eqType
  s1, s2 : seq T
  ============================
  subseq s1 s2 -> {s3 : seq T | perm_eq s2 (s1 ++ s3)}
1 subgoal
  
  n0 : nat
  T1 : eqType
  x1 : T1
  T2 : eqType
  x2 : T2
  f : T1 -> T2
  s : seq T1
  x : T1
  ============================
  x \in s -> f x \in [seq f i | i <- s]
1 subgoal
  
  n0 : nat
  T1 : eqType
  x1 : T1
  T2 : eqType
  x2 : T2
  f : T1 -> T2
  s : seq T1
  y : T2
  ============================
  reflect (exists2 x : T1, x \in s & y = f x) (y \in [seq f i | i <- s])
1 subgoal
  
  n0 : nat
  T1 : eqType
  x1 : T1
  T2 : eqType
  x2 : T2
  f : T1 -> T2
  s : seq T1
  ============================
  uniq [seq f i | i <- s] -> uniq s
1 subgoal
  
  n0 : nat
  T1 : eqType
  x1 : T1
  T2 : eqType
  x2 : T2
  f : T1 -> T2
  s : seq T1
  ============================
  {in s &, injective f} -> uniq [seq f i | i <- s] = uniq s
1 subgoal
  
  n0 : nat
  T1 : eqType
  x1 : T1
  T2 : eqType
  x2 : T2
  f : T1 -> T2
  s1, s2 : seq T1
  ============================
  subseq s1 s2 -> subseq [seq f i | i <- s1] [seq f i | i <- s2]
1 subgoal
  
  n0 : nat
  T1 : eqType
  x1 : T1
  T2 : eqType
  x2 : T2
  f : T1 -> T2
  s : seq T1
  x0, x : T1
  ============================
  {in s &, injective f} ->
  x \in s -> nth x0 s (index (f x) [seq f i | i <- s]) = x
1 subgoal
  
  n0 : nat
  T1 : eqType
  x1 : T1
  T2 : eqType
  x2 : T2
  f : T1 -> T2
  s, t : seq T1
  ============================
  perm_eq s t -> perm_eq [seq f i | i <- s] [seq f i | i <- t]
1 subgoal
  
  n0 : nat
  T1 : eqType
  x1 : T1
  T2 : eqType
  x2 : T2
  f : T1 -> T2
  Hf : injective f
  s : seq T1
  x : T1
  ============================
  (f x \in [seq f i | i <- s]) = (x \in s)
1 subgoal
  
  n0 : nat
  T1 : eqType
  x1 : T1
  T2 : eqType
  x2 : T2
  f : T1 -> T2
  Hf : injective f
  s : seq T1
  x : T1
  ============================
  index (f x) [seq f i | i <- s] = index x s
1 subgoal
  
  n0 : nat
  T1 : eqType
  x1 : T1
  T2 : eqType
  x2 : T2
  f : T1 -> T2
  Hf : injective f
  s : seq T1
  ============================
  uniq [seq f i | i <- s] = uniq s
1 subgoal
  
  T1 : eqType
  T2 : Type
  s : seq T1
  fs : seq T2
  y0 : T2
  ============================
  {f : T1 -> T2 | uniq s -> size fs = size s -> [seq f i | i <- s] = fs}
1 subgoal
  
  T1, T2, T3 : Type
  s : seq T1
  ============================
  [seq x | x <- s] = s
1 subgoal
  
  T1, T2, T3 : Type
  f1, f2 : T1 -> T2
  ============================
  f1 =1 f2 -> map f1 =1 map f2
1 subgoal
  
  T1, T2, T3 : Type
  f1 : T2 -> T3
  f2 : T1 -> T2
  s : seq T1
  ============================
  [seq (f1 \o f2) i | i <- s] = [seq f1 i | i <- [seq f2 i | i <- s]]
1 subgoal
  
  T1, T2, T3 : Type
  f1 : T1 -> T2
  f2 : T2 -> T1
  ============================
  cancel f1 f2 -> cancel (map f1) (map f2)
1 subgoal
  
  T1 : eqType
  T2 : Type
  f1, f2 : T1 -> T2
  s : seq T1
  ============================
  {in s, f1 =1 f2} <-> [seq f1 i | i <- s] = [seq f2 i | i <- s]
1 subgoal
  
  T : eqType
  f : T -> T
  s : seq T
  ============================
  {in s, f =1 id} -> [seq f i | i <- s] = s
1 subgoal
  
  aT, rT : Type
  f : aT -> option rT
  g : rT -> aT
  ============================
  pcancel g f -> cancel (map g) pmap
1 subgoal
  
  aT, rT : Type
  f : aT -> option rT
  g : rT -> aT
  s : seq aT
  ============================
  size (pmap s) = count (fun x : aT => f x) s
1 subgoal
  
  aT, rT : Type
  f : aT -> option rT
  g : rT -> aT
  s : seq aT
  ============================
  [seq Some i | i <- pmap s] = [seq f i | i <- s & f i]
1 subgoal
  
  aT, rT : Type
  f : aT -> option rT
  g : rT -> aT
  fK : ocancel f g
  s : seq aT
  ============================
  [seq g i | i <- pmap s] = [seq x <- s | f x]
1 subgoal
  
  aT, rT : eqType
  f : aT -> option rT
  g : rT -> aT
  f1, f2 : aT -> option rT
  ============================
  f1 =1 f2 -> pmap f1 =1 pmap f2
1 subgoal
  
  aT, rT : eqType
  f : aT -> option rT
  g : rT -> aT
  s : seq aT
  u : rT
  ============================
  (u \in pmap f s) = (Some u \in [seq f i | i <- s])
1 subgoal
  
  aT, rT : eqType
  f : aT -> option rT
  g : rT -> aT
  fK : ocancel f g
  ============================
  pcancel g f -> forall (s : seq aT) (u : rT), (u \in pmap f s) = (g u \in s)
1 subgoal
  
  aT, rT : eqType
  f : aT -> option rT
  g : rT -> aT
  fK : ocancel f g
  s : seq aT
  ============================
  uniq s -> uniq (pmap f s)
1 subgoal
  
  T : Type
  p : pred T
  sT : subType p
  s : seq T
  ============================
  size (pmap (insub : T -> option sT) s) = count p s
1 subgoal
  
  T : eqType
  p : pred T
  sT : subType p
  insT := insub : T -> option sT
  s : seq T
  u : sub_eqType sT
  ============================
  (u \in pmap insT s) = (val u \in s)
1 subgoal
  
  T : eqType
  p : pred T
  sT : subType p
  insT := insub : T -> option sT
  s : seq T
  ============================
  uniq s -> uniq (pmap insT s)
1 subgoal
  
  m, n : nat
  ============================
  size (iota m n) = n
1 subgoal
  
  m, n1, n2 : nat
  ============================
  iota m (n1 + n2) = iota m n1 ++ iota (m + n1) n2
1 subgoal
  
  m1, m2, n : nat
  ============================
  iota (m1 + m2) n = [seq m1 + i | i <- iota m2 n]
1 subgoal
  
  p, m, n, i : nat
  ============================
  i < n -> nth p (iota m n) i = m + i
1 subgoal
  
  m, n : nat
  i : nat_eqType
  ============================
  (i \in iota m n) = (m <= i) && (i < m + n)
1 subgoal
  
  m, n : nat
  ============================
  uniq (iota m n)
1 subgoal
  
  T : Type
  x0 : T
  f : nat -> T
  n : nat
  ============================
  size (mkseq f n) = n
1 subgoal
  
  T : Type
  x0 : T
  f, g : nat -> T
  ============================
  f =1 g -> mkseq f =1 mkseq g
1 subgoal
  
  T : Type
  x0 : T
  f : nat -> T
  n, i : nat
  ============================
  i < n -> nth x0 (mkseq f n) i = f i
1 subgoal
  
  T : Type
  x0 : T
  s : seq T
  ============================
  mkseq (nth x0 s) (size s) = s
1 subgoal
  
  T : eqType
  f : nat -> T
  n : nat
  ============================
  injective f -> uniq (mkseq f n)
1 subgoal
  
  T : eqType
  s, t : seq T
  x0 : T
  It := iota 0 (size t) : seq nat
  ============================
  reflect
    (exists2 Is : seq nat_eqType,
       perm_eq Is It & s = [seq nth x0 t i | i <- Is]) 
    (perm_eq s t)
1 subgoal
  
  T1, T2 : Type
  h : T1 -> T2
  R : Type
  f : T2 -> R -> R
  z0 : R
  s1, s2 : seq T2
  ============================
  foldr f z0 (s1 ++ s2) = foldr f (foldr f z0 s2) s1
1 subgoal
  
  T1, T2 : Type
  h : T1 -> T2
  R : Type
  f : T2 -> R -> R
  z0 : R
  s : seq T1
  ============================
  foldr f z0 [seq h i | i <- s] = foldr (fun x : T1 => [eta f (h x)]) z0 s
1 subgoal
  
  x, n : nat
  ============================
  sumn (nseq n x) = x * n
1 subgoal
  
  s1, s2 : seq nat
  ============================
  sumn (s1 ++ s2) = sumn s1 + sumn s2
1 subgoal
  
  T : Type
  P : pred T
  s : seq T
  ============================
  sumn [seq (P i : nat) | i <- s] = count P s
1 subgoal
  
  s : seq nat
  n : nat
  ============================
  sumn (rcons s n) = sumn s + n
1 subgoal
  
  s : seq nat
  ============================
  sumn (rev s) = sumn s
1 subgoal
  
  s : seq nat
  ============================
  reflect (s = nseq (size s) 0) (sumn s == 0)
1 subgoal
  
  T, R : Type
  f : R -> T -> R
  z : R
  s : seq T
  ============================
  foldl z (rev s) = foldr (fun x : T => f^~ x) z s
1 subgoal
  
  T, R : Type
  f : R -> T -> R
  z : R
  s1, s2 : seq T
  ============================
  foldl z (s1 ++ s2) = foldl (foldl z s1) s2
1 subgoal
  
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T1 -> T2
  g : T1 -> T2 -> T1
  x : T1
  s : seq T1
  ============================
  size (pairmap x s) = size s
1 subgoal
  
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T1 -> T2
  g : T1 -> T2 -> T1
  x : T1
  s1, s2 : seq T1
  ============================
  pairmap x (s1 ++ s2) = pairmap x s1 ++ pairmap (last x s1) s2
1 subgoal
  
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T1 -> T2
  g : T1 -> T2 -> T1
  s : seq T1
  n : nat
  ============================
  n < size s ->
  forall x : T1, nth x2 (pairmap x s) n = f (nth x1 (x :: s) n) (nth x1 s n)
1 subgoal
  
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T1 -> T2
  g : T1 -> T2 -> T1
  x : T1
  s : seq T2
  ============================
  size (scanl x s) = size s
1 subgoal
  
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T1 -> T2
  g : T1 -> T2 -> T1
  x : T1
  s1, s2 : seq T2
  ============================
  scanl x (s1 ++ s2) = scanl x s1 ++ scanl (foldl g x s1) s2
1 subgoal
  
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T1 -> T2
  g : T1 -> T2 -> T1
  s : seq T2
  n : nat
  ============================
  n < size s -> forall x : T1, nth x1 (scanl x s) n = foldl g x (take n.+1 s)
1 subgoal
  
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T1 -> T2
  g : T1 -> T2 -> T1
  ============================
  (forall x : T1, cancel (g x) (f x)) ->
  forall x : T1, cancel (scanl x) (pairmap x)
1 subgoal
  
  T1 : Type
  x1 : T1
  T2 : Type
  x2 : T2
  f : T1 -> T1 -> T2
  g : T1 -> T2 -> T1
  ============================
  (forall x : T1, cancel (f x) (g x)) ->
  forall x : T1, cancel (pairmap x) (scanl x)
1 subgoal
  
  S, T : Type
  s : seq (S * T)
  ============================
  zip (unzip1 s) (unzip2 s) = s
1 subgoal
  
  S, T : Type
  s : seq S
  t : seq T
  ============================
  size s <= size t -> unzip1 (zip s t) = s
1 subgoal
  
  S, T : Type
  s : seq S
  t : seq T
  ============================
  size t <= size s -> unzip2 (zip s t) = t
1 subgoal
  
  S, T : Type
  s : seq S
  t : seq T
  ============================
  size s <= size t -> size (zip s t) = size s
1 subgoal
  
  S, T : Type
  s : seq S
  t : seq T
  ============================
  size t <= size s -> size (zip s t) = size t
1 subgoal
  
  S, T : Type
  s : seq S
  t : seq T
  ============================
  size (zip s t) = minn (size s) (size t)
1 subgoal
  
  S, T : Type
  s1, s2 : seq S
  t1, t2 : seq T
  ============================
  size s1 = size t1 -> zip (s1 ++ s2) (t1 ++ t2) = zip s1 t1 ++ zip s2 t2
1 subgoal
  
  S, T : Type
  x : S
  y : T
  s : seq S
  t : seq T
  i : nat
  ============================
  size s = size t -> nth (x, y) (zip s t) i = (nth x s i, nth y t i)
1 subgoal
  
  S, T : Type
  p : S * T
  s : seq S
  t : seq T
  i : nat
  ============================
  nth p (zip s t) i =
  (if i < size (zip s t) then (nth p.1 s i, nth p.2 t i) else p)
1 subgoal
  
  S, T : Type
  s1 : seq S
  s2 : seq T
  z1 : S
  z2 : T
  ============================
  size s1 = size s2 ->
  zip (rcons s1 z1) (rcons s2 z2) = rcons (zip s1 s2) (z1, z2)
1 subgoal
  
  S, T : Type
  s1 : seq S
  s2 : seq T
  ============================
  size s1 = size s2 -> rev (zip s1 s2) = zip (rev s1) (rev s2)
1 subgoal
  
  T : Type
  ss : seq (seq T)
  ============================
  size (flatten ss) = sumn (shape ss)
1 subgoal
  
  T : Type
  ss1, ss2 : seq (seq T)
  ============================
  flatten (ss1 ++ ss2) = flatten ss1 ++ flatten ss2
1 subgoal
  
  T : Type
  sh : seq nat
  s : seq T
  ============================
  size (reshape sh s) = size sh
1 subgoal
  
  T : Type
  sh : seq nat
  l : seq T
  n : nat
  ============================
  nth [::] (reshape sh l) n = take (nth 0 sh n) (drop (sumn (take n sh)) l)
1 subgoal
  
  T : Type
  ss : seq (seq T)
  ============================
  reshape (shape ss) (flatten ss) = ss
1 subgoal
  
  T : Type
  sh : seq nat
  s : seq T
  ============================
  size s <= sumn sh -> flatten (reshape sh s) = s
1 subgoal
  
  T : Type
  sh : seq nat
  s : seq T
  ============================
  sumn sh <= size s -> shape (reshape sh s) = sh
1 subgoal
  
  T : Type
  ss : seq (seq T)
  s : seq T
  ============================
  flatten (rcons ss s) = flatten ss ++ s
1 subgoal
  
  T : Type
  s : seq T
  ============================
  flatten [seq [:: x] | x <- s] = s
1 subgoal
  
  T : Type
  ss : seq (seq T)
  P : pred T
  ============================
  count P (flatten ss) = sumn [seq count P x | x <- ss]
1 subgoal
  
  T : Type
  ss : seq (seq T)
  P : pred T
  ============================
  [seq x <- flatten ss | P x] = flatten [seq [seq x <- i | P x] | i <- ss]
1 subgoal
  
  T : Type
  ss : seq (seq T)
  ============================
  rev (flatten ss) = flatten (rev [seq rev i | i <- ss])
1 subgoal
  
  T : Type
  ss : seq (seq T)
  i : nat
  ============================
  nth 0 (shape ss) i = size (nth [::] ss i)
1 subgoal
  
  T : Type
  ss : seq (seq T)
  ============================
  shape (rev ss) = rev (shape ss)
1 subgoal
  
  T : Type
  ss1, ss2 : seq (seq T)
  ============================
  flatten ss1 = flatten ss2 -> shape ss1 = shape ss2 -> ss1 = ss2
1 subgoal
  
  T : Type
  sh : seq nat
  s : seq T
  ============================
  size s = sumn sh ->
  rev (reshape sh s) = [seq rev i | i <- reshape (rev sh) (rev s)]
1 subgoal
  
  T : Type
  s : seq T
  sh : seq nat
  n : nat
  m := sumn sh : nat
  ============================
  m + n = size s ->
  reshape (rcons sh n) s = rcons (reshape sh (take m s)) (drop m s)
1 subgoal
  
  T : Type
  sh : seq nat
  r, c : nat
  ============================
  c < nth 0 sh r -> flatten_index sh r c < sumn sh
1 subgoal
  
  T : Type
  sh : seq nat
  i : nat
  ============================
  i < sumn sh -> reshape_index sh i < size sh
1 subgoal
  
  T : Type
  sh : seq nat
  i : nat
  ============================
  i < sumn sh -> reshape_offset sh i < nth 0 sh (reshape_index sh i)
1 subgoal
  
  T : Type
  sh : seq nat
  i : nat
  ============================
  flatten_index sh (reshape_index sh i) (reshape_offset sh i) = i
1 subgoal
  
  T : Type
  sh : seq nat
  r, c : nat
  ============================
  c < nth 0 sh r -> reshape_index sh (flatten_index sh r c) = r
1 subgoal
  
  T : Type
  sh : seq nat
  r, c : nat
  ============================
  c < nth 0 sh r -> reshape_offset sh (flatten_index sh r c) = c
1 subgoal
  
  T : Type
  x0 : T
  ss : seq (seq T)
  i : nat
  r := reshape_index (shape ss) i : nat
  ============================
  nth x0 (flatten ss) i =
  nth x0 (nth [::] ss r) (reshape_offset (shape ss) i)
1 subgoal
  
  T : Type
  sh : seq nat
  i1, i2 : nat
  r1 := reshape_index sh i1 : nat
  c1 := reshape_offset sh i1 : nat
  r2 := reshape_index sh i2 : nat
  c2 := reshape_offset sh i2 : nat
  ============================
  (i1 <= i2) = (r1 < r2) || (r1 == r2) && (c1 <= c2)
1 subgoal
  
  S : Type
  T : Type
  f : T -> S
  ss : seq (seq T)
  ============================
  [seq f i | i <- flatten ss] = flatten [seq [seq f i | i <- i] | i <- ss]
1 subgoal
  
  ss : seq (seq nat)
  ============================
  sumn (flatten ss) = sumn [seq sumn i | i <- ss]
1 subgoal
  
  T : Type
  S : Type
  f : T -> S
  sh : seq nat
  s : seq T
  ============================
  [seq [seq f i | i <- i] | i <- reshape sh s] =
  reshape sh [seq f i | i <- s]
1 subgoal
  
  S, T : eqType
  A : seq (seq T)
  x : T
  ============================
  reflect (exists2 s : seq_eqType T, s \in A & x \in s) (x \in flatten A)
1 subgoal
  
  S, T : eqType
  A : S -> seq T
  s : seq_predType S
  y : T
  ============================
  reflect (exists2 x : S, x \in s & y \in A x)
    (y \in flatten [seq A i | i <- s])
1 subgoal
  
  T : eqType
  s : seq T
  ============================
  perm_eq (flatten [seq nseq ((count_mem x) s) x | x <- undup s]) s
1 subgoal
  
  S, T, R : Type
  f : S -> T -> R
  s : seq S
  t : seq T
  ============================
  size (allpairs s t) = size s * size t
1 subgoal
  
  S, T, R : Type
  f : S -> T -> R
  s1, s2 : seq S
  t : seq T
  ============================
  allpairs (s1 ++ s2) t = allpairs s1 t ++ allpairs s2 t
1 subgoal
  
  S, T, R : eqType
  f : S -> T -> R
  s : seq S
  t : seq T
  z : R
  ============================
  reflect (exists p : S * T, [/\ p.1 \in s, p.2 \in t & z = f p.1 p.2])
    (z \in [seq f i j | i <- s, j <- t])
1 subgoal
  
  S, T, R : eqType
  f : S -> T -> R
  s1 : seq S
  t1 : seq T
  s2 : seq S
  t2 : seq T
  ============================
  s1 =i s2 ->
  t1 =i t2 ->
  [seq f i j | i <- s1, j <- t1] =i [seq f i j | i <- s2, j <- t2]
1 subgoal
  
  S, T, R : eqType
  f : S -> T -> R
  s : seq S
  t1, t2 : seq T
  ============================
  [seq f i j | i <- s, j <- t1 ++ t2]
    =i [seq f i j | i <- s, j <- t1] ++ [seq f i j | i <- s, j <- t2]
1 subgoal
  
  S, T, R : eqType
  f : S -> T -> R
  s : seq S
  t : seq T
  ============================
  uniq s ->
  uniq t ->
  {in [seq (x, y) | x <- s, y <- t] &, injective (prod_curry f)} ->
  uniq [seq f i j | i <- s, j <- t]
1 subgoal
  
  P0 : Prop
  Ps : seq Prop
  ============================
  all_iff P0 Ps ->
  forall m n : nat, nth P0 (P0 :: Ps) m -> nth P0 (P0 :: Ps) n
1 subgoal
  
  P0 : Prop
  Ps : seq Prop
  ============================
  all_iff P0 Ps ->
  forall m n : nat, nth P0 (P0 :: Ps) m <-> nth P0 (P0 :: Ps) n
1 subgoal
  
  T : Type
  U : Type
  p : T -> U -> bool
  s1 : seq T
  s2 : seq U
  ============================
  all2 s1 s2 =
  (size s1 == size s2) && all [pred xy | p xy.1 xy.2] (zip s1 s2)
COQC choice.v
1 subgoal
  
  ============================
  cancel decode code
1 subgoal
  
  ============================
  cancel code decode
1 subgoal
  
  s : seq nat
  ============================
  all (fun j : nat => j < code s) s
1 subgoal
  
  n : nat
  ============================
  all (ltn^~ n) (decode n)
1 subgoal
  
  T, T1, T2 : Type
  ============================
  cancel seq_of_opt ohead
1 subgoal
  
  T, T1, T2 : Type
  ============================
  cancel tag_of_pair pair_of_tag
1 subgoal
  
  T, T1, T2 : Type
  ============================
  cancel pair_of_tag tag_of_pair
1 subgoal
  
  T, T1, T2 : Type
  ============================
  pcancel opair_of_sum sum_of_opair
1 subgoal
  
  T, T1, T2 : Type
  ============================
  cancel xpredT (fun _ : bool => tt)
1 subgoal
  
  T : Type
  ============================
  pcancel encode decode
1 subgoal
  
  T : choiceType
  P : pred T
  n : nat
  x : T
  ============================
  find P n = Some x -> P x
1 subgoal
  
  T : choiceType
  P : pred T
  ============================
  (exists x : T, P x) -> exists n : nat, find P n
1 subgoal
  
  T : choiceType
  P, Q : pred T
  ============================
  P =1 Q -> find P =1 find Q
1 subgoal
  
  T : choiceType
  P : pred T
  exP : exists x : T, P x
  ============================
  {x : T | find P (ex_minn (complete exP)) = Some x}
1 subgoal
  
  T : choiceType
  P : pred T
  exP : exists x : T, P x
  ============================
  P (xchoose exP)
1 subgoal
  
  T : choiceType
  P, Q : pred T
  exP : exists x : T, P x
  exQ : exists x : T, Q x
  ============================
  P =1 Q -> xchoose exP = xchoose exQ
1 subgoal
  
  T : choiceType
  P : pred T
  ============================
  (exists x : T, P x) -> {x : T | P x}
1 subgoal
  
  T : choiceType
  P, Q : pred T
  ============================
  (exists2 x : T, P x & Q x) -> {x : T | P x & Q x}
1 subgoal
  
  T : choiceType
  vT : eqType
  lhs, rhs : T -> vT
  ============================
  (exists x : T, lhs x = rhs x) -> {x : T | lhs x = rhs x}
1 subgoal
  
  T : choiceType
  vT : eqType
  P : pred T
  lhs, rhs : T -> vT
  ============================
  (exists2 x : T, P x & lhs x = rhs x) -> {x : T | P x & lhs x = rhs x}
1 subgoal
  
  T : choiceType
  P : pred T
  x0 : T
  ============================
  P x0 -> P (choose P x0)
1 subgoal
  
  T : choiceType
  P : pred T
  x0, y0 : T
  ============================
  P x0 -> P y0 -> choose P x0 = choose P y0
1 subgoal
  
  T : choiceType
  P, Q : pred T
  ============================
  P =1 Q -> choose P =1 choose Q
1 subgoal
  
  T : choiceType
  sT : Type
  f : sT -> T
  f' : T -> option sT
  ============================
  pcancel f f' -> choiceMixin sT
1 subgoal
  
  T : choiceType
  ============================
  choiceMixin (seq T)
1 subgoal
  
  I : choiceType
  T_ : I -> choiceType
  ============================
  choiceMixin {i : I & T_ i}
1 subgoal
  
  ============================
  choiceMixin nat
1 subgoal
  
  T : countType
  ============================
  pcancel pickle unpickle
1 subgoal
  
  T : countType
  ============================
  ocancel pickle_inv pickle
1 subgoal
  
  T : countType
  ============================
  pcancel pickle pickle_inv
1 subgoal
  
  T : countType
  sT : Type
  f : sT -> T
  f' : T -> option sT
  ============================
  pcancel f f' -> pcancel (pickle \o f) (pcomp f' unpickle)
1 subgoal
  
  T : countType
  ============================
  pcancel pickle_seq unpickle_seq
1 subgoal
  
  I : countType
  T_ : I -> countType
  ============================
  pcancel pickle_tagged unpickle_tagged
1 subgoal
  
  ============================
  pcancel id Some
COQC path.v
1 subgoal
  
  n0 : nat
  T : Type
  x0_cycle : T
  e : rel T
  x : T
  p1, p2 : seq T
  ============================
  path x (p1 ++ p2) = path x p1 && path (last x p1) p2
1 subgoal
  
  n0 : nat
  T : Type
  x0_cycle : T
  e : rel T
  x : T
  p : seq T
  y : T
  ============================
  path x (rcons p y) = path x p && e (last x p) y
1 subgoal
  
  n0 : nat
  T : Type
  x0_cycle : T
  e : rel T
  x : T
  p : seq T
  x0 : T
  ============================
  reflect (forall i : nat, i < size p -> e (nth x0 (x :: p) i) (nth x0 p i))
    (path x p)
1 subgoal
  
  n0 : nat
  T : Type
  x0_cycle : T
  e : rel T
  p : seq T
  ============================
  cycle p = path (last x0_cycle p) p
1 subgoal
  
  n0 : nat
  T : Type
  x0_cycle : T
  e : rel T
  p : seq T
  ============================
  cycle (rot n0 p) = cycle p
1 subgoal
  
  n0 : nat
  T : Type
  x0_cycle : T
  e : rel T
  p : seq T
  ============================
  cycle (rotr n0 p) = cycle p
1 subgoal
  
  n0 : nat
  T : Type
  e, e' : T -> T -> bool
  ============================
  e =2 e' -> path e =2 path e'
1 subgoal
  
  n0 : nat
  T : Type
  e, e' : T -> T -> bool
  ============================
  e =2 e' -> cycle e =1 cycle e'
1 subgoal
  
  n0 : nat
  T : Type
  e, e' : rel T
  ============================
  subrel e e' -> forall (x : T) (p : seq T), path e x p -> path e' x p
1 subgoal
  
  n0 : nat
  T : Type
  e : rel T
  x : T
  p : seq T
  ============================
  path e (last x p) (rev (belast x p)) = path (fun z : T => e^~ z) x p
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p : seq T
  x : T
  i := index x p : nat
  ============================
  x \in p -> split x p (take i p) (drop i.+1 p)
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  x1 : T
  p : seq T
  x : T
  ============================
  x \in x1 :: p -> splitl x1 x p
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p : seq T
  x : T
  ============================
  x \in p -> splitr x p
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p : seq T
  x : T
  ============================
  next p x =
  (if x \in p
   then match p with
        | [::] => x
        | y :: p' => nth y p' (index x p)
        end
   else x)
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p : seq T
  x : T
  ============================
  prev p x =
  (if x \in p
   then match p with
        | [::] => x
        | y :: p' => nth y p (index x p')
        end
   else x)
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p : seq T
  x : T
  ============================
  (next p x \in p) = (x \in p)
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p : seq T
  x : T
  ============================
  (prev p x \in p) = (x \in p)
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p : seq T
  ============================
  ucycle p -> cycle e p
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p : seq T
  ============================
  ucycle p -> uniq p
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p : seq T
  x : T
  ============================
  cycle e p -> x \in p -> e x (next p x)
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p : seq T
  x : T
  ============================
  cycle e p -> x \in p -> e (prev p x) x
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p : seq T
  ============================
  ucycle (rot n0 p) = ucycle p
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p : seq T
  ============================
  ucycle (rotr n0 p) = ucycle p
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p : seq T
  x, y : T
  ============================
  mem2 p x y -> x \in p
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p : seq T
  x, y : T
  ============================
  x \notin p -> mem2 p x y = false
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p : seq T
  x, y : T
  ============================
  mem2 p x y -> y \in p
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p : seq T
  x, y : T
  ============================
  y \notin p -> mem2 p x y = false
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p1, p2 : seq T
  x, y : T
  ============================
  mem2 (p1 ++ p2) x y =
  mem2 p1 x y || mem2 p2 x y || (x \in p1) && (y \in p2)
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p1, p3 : seq T
  x, y : T
  p2 : seq T
  ============================
  mem2 (p1 ++ p3) x y -> mem2 (p1 ++ p2 ++ p3) x y
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p1, p3 : seq T
  x, y, z : T
  ============================
  mem2 (p1 ++ p3) x y -> mem2 (p1 ++ z :: p3) x y
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  x : T
  p : seq T
  y, z : T
  ============================
  mem2 (x :: p) y z = (if x == y then z \in x :: p else mem2 p y z)
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  x, y, z : T
  ============================
  mem2 [:: x] y z = (y == x) && (z == x)
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  y0 : T
  p : seq T
  x : T
  ============================
  mem2 p x (last y0 p) = (x \in p)
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p1, p2 : seq T
  x : T
  ============================
  x \notin p1 -> mem2 (p1 ++ p2) x =1 mem2 p2 x
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p1, p2 : seq T
  x, y : T
  ============================
  y \notin p2 -> mem2 (p1 ++ p2) x y = mem2 p1 x y
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p1, p2, p3 : seq T
  x, y : T
  ============================
  x \notin p2 ->
  y \notin p2 -> mem2 (p1 ++ p2 ++ p3) x y = mem2 (p1 ++ p3) x y
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  p : seq T
  x, y : T
  ============================
  mem2 p x y -> split2r x y p
1 subgoal
  
  n0 : nat
  T : eqType
  x0_cycle : T
  e : rel T
  x : T
  p : seq T
  ============================
  path e x p -> shorten_spec x p (last x p) (shorten x p)
1 subgoal
  
  T : eqType
  leT : rel T
  x : T
  s : seq T
  ============================
  path leT x s -> sorted s
1 subgoal
  
  T : eqType
  leT : rel T
  x : T
  s : seq_predType T
  ============================
  {in s, forall y : T, leT x y} -> path leT x s = sorted s
1 subgoal
  
  T : eqType
  leT : rel T
  leT_tr : transitive leT
  x : T
  s1, s2 : seq T
  ============================
  subseq s1 s2 -> path leT x s2 -> path leT x s1
1 subgoal
  
  T : eqType
  leT : rel T
  leT_tr : transitive leT
  x : T
  s : seq T
  ============================
  path leT x s -> all (leT x) s
1 subgoal
  
  T : eqType
  leT : rel T
  leT_tr : transitive leT
  s1, s2 : seq T
  ============================
  subseq s1 s2 -> sorted s2 -> sorted s1
1 subgoal
  
  T : eqType
  leT : rel T
  leT_tr : transitive leT
  a : pred T
  s : seq T
  ============================
  sorted s -> sorted [seq x <- s | a x]
1 subgoal
  
  T : eqType
  leT : rel T
  leT_tr : transitive leT
  ============================
  irreflexive leT -> forall s : seq T, sorted s -> uniq s
1 subgoal
  
  T : eqType
  leT : rel T
  leT_tr : transitive leT
  ============================
  antisymmetric leT ->
  forall s1 s2 : seq T, sorted s1 -> sorted s2 -> perm_eq s1 s2 -> s1 = s2
1 subgoal
  
  T : eqType
  leT : rel T
  leT_tr : transitive leT
  ============================
  irreflexive leT ->
  forall s1 s2 : seq T, sorted s1 -> sorted s2 -> s1 =i s2 -> s1 = s2
1 subgoal
  
  T : eqType
  leT : rel T
  leT_total : total leT
  x : T
  s1, s2 : seq T
  ============================
  path leT x s1 -> path leT x s2 -> path leT x (merge s1 s2)
1 subgoal
  
  T : eqType
  leT : rel T
  leT_total : total leT
  s1, s2 : seq T
  ============================
  sorted s1 -> sorted s2 -> sorted (merge s1 s2)
1 subgoal
  
  T : eqType
  leT : rel T
  leT_total : total leT
  s1, s2 : seq T
  ============================
  perm_eql (merge s1 s2) (s1 ++ s2)
1 subgoal
  
  T : eqType
  leT : rel T
  leT_total : total leT
  s1, s2 : seq T
  ============================
  merge s1 s2 =i s1 ++ s2
1 subgoal
  
  T : eqType
  leT : rel T
  leT_total : total leT
  s1, s2 : seq T
  ============================
  size (merge s1 s2) = size (s1 ++ s2)
1 subgoal
  
  T : eqType
  leT : rel T
  leT_total : total leT
  s1, s2 : seq T
  ============================
  uniq (merge s1 s2) = uniq (s1 ++ s2)
1 subgoal
  
  T : eqType
  leT : rel T
  leT_total : total leT
  s : seq T
  ============================
  sorted (sort s)
1 subgoal
  
  T : eqType
  leT : rel T
  leT_total : total leT
  s : seq T
  ============================
  perm_eql (sort s) s
1 subgoal
  
  T : eqType
  leT : rel T
  leT_total : total leT
  s : seq T
  ============================
  sort s =i s
1 subgoal
  
  T : eqType
  leT : rel T
  leT_total : total leT
  s : seq T
  ============================
  size (sort s) = size s
1 subgoal
  
  T : eqType
  leT : rel T
  leT_total : total leT
  s : seq T
  ============================
  uniq (sort s) = uniq s
1 subgoal
  
  T : eqType
  leT : rel T
  leT_total : total leT
  ============================
  transitive leT ->
  antisymmetric leT ->
  forall s1 s2 : seq T, reflect (sort s1 = sort s2) (perm_eq s1 s2)
1 subgoal
  
  T : eqType
  leT : rel T
  s : seq T
  ============================
  sorted leT (rev s) = sorted (fun y : T => leT^~ y) s
1 subgoal
  
  s : seq nat_eqType
  ============================
  sorted ltn s = uniq s && sorted leq s
1 subgoal
  
  i, n : nat
  ============================
  sorted leq (iota i n)
1 subgoal
  
  i, n : nat
  ============================
  sorted ltn (iota i n)
1 subgoal
  
  T : Type
  f : T -> T
  x : T
  n : nat
  ============================
  traject x n.+1 = x :: traject (f x) n
1 subgoal
  
  T : Type
  f : T -> T
  x : T
  n : nat
  ============================
  traject x n.+1 = rcons (traject x n) (iter n f x)
1 subgoal
  
  T : Type
  f : T -> T
  x : T
  n : nat
  ============================
  last x (traject (f x) n) = iter n f x
1 subgoal
  
  T : Type
  f : T -> T
  x : T
  n : nat
  ============================
  traject x n = iteri n (fun i : nat => rcons^~ (iter i f x)) [::]
1 subgoal
  
  T : Type
  f : T -> T
  x : T
  n : nat
  ============================
  size (traject x n) = n
1 subgoal
  
  T : Type
  f : T -> T
  i, n : nat
  ============================
  i < n -> forall x : T, nth x (traject x n) i = iter i f x
1 subgoal
  
  T : eqType
  f, f' : T -> T
  ============================
  f =1 f' -> fpath f =2 fpath f'
1 subgoal
  
  T : eqType
  f, f' : T -> T
  ============================
  f =1 f' -> fcycle f =1 fcycle f'
1 subgoal
  
  T : eqType
  f : T -> T
  x : T
  p : seq T
  ============================
  reflect (exists n : nat, p = traject f (f x) n) ((fpath f) x p)
1 subgoal
  
  T : eqType
  f : T -> T
  x : T
  n : nat
  ============================
  (fpath f) x (traject f (f x) n)
1 subgoal
  
  T : eqType
  f : T -> T
  x : T
  n : nat
  ============================
  reflect (forall m : nat, iter m f x \in traject f x n) (looping x n)
1 subgoal
  
  T : eqType
  f : T -> T
  x : T
  n : nat
  y : T
  ============================
  reflect (exists2 i : nat, i < n & y = iter i f x) (y \in traject f x n)
1 subgoal
  
  T : eqType
  f : T -> T
  x : T
  n : nat
  ============================
  uniq (traject f x n.+1) = ~~ looping x n
1 subgoal
  
  n0 : nat
  T : eqType
  e : rel T
  p : seq T
  Up : uniq p
  ============================
  cancel (next p) (prev p)
1 subgoal
  
  n0 : nat
  T : eqType
  e : rel T
  p : seq T
  Up : uniq p
  ============================
  cancel (prev p) (next p)
1 subgoal
  
  n0 : nat
  T : eqType
  e : rel T
  p : seq T
  Up : uniq p
  ============================
  (fcycle (next p)) p
1 subgoal
  
  n0 : nat
  T : eqType
  e : rel T
  p : seq T
  Up : uniq p
  ============================
  cycle (fun x y : T => x == prev p y) p
1 subgoal
  
  n0 : nat
  T : eqType
  e : rel T
  p : seq T
  Up : uniq p
  ============================
  (forall x : T, x \in p -> e x (next p x)) -> cycle e p
1 subgoal
  
  n0 : nat
  T : eqType
  e : rel T
  p : seq T
  Up : uniq p
  ============================
  (forall x : T, x \in p -> e (prev p x) x) -> cycle e p
1 subgoal
  
  n0 : nat
  T : eqType
  e : rel T
  p : seq T
  Up : uniq p
  ============================
  next (rot n0 p) =1 next p
1 subgoal
  
  n0 : nat
  T : eqType
  e : rel T
  p : seq T
  Up : uniq p
  ============================
  prev (rot n0 p) =1 prev p
1 subgoal
  
  n0 : nat
  T : eqType
  p : seq T
  Up : uniq p
  ============================
  next (rotr n0 p) =1 next p
1 subgoal
  
  n0 : nat
  T : eqType
  p : seq T
  Up : uniq p
  ============================
  prev (rotr n0 p) =1 prev p
1 subgoal
  
  T : eqType
  p : seq T
  ============================
  uniq p -> prev (rev p) =1 next p
1 subgoal
  
  T : eqType
  p : seq T
  ============================
  uniq p -> next (rev p) =1 prev p
1 subgoal
  
  T, T' : Type
  h : T' -> T
  e : rel T
  e' : rel T'
  b : pred T
  x' : T'
  p' : seq T'
  Bb : rel_base b
  ============================
  ~~ has (preim h b) (belast x' p') ->
  path e (h x') [seq h i | i <- p'] = path e' x' p'
1 subgoal
  
  T, T' : eqType
  h : T' -> T
  e : rel T
  e' : rel T'
  Ih : injective h
  x', y' : T'
  p' : seq T'
  ============================
  mem2 [seq h i | i <- p'] (h x') (h y') = mem2 p' x' y'
1 subgoal
  
  T, T' : eqType
  h : T' -> T
  e : rel T
  e' : rel T'
  Ih : injective h
  p : seq T'
  ============================
  uniq p -> forall x : T', next [seq h i | i <- p] (h x) = h (next p x)
1 subgoal
  
  T, T' : eqType
  h : T' -> T
  e : rel T
  e' : rel T'
  Ih : injective h
  p : seq T'
  ============================
  uniq p -> forall x : T', prev [seq h i | i <- p] (h x) = h (prev p x)
1 subgoal
  
  T : eqType
  i : nat
  p : seq T
  ============================
  uniq p -> {in p, arc (rot i p) =2 arc p}
1 subgoal
  
  T : eqType
  x, y : T
  p1, p2 : seq T
  p := x :: p1 ++ y :: p2 : seq T
  ============================
  uniq p -> arc p x y = x :: p1
1 subgoal
  
  T : eqType
  x, y : T
  p1, p2 : seq T
  p := x :: p1 ++ y :: p2 : seq T
  ============================
  uniq p -> arc p y x = y :: p2
1 subgoal
  
  T : eqType
  p : seq T
  x, y : T
  ============================
  uniq p -> x \in p -> y \in p -> x != y -> rot_to_arc_spec p x y
COQC div.v
1 subgoal
  
  m, d : nat
  ============================
  edivn_spec m d (edivn m d)
1 subgoal
  
  d, q, r : nat
  ============================
  r < d -> edivn (q * d + r) d = (q, r)
1 subgoal
  
  m, d : nat
  ============================
  m %% d = (edivn m d).2
1 subgoal
  
  m, d : nat
  ============================
  edivn m d = (m %/ d, m %% d)
1 subgoal
  
  m, d : nat
  ============================
  m = m %/ d * d + m %% d
1 subgoal
  
  d : nat
  ============================
  0 %/ d = 0
1 subgoal
  
  m : nat
  ============================
  m %/ 0 = 0
1 subgoal
  
  d : nat
  ============================
  0 %% d = 0
1 subgoal
  
  m : nat
  ============================
  m %% 0 = m
1 subgoal
  
  m, d : nat
  ============================
  m < d -> m %/ d = 0
1 subgoal
  
  q, m, d : nat
  ============================
  0 < d -> (q * d + m) %/ d = q + m %/ d
1 subgoal
  
  m, d : nat
  ============================
  0 < d -> (m * d) %/ d = m
1 subgoal
  
  m, d : nat
  ============================
  0 < d -> (d * m) %/ d = m
1 subgoal
  
  p, m, n : nat
  ============================
  0 < p -> n <= m -> p ^ (m - n) = p ^ m %/ p ^ n
1 subgoal
  
  m : nat
  ============================
  m %% 1 = 0
1 subgoal
  
  m : nat
  ============================
  m %/ 1 = m
1 subgoal
  
  d : nat
  ============================
  d %/ d = (0 < d)
1 subgoal
  
  p, m, d : nat
  ============================
  0 < p -> (p * m) %/ (p * d) = m %/ d
1 subgoal
  
  p, m, d : nat
  ============================
  0 < p -> (m * p) %/ (d * p) = m %/ d
1 subgoal
  
  m, d : nat
  ============================
  (m %% d < d) = (0 < d)
1 subgoal
  
  m, d : nat
  ============================
  0 < d -> m %% d < d
1 subgoal
  
  m, d : nat
  ============================
  m %/ d * d <= m
1 subgoal
  
  m, d : nat
  ============================
  m %% d <= m
1 subgoal
  
  m, d : nat
  ============================
  m %/ d <= m
1 subgoal
  
  m, d : nat
  ============================
  0 < d -> m < (m %/ d).+1 * d
1 subgoal
  
  m, n, d : nat
  ============================
  0 < d -> (m %/ d < n) = (m < n * d)
1 subgoal
  
  m, n, d : nat
  ============================
  0 < d -> (m <= n %/ d) = (m * d <= n)
1 subgoal
  
  m, d : nat
  ============================
  1 < d -> 0 < m -> m %/ d < m
1 subgoal
  
  d, m : nat
  ============================
  0 < d -> (0 < m %/ d) = (d <= m)
1 subgoal
  
  d, m, n : nat
  ============================
  m <= n -> m %/ d <= n %/ d
1 subgoal
  
  m, d, e : nat
  ============================
  0 < d -> d <= e -> m %/ e <= m %/ d
1 subgoal
  
  p, m, n : nat
  ============================
  (m + n) %/ p <= m %/ p + n %/ p + 1
1 subgoal
  
  k, m, p : nat
  ============================
  k %/ p - m %/ p <= (k - m) %/ p + 1
1 subgoal
  
  m, n, p : nat
  ============================
  m %/ (n * p) = (m %/ n) %/ p
1 subgoal
  
  m, n, p : nat
  ============================
  (m %/ n) %/ p = (m %/ p) %/ n
1 subgoal
  
  m, d : nat
  ============================
  m < d -> m %% d = m
1 subgoal
  
  m, d : nat
  ============================
  m %% d = m %[mod d]
1 subgoal
  
  p, m, d : nat
  ============================
  p * d + m = m %[mod d]
1 subgoal
  
  p, m, d : nat
  ============================
  0 < p -> p * (m %% d) = (p * m) %% (p * d)
1 subgoal
  
  p, m, d : nat
  ============================
  0 < p -> m %% d * p = (m * p) %% (d * p)
1 subgoal
  
  m, d : nat
  ============================
  d + m = m %[mod d]
1 subgoal
  
  m, d : nat
  ============================
  m + d = m %[mod d]
1 subgoal
  
  d : nat
  ============================
  d %% d = 0
1 subgoal
  
  p, d : nat
  ============================
  (p * d) %% d = 0
1 subgoal
  
  p, d : nat
  ============================
  (d * p) %% d = 0
1 subgoal
  
  m, n, d : nat
  ============================
  m %% d + n = m + n %[mod d]
1 subgoal
  
  m, n, d : nat
  ============================
  m + n %% d = m + n %[mod d]
1 subgoal
  
  m, n, d : nat
  ============================
  m %% d + n %% d = m + n %[mod d]
1 subgoal
  
  p, m, n, d : nat
  ============================
  ((p + m) %% d == (p + n) %% d) = (m %% d == n %% d)
1 subgoal
  
  p, m, n, d : nat
  ============================
  ((m + p) %% d == (n + p) %% d) = (m %% d == n %% d)
1 subgoal
  
  m, n, d : nat
  ============================
  m %% d * n = m * n %[mod d]
1 subgoal
  
  m, n, d : nat
  ============================
  m * (n %% d) = m * n %[mod d]
1 subgoal
  
  m, n, d : nat
  ============================
  m %% d * (n %% d) = m * n %[mod d]
1 subgoal
  
  m : nat
  ============================
  m %% 2 = odd m
1 subgoal
  
  m : nat
  ============================
  m %/ 2 = m./2
1 subgoal
  
  m, d : nat
  ============================
  odd d = false -> odd (m %% d) = odd m
1 subgoal
  
  m, n, a : nat
  ============================
  (a %% n) ^ m = a ^ m %[mod n]
1 subgoal
  
  d, m : nat
  ============================
  reflect (exists k : nat, m = k * d) (d %| m)
1 subgoal
  
  d : nat
  ============================
  d %| 0
1 subgoal
  
  n : nat
  ============================
  (0 %| n) = (n == 0)
1 subgoal
  
  d : nat
  ============================
  (d %| 1) = (d == 1)
1 subgoal
  
  m : nat
  ============================
  1 %| m
1 subgoal
  
  d, m : nat
  ============================
  0 < m -> d %| m -> 0 < d
1 subgoal
  
  m : nat
  ============================
  m %| m
1 subgoal
  
  d, m, n : nat
  ============================
  d %| n -> d %| m * n
1 subgoal
  
  d, m, n : nat
  ============================
  d %| m -> d %| m * n
1 subgoal
  
  d1, d2, m1, m2 : nat
  ============================
  d1 %| m1 -> d2 %| m2 -> d1 * d2 %| m1 * m2
1 subgoal
  
  n, d, m : nat
  ============================
  d %| n -> n %| m -> d %| m
1 subgoal
  
  d, m : nat
  ============================
  (d %| m) = (m %/ d * d == m)
1 subgoal
  
  n : nat
  ============================
  (2 %| n) = ~~ odd n
1 subgoal
  
  m, n : nat
  ============================
  m %| n -> odd n -> odd m
1 subgoal
  
  d, m : nat
  ============================
  d %| m -> m %/ d * d = m
1 subgoal
  
  d, m, n : nat
  ============================
  d %| m -> (m %/ d <= n) = (m <= n * d)
1 subgoal
  
  d, m, n : nat
  ============================
  d %| m -> (n < m %/ d) = (n * d < m)
1 subgoal
  
  d, m : nat
  n : nat_eqType
  ============================
  0 < d -> d %| m -> (n == m %/ d) = (n * d == m)
1 subgoal
  
  d, m, n : nat
  ============================
  0 < d -> d %| m -> (m == n * d) = (m %/ d == n)
1 subgoal
  
  d, m, n : nat
  ============================
  d %| m -> m %/ d * n = (m * n) %/ d
1 subgoal
  
  d, m, n : nat
  ============================
  d %| n -> m * (n %/ d) = (m * n) %/ d
1 subgoal
  
  d, m, n : nat
  ============================
  d %| m -> d %| n -> m * (n %/ d) = n * (m %/ d)
1 subgoal
  
  m, n, p : nat
  ============================
  p %| n -> m %/ (n %/ p) = (m * p) %/ n
1 subgoal
  
  m, n, d : nat
  ============================
  d %| m -> n %% m = n %[mod d]
1 subgoal
  
  d, m : nat
  ============================
  0 < m -> d %| m -> d <= m
1 subgoal
  
  n, d : nat
  ============================
  0 < n -> n < d -> (d %| n) = false
1 subgoal
  
  m, n : nat_eqType
  ============================
  (m == n) = (m %| n) && (n %| m)
1 subgoal
  
  p, d, m : nat
  ============================
  0 < p -> (p * d %| p * m) = (d %| m)
1 subgoal
  
  p, d, m : nat
  ============================
  0 < p -> (d * p %| m * p) = (d %| m)
1 subgoal
  
  p, d, m : nat
  ============================
  0 < p -> p %| d -> (d %/ p %| m) = (d %| m * p)
1 subgoal
  
  p, d, m : nat
  ============================
  p %| m -> (d %| m %/ p) = (d * p %| m)
1 subgoal
  
  d, m : nat
  ============================
  d %| m -> m %/ d %| m
1 subgoal
  
  p, m, n : nat
  ============================
  m <= n -> p ^ m %| p ^ n
1 subgoal
  
  p, m, n : nat
  ============================
  1 < p -> (p ^ m %| p ^ n) = (m <= n)
1 subgoal
  
  m, n, k : nat
  ============================
  m %| n -> m ^ k %| n ^ k
1 subgoal
  
  m, d, n : nat
  ============================
  d %| m -> (d %| m + n) = (d %| n)
1 subgoal
  
  n, d, m : nat
  ============================
  d %| n -> (d %| m + n) = (d %| m)
1 subgoal
  
  d, m, n : nat
  ============================
  d %| m -> d %| n -> d %| m + n
1 subgoal
  
  d, m, n : nat
  ============================
  d %| m + n -> (d %| m) = (d %| n)
1 subgoal
  
  d, m, n : nat
  ============================
  n <= m -> d %| m -> (d %| m - n) = (d %| n)
1 subgoal
  
  d, m, n : nat
  ============================
  n <= m -> d %| n -> (d %| m - n) = (d %| m)
1 subgoal
  
  d, m, n : nat
  ============================
  d %| m -> d %| n -> d %| m - n
1 subgoal
  
  k, d, m : nat
  ============================
  0 < k -> d %| m -> d %| m ^ k
1 subgoal
  
  m, n : nat
  ============================
  (0 < m) && (m <= n) -> m %| n`!
1 subgoal
  
  d, m, n : nat
  ============================
  n <= m -> (m %% d == n %% d) = (d %| m - n)
1 subgoal
  
  m, n, d : nat
  ============================
  d %| m -> (m + n) %/ d = m %/ d + n %/ d
1 subgoal
  
  m, n, d : nat
  ============================
  d %| n -> (m + n) %/ d = m %/ d + n %/ d
1 subgoal
  
  m, n : nat
  ============================
  gcdn m n = (if m == 0 then n else gcdn (n %% m) m)
1 subgoal
  
  ============================
  idempotent gcdn
1 subgoal
  
  ============================
  commutative gcdn
1 subgoal
  
  ============================
  left_id 0 gcdn
1 subgoal
  
  ============================
  right_id 0 gcdn
1 subgoal
  
  ============================
  left_zero 1 gcdn
1 subgoal
  
  ============================
  right_zero 1 gcdn
1 subgoal
  
  m, n : nat
  ============================
  gcdn m n %| n
1 subgoal
  
  m, n : nat
  ============================
  gcdn m n %| m
1 subgoal
  
  m, n : nat
  ============================
  (0 < gcdn m n) = (0 < m) || (0 < n)
1 subgoal
  
  k, m, n : nat
  ============================
  gcdn m (k * m + n) = gcdn m n
1 subgoal
  
  m, n : nat
  ============================
  gcdn m (m + n) = gcdn m n
1 subgoal
  
  m, n : nat
  ============================
  gcdn m (n + m) = gcdn m n
1 subgoal
  
  n, m : nat
  ============================
  gcdn n (m * n) = n
1 subgoal
  
  n, m : nat
  ============================
  gcdn n (n * m) = n
1 subgoal
  
  m, n : nat
  ============================
  reflect (gcdn m n = m) (m %| n)
1 subgoal
  
  m, n : nat
  ============================
  reflect (gcdn m n = n) (n %| m)
1 subgoal
  
  e, m, n : nat
  ============================
  e ^ minn m n = gcdn (e ^ m) (e ^ n)
1 subgoal
  
  m, n : nat
  ============================
  gcdn m (n %% m) = gcdn m n
1 subgoal
  
  m, n : nat
  ============================
  gcdn (m %% n) n = gcdn m n
1 subgoal
  
  n : nat
  ============================
  egcdn 0 n = (1, 0)
1 subgoal
  
  m, n : nat
  ============================
  0 < m -> egcdn_spec m n (egcdn m n)
1 subgoal
  
  m, n : nat
  ============================
  0 < m -> {a : nat | a < m & m %| gcdn m n + a * n}
1 subgoal
  
  m, n : nat
  ============================
  0 < n -> {a : nat | a < n & n %| gcdn m n + a * m}
1 subgoal
  
  p, m, n : nat
  ============================
  (p %| gcdn m n) = (p %| m) && (p %| n)
1 subgoal
  
  ============================
  right_commutative gcdn
1 subgoal
  
  ============================
  associative gcdn
1 subgoal
  
  ============================
  left_commutative gcdn
1 subgoal
  
  ============================
  interchange gcdn gcdn
1 subgoal
  
  ============================
  right_distributive muln gcdn
1 subgoal
  
  ============================
  left_distributive muln gcdn
1 subgoal
  
  d, m, n : nat
  ============================
  d %| m ->
  d %| n -> (forall d' : nat, d' %| m -> d' %| n -> d' %| d) -> gcdn m n = d
1 subgoal
  
  n, m : nat
  ============================
  n * (m %/ gcdn n m) = m * (n %/ gcdn n m)
1 subgoal
  
  ============================
  commutative lcmn
1 subgoal
  
  ============================
  left_zero 0 lcmn
1 subgoal
  
  ============================
  right_zero 0 lcmn
1 subgoal
  
  ============================
  left_id 1 lcmn
1 subgoal
  
  ============================
  right_id 1 lcmn
1 subgoal
  
  m, n : nat
  ============================
  lcmn m n * gcdn m n = m * n
1 subgoal
  
  m, n : nat
  ============================
  (0 < lcmn m n) = (0 < m) && (0 < n)
1 subgoal
  
  ============================
  right_distributive muln lcmn
1 subgoal
  
  ============================
  left_distributive muln lcmn
1 subgoal
  
  ============================
  associative lcmn
1 subgoal
  
  ============================
  left_commutative lcmn
1 subgoal
  
  ============================
  right_commutative lcmn
1 subgoal
  
  ============================
  interchange lcmn lcmn
1 subgoal
  
  d1, d2 : nat
  ============================
  d1 %| lcmn d1 d2
1 subgoal
  
  d1, d2 : nat
  ============================
  d2 %| lcmn d1 d2
1 subgoal
  
  d1, d2, m : nat
  ============================
  (lcmn d1 d2 %| m) = (d1 %| m) && (d2 %| m)
1 subgoal
  
  m, n : nat
  ============================
  lcmn m (m * n) = m * n
1 subgoal
  
  m, n : nat
  ============================
  lcmn n (m * n) = m * n
1 subgoal
  
  m, n : nat
  ============================
  reflect (lcmn m n = n) (m %| n)
1 subgoal
  
  m, n : nat
  ============================
  reflect (lcmn m n = m) (n %| m)
1 subgoal
  
  e, m, n : nat
  ============================
  e ^ maxn m n = lcmn (e ^ m) (e ^ n)
1 subgoal
  
  n : nat
  ============================
  coprime 1 n
1 subgoal
  
  n : nat
  ============================
  coprime n 1
1 subgoal
  
  m, n : nat
  ============================
  coprime m n = coprime n m
1 subgoal
  
  m, n : nat
  ============================
  coprime (m %% n) n = coprime m n
1 subgoal
  
  m, n : nat
  ============================
  coprime m (n %% m) = coprime m n
1 subgoal
  
  n : nat
  ============================
  coprime 2 n = odd n
1 subgoal
  
  n : nat
  ============================
  coprime n 2 = odd n
1 subgoal
  
  n : nat
  ============================
  coprime n.+1 n
1 subgoal
  
  n : nat
  ============================
  coprime n n.+1
1 subgoal
  
  n : nat
  ============================
  0 < n -> coprime n.-1 n
1 subgoal
  
  n : nat
  ============================
  0 < n -> coprime n n.-1
1 subgoal
  
  n, m : nat
  ============================
  0 < n ->
  reflect (exists u : nat * nat, u.1 * n - u.2 * m = 1) (coprime n m)
1 subgoal
  
  k, n : nat
  ============================
  0 < k -> (exists u : nat, (k * u) %% n = 1) -> coprime k n
1 subgoal
  
  m, n, p : nat
  ============================
  coprime m n -> (m * n %| p) = (m %| p) && (n %| p)
1 subgoal
  
  m, n, p : nat
  ============================
  coprime m n -> (m %| n * p) = (m %| p)
1 subgoal
  
  m, n, p : nat
  ============================
  coprime m p -> (m %| n * p) = (m %| n)
1 subgoal
  
  m, n : nat
  ============================
  m %| n -> odd m -> ~~ odd n -> 0 < n -> m.*2 <= n
1 subgoal
  
  m, n : nat
  ============================
  m %| n.-1 -> odd m -> odd n -> 1 < n -> m.*2 < n
1 subgoal
  
  p, m, n : nat
  ============================
  coprime p m -> gcdn p (m * n) = gcdn p n
1 subgoal
  
  p, m, n : nat
  ============================
  coprime p n -> gcdn p (m * n) = gcdn p m
1 subgoal
  
  p, m, n : nat
  ============================
  coprime p (m * n) = coprime p m && coprime p n
1 subgoal
  
  p, m, n : nat
  ============================
  coprime (m * n) p = coprime m p && coprime n p
1 subgoal
  
  k, m, n : nat
  ============================
  0 < k -> coprime (m ^ k) n = coprime m n
1 subgoal
  
  k, m, n : nat
  ============================
  0 < k -> coprime m (n ^ k) = coprime m n
1 subgoal
  
  k, m, n : nat
  ============================
  coprime m n -> coprime (m ^ k) n
1 subgoal
  
  k, m, n : nat
  ============================
  coprime m n -> coprime m (n ^ k)
1 subgoal
  
  m, n, p : nat
  ============================
  m %| n -> coprime n p -> coprime m p
1 subgoal
  
  m, n, p : nat
  ============================
  m %| n -> coprime p n -> coprime p m
1 subgoal
  
  n, m : nat
  ============================
  0 < n -> coprime (egcdn n m).1 (egcdn n m).2
1 subgoal
  
  m, n, k : nat
  ============================
  0 < k -> (m ^ k %| n ^ k) = (m %| n)
1 subgoal
  
  m1, m2 : nat
  co_m12 : coprime m1 m2
  x, y : nat
  ============================
  (x %% (m1 * m2) == y %% (m1 * m2)) =
  (x %% m1 == y %% m1) && (x %% m2 == y %% m2)
1 subgoal
  
  m1, m2 : nat
  co_m12 : coprime m1 m2
  r1, r2 : nat
  ============================
  chinese r1 r2 = r1 %[mod m1]
1 subgoal
  
  m1, m2 : nat
  co_m12 : coprime m1 m2
  r1, r2 : nat
  ============================
  chinese r1 r2 = r2 %[mod m2]
1 subgoal
  
  m1, m2 : nat
  co_m12 : coprime m1 m2
  x : nat
  ============================
  x = chinese (x %% m1) (x %% m2) %[mod m1 * m2]
COQC fintype.v
1 subgoal
  
  T : eqType
  e : seq T
  ============================
  uniq e -> e =i T -> axiom e
1 subgoal
  
  T : countType
  n : nat
  ubT : forall x : T, pickle x < n
  ============================
  axiom count_enum
1 subgoal
  
  T : finType
  ============================
  Finite.axiom (Finite.EnumDef.enum T)
1 subgoal
  
  T : finType
  P : pred T
  ============================
  enum T = Finite.EnumDef.enum T
1 subgoal
  
  T : finType
  P, A : pred T
  ============================
  enum A =i A
1 subgoal
  
  T : finType
  P : pred T
  ============================
  uniq (enum P)
1 subgoal
  
  T : finType
  P : pred T
  ============================
  enum pred0 = [::]
1 subgoal
  
  T : finType
  P : pred T
  x : T
  ============================
  enum (pred1 x) = [:: x]
1 subgoal
  
  T : finType
  P : pred T
  ============================
  pick_spec [pick x | P x ]
1 subgoal
  
  T : finType
  P, Q : pred T
  ============================
  P =i Q -> enum P = enum Q
1 subgoal
  
  T : finType
  P, Q : pred T
  ============================
  P =1 Q -> [pick x | P x ] = [pick x | Q x ]
1 subgoal
  
  T : finType
  A : pred T
  ============================
  #|A| = size (enum A)
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  A =i B -> #|A| = #|B|
1 subgoal
  
  T : finType
  A, B : pred T
  n : nat
  ============================
  #|A| = n -> B =i A -> #|B| = n
1 subgoal
  
  T : finType
  ============================
  #|pred0| = 0
1 subgoal
  
  T : finType
  ============================
  #|T| = size (enum T)
1 subgoal
  
  T : finType
  x : T
  ============================
  #|pred1 x| = 1
1 subgoal
  
  T : finType
  A : pred T
  ============================
  A =i pred0 -> #|A| = 0
1 subgoal
  
  T : finType
  A : pred T
  ============================
  A =i predT -> #|A| = size (enum T)
1 subgoal
  
  T : finType
  x : T
  A : pred T
  ============================
  A =i pred1 x -> #|A| = 1
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  #|[predU A & B]| + #|[predI A & B]| = #|A| + #|B|
1 subgoal
  
  T : finType
  B, A : pred T
  ============================
  #|[predI A & B]| + #|[predD A & B]| = #|A|
1 subgoal
  
  T : finType
  A : pred T
  ============================
  #|A| + #|[predC A]| = #|T|
1 subgoal
  
  T : finType
  x : T
  A : pred T
  ============================
  #|[predU1 x & A]| = (x \notin A) + #|A|
1 subgoal
  
  T : finType
  x, y : T
  ============================
  #|pred2 x y| = (x != y).+1
1 subgoal
  
  T : finType
  x : T
  ============================
  #|predC1 x| = #|T|.-1
1 subgoal
  
  T : finType
  x : T
  A : pred T
  ============================
  #|A| = (x \in A) + #|[predD1 A & x]|
1 subgoal
  
  T : finType
  A : pred T
  ============================
  #|A| <= #|T|
1 subgoal
  
  T : finType
  s : seq T
  ============================
  #|s| <= size s
1 subgoal
  
  T : finType
  s : seq T
  ============================
  reflect (#|s| = size s) (uniq s)
1 subgoal
  
  T : finType
  A : pred T
  ============================
  #|A| = 0 -> A =i pred0
1 subgoal
  
  T : finType
  P : pred T
  ============================
  reflect (P =1 pred0) (pred0b P)
1 subgoal
  
  T : finType
  P : pred T
  ============================
  reflect (exists x : T, P x) (~~ pred0b P)
1 subgoal
  
  T : finType
  A : pred T
  ============================
  reflect (exists i : T, i \in A) (0 < #|A|)
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  (A \subset B) = pred0b [predD A & B]
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  reflect {subset A <= B} (A \subset B)
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  reflect (exists2 x : T, x \in A & x \notin B) (~~ (A \subset B))
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  A \subset B -> #|A| <= #|B|
1 subgoal
  
  T : finType
  mA : mem_pred T
  ============================
  subset mA mA
1 subgoal
  
  T : finType
  pT : predType T
  pA : pT
  ============================
  pA \subset pA
1 subgoal
  
  T : finType
  A1, A2 : pred T
  ============================
  A1 =i A2 -> subset (mem A1) =1 subset (mem A2)
1 subgoal
  
  T : finType
  B1, B2 : pred T
  ============================
  B1 =i B2 -> (subset (T:=T))^~ (mem B1) =1 (subset (T:=T))^~ (mem B2)
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  A =i B -> A \subset B
1 subgoal
  
  T : finType
  A : pred T
  ============================
  A \subset T
1 subgoal
  
  T : finType
  A : pred T
  ============================
  T \subset A -> forall x : T, x \in A
1 subgoal
  
  T : finType
  A : pred T
  x : T
  ============================
  (pred1 x \subset A) = (x \in A)
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  reflect (A =i B) ((A \subset B) && (B \subset A))
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  #|A| = #|B| -> reflect (A =i B) (A \subset B)
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  A \subset B -> #|A| <= #|B| ?= iff (B \subset A)
1 subgoal
  
  T : finType
  A, B, C : pred T
  ============================
  A \subset B -> B \subset C -> A \subset C
1 subgoal
  
  T : finType
  s : seq T
  A : pred T
  ============================
  (s \subset A) = all (mem A) s
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  (A \proper B) = (A \subset B) && ~~ (B \subset A)
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  reflect (A \subset B /\ (exists2 x : T, x \in B & x \notin A))
    (A \proper B)
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  A \proper B -> A \subset B
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  A \proper B -> ~~ (B \subset A)
1 subgoal
  
  T : finType
  A, B, C : pred T
  ============================
  A \proper B -> B \proper C -> A \proper C
1 subgoal
  
  T : finType
  A, B, C : pred T
  ============================
  A \proper B -> B \subset C -> A \proper C
1 subgoal
  
  T : finType
  A, B, C : pred T
  ============================
  A \subset B -> B \proper C -> A \proper C
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  A \proper B -> #|A| < #|B|
1 subgoal
  
  T : finType
  A : pred T
  ============================
  ~~ (A \proper A)
1 subgoal
  
  T : finType
  A : pred T
  ============================
  (A \proper A) = false
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  A =i B -> proper (mem A) =1 proper (mem B)
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  A =i B -> (proper (T:=T))^~ (mem A) =1 (proper (T:=T))^~ (mem B)
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  [disjoint A & B] = [disjoint B & A]
1 subgoal
  
  T : finType
  A1, A2 : pred T
  ============================
  A1 =i A2 -> disjoint (mem A1) =1 disjoint (mem A2)
1 subgoal
  
  T : finType
  B1, B2 : pred T
  ============================
  B1 =i B2 -> (disjoint (T:=T))^~ (mem B1) =1 (disjoint (T:=T))^~ (mem B2)
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  (A \subset B) = [disjoint A & [predC B]]
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  [disjoint A & B] = (A \subset [predC B])
1 subgoal
  
  T : finType
  A, B, C : pred T
  ============================
  A \subset B -> [disjoint B & C] -> [disjoint A & C]
1 subgoal
  
  T : finType
  A : pred T
  ============================
  [disjoint pred0 & A]
1 subgoal
  
  T : finType
  A, B : pred T
  ============================
  A =i pred0 -> [disjoint A & B]
1 subgoal
  
  T : finType
  x : T
  A : pred T
  ============================
  [disjoint pred1 x & A] = (x \notin A)
1 subgoal
  
  T : finType
  x : T
  A, B : pred T
  ============================
  A =i pred1 x -> [disjoint A & B] = (x \notin B)
1 subgoal
  
  T : finType
  A, B, C : pred T
  ============================
  [disjoint predU A B & C] = [disjoint A & C] && [disjoint B & C]
1 subgoal
  
  T : finType
  x : T
  A, B : pred T
  ============================
  [disjoint predU1 x A & B] = (x \notin B) && [disjoint A & B]
1 subgoal
  
  T : finType
  x : T
  s : seq T
  B : pred T
  ============================
  [disjoint x :: s & B] = (x \notin B) && [disjoint s & B]
1 subgoal
  
  T : finType
  s : seq T
  A : pred T
  ============================
  [disjoint s & A] = ~~ has (mem A) s
1 subgoal
  
  T : finType
  s1, s2 : seq T
  A : pred T
  ============================
  [disjoint s1 ++ s2 & A] = [disjoint s1 & A] && [disjoint s2 & A]
1 subgoal
  
  T : finType
  P : pred T
  PP : T -> Prop
  viewP : forall x : T, reflect (PP x) (P x)
  ============================
  reflect (exists x : T, PP x) [exists x, P x]
1 subgoal
  
  T : finType
  P : pred T
  PP : T -> Prop
  viewP : forall x : T, reflect (PP x) (P x)
  ============================
  reflect (forall x : T, PP x) [forall x, P x]
1 subgoal
  
  T : finType
  rT : T -> eqType
  P : pred T
  ============================
  reflect (forall x : T, P x) [forall x, P x]
1 subgoal
  
  T : finType
  rT : T -> eqType
  f1, f2 : forall x : T, rT x
  ============================
  reflect (forall x : T, f1 x = f2 x) [forall x, f1 x == f2 x]
1 subgoal
  
  T : finType
  rT : T -> eqType
  D, P : pred T
  ============================
  reflect (forall x : T, D x -> P x) [forall (x | D x), P x]
1 subgoal
  
  T : finType
  rT : T -> eqType
  D, P : pred T
  PP : T -> Prop
  ============================
  (forall x : T, reflect (PP x) (P x)) ->
  reflect (forall x : T, D x -> PP x) [forall (x | D x), P x]
1 subgoal
  
  T : finType
  rT : T -> eqType
  D : pred T
  f1, f2 : forall x : T, rT x
  ============================
  reflect {in D, forall x : T, f1 x = f2 x} [forall x in D, f1 x == f2 x]
1 subgoal
  
  T : finType
  rT : T -> eqType
  P : pred T
  ============================
  reflect (exists x : T, P x) [exists x, P x]
1 subgoal
  
  T : finType
  rT : T -> eqType
  f1, f2 : forall x : T, rT x
  ============================
  reflect (exists x : T, f1 x = f2 x) [exists x, f1 x == f2 x]
1 subgoal
  
  T : finType
  rT : T -> eqType
  D, P : pred T
  ============================
  reflect (exists2 x : T, D x & P x) [exists (x | D x), P x]
1 subgoal
  
  T : finType
  rT : T -> eqType
  D, P : pred T
  PP : T -> Prop
  ============================
  (forall x : T, reflect (PP x) (P x)) ->
  reflect (exists2 x : T, D x & PP x) [exists (x | D x), P x]
1 subgoal
  
  T : finType
  rT : T -> eqType
  D : pred T
  f1, f2 : forall x : T, rT x
  ============================
  reflect (exists2 x : T, D x & f1 x = f2 x) [exists (x | D x), f1 x == f2 x]
1 subgoal
  
  T : finType
  rT : T -> eqType
  P1, P2 : pred T
  ============================
  P1 =1 P2 -> [exists x, P1 x] = [exists x, P2 x]
1 subgoal
  
  T : finType
  rT : T -> eqType
  D, P1, P2 : pred T
  ============================
  (forall x : T, D x -> P1 x = P2 x) ->
  [exists (x | D x), P1 x] = [exists (x | D x), P2 x]
1 subgoal
  
  T : finType
  rT : T -> eqType
  P1, P2 : pred T
  ============================
  P1 =1 P2 -> [forall x, P1 x] = [forall x, P2 x]
1 subgoal
  
  T : finType
  rT : T -> eqType
  D, P1, P2 : pred T
  ============================
  (forall x : T, D x -> P1 x = P2 x) ->
  [forall (x | D x), P1 x] = [forall (x | D x), P2 x]
1 subgoal
  
  T : finType
  rT : T -> eqType
  P : pred T
  ============================
  ~~ [forall x, P x] = [exists x, ~~ P x]
1 subgoal
  
  T : finType
  rT : T -> eqType
  D, P : pred T
  ============================
  ~~ [forall (x | D x), P x] = [exists (x | D x), ~~ P x]
1 subgoal
  
  T : finType
  rT : T -> eqType
  P : pred T
  ============================
  ~~ [exists x, P x] = [forall x, ~~ P x]
1 subgoal
  
  T : finType
  rT : T -> eqType
  D, P : pred T
  ============================
  ~~ [exists (x | D x), P x] = [forall (x | D x), ~~ P x]
1 subgoal
  
  I : finType
  i0 : I
  P : pred I
  F : I -> nat
  arg_pred := fun ord : nat -> nat -> bool =>
              [pred i | P i & [forall (j | P j), ord (F i) (F j)]]
   : (nat -> nat -> bool) -> simpl_pred I
  Pi0 : P i0
  FP := fun n : nat_eqType => [exists (i | P i), F i == n]
   : nat_eqType -> bool
  i : I
  ============================
  P i -> FP (F i)
1 subgoal
  
  I : finType
  i0 : I
  P : pred I
  F : I -> nat
  arg_pred := fun ord : nat -> nat -> bool =>
              [pred i | P i & [forall (j | P j), ord (F i) (F j)]]
   : (nat -> nat -> bool) -> simpl_pred I
  Pi0 : P i0
  FP := fun n : nat_eqType => [exists (i | P i), F i == n]
   : nat_eqType -> bool
  FP_F : forall i : I, P i -> FP (F i)
  ============================
  exists n : nat_eqType, FP n
1 subgoal
  
  I : finType
  i0 : I
  P : pred I
  F : I -> nat
  arg_pred := fun ord : nat -> nat -> bool =>
              [pred i | P i & [forall (j | P j), ord (F i) (F j)]]
   : (nat -> nat -> bool) -> simpl_pred I
  Pi0 : P i0
  FP := fun n : nat_eqType => [exists (i | P i), F i == n]
   : nat_eqType -> bool
  FP_F : forall i : I, P i -> FP (F i)
  exFP : exists n : nat_eqType, FP n
  ============================
  extremum_spec leq arg_min
1 subgoal
  
  I : finType
  i0 : I
  P : pred I
  F : I -> nat
  arg_pred := fun ord : nat -> nat -> bool =>
              [pred i | P i & [forall (j | P j), ord (F i) (F j)]]
   : (nat -> nat -> bool) -> simpl_pred I
  Pi0 : P i0
  FP := fun n : nat_eqType => [exists (i | P i), F i == n]
   : nat_eqType -> bool
  FP_F : forall i : I, P i -> FP (F i)
  exFP : exists n : nat_eqType, FP n
  ============================
  extremum_spec geq arg_max
1 subgoal
  
  aT : finType
  rT : eqType
  f : aT -> rT
  D : pred aT
  ============================
  reflect
    (exists2 x : aT,
       x \in D & exists2 y : aT, y \in [predD1 D & x] & f x = f y)
    (~~ dinjectiveb D)
1 subgoal
  
  aT : finType
  rT : eqType
  f : aT -> rT
  D : pred aT
  ============================
  reflect {in D &, injective f} (dinjectiveb D)
1 subgoal
  
  aT : finType
  rT : eqType
  f : aT -> rT
  ============================
  reflect (exists x : aT, exists2 y : aT, x != y & f x = f y) (~~ injectiveb)
1 subgoal
  
  aT : finType
  rT : eqType
  f : aT -> rT
  ============================
  reflect (injective f) injectiveb
1 subgoal
  
  T : finType
  T' : Type
  f : T -> T'
  A : pred T
  ============================
  size [seq f x | x in A] = #|A|
1 subgoal
  
  T : finType
  T' : Type
  f : T -> T'
  ============================
  size (codom f) = #|T|
1 subgoal
  
  T : finType
  T' : Type
  f : T -> T'
  ============================
  codom f = [seq f i | i <- enum T]
1 subgoal
  
  T : finType
  T' : eqType
  f : T -> T'
  A : pred T
  y : T'
  ============================
  reflect (exists2 x : T, x \in A & y = f x) (y \in image f A)
1 subgoal
  
  T : finType
  T' : eqType
  f : T -> T'
  y : T'
  ============================
  reflect (exists x : T, y = f x) (y \in codom f)
1 subgoal
  
  T : finType
  T' : eqType
  f : T -> T'
  A : pred T
  y : T'
  ============================
  y \in image f A -> {x : T | x \in A & f x = y}
1 subgoal
  
  T : finType
  T' : eqType
  f : T -> T'
  A : pred T
  y : T'
  fAy : y \in image f A
  ============================
  f (iinv fAy) = y
1 subgoal
  
  T : finType
  T' : eqType
  f : T -> T'
  A : pred T
  y : T'
  fAy : y \in image f A
  ============================
  iinv fAy \in A
1 subgoal
  
  T : finType
  T' : eqType
  f : T -> T'
  A : pred T
  ============================
  {in A &, injective f} ->
  forall (x : T) (fAfx : f x \in image f A), x \in A -> iinv fAfx = x
1 subgoal
  
  T : finType
  T' : eqType
  f : T -> T'
  A : pred T
  B : pred T'
  y : T'
  fAy : y \in image f A
  ============================
  (preim f B) (iinv fAy) = B y
1 subgoal
  
  T : finType
  T' : eqType
  f : T -> T'
  A : pred T
  x : T
  ============================
  x \in A -> f x \in image f A
1 subgoal
  
  T : finType
  T' : eqType
  f : T -> T'
  x : T
  ============================
  f x \in codom f
1 subgoal
  
  T : finType
  T' : eqType
  f : T -> T'
  A : pred T
  ============================
  {subset image f A <= codom f}
1 subgoal
  
  T : finType
  T' : eqType
  f : T -> T'
  ============================
  image f pred0 =i pred0
1 subgoal
  
  T : finType
  T' : eqType
  f : T -> T'
  injf : injective f
  A : pred T
  x : T
  ============================
  (f x \in image f A) = (x \in A)
1 subgoal
  
  T : finType
  T' : eqType
  f : T -> T'
  injf : injective f
  A : pred T
  ============================
  [preim f of image f A] =i A
1 subgoal
  
  T : finType
  T' : eqType
  f : T -> T'
  injf : injective f
  A : pred T
  y : T'
  fTy : y \in codom f
  ============================
  (y \in image f A) = (iinv fTy \in A)
1 subgoal
  
  T : finType
  T' : eqType
  f : T -> T'
  injf : injective f
  x : T
  fTfx : f x \in image f T
  ============================
  iinv fTfx = x
1 subgoal
  
  T : finType
  T' : eqType
  f : T -> T'
  injf : injective f
  B : pred T'
  ============================
  image f [preim f of B] =i [predI B & codom f]
1 subgoal
  
  T : finType
  T' : eqType
  f : T -> T'
  injf : injective f
  x0 : T
  ============================
  {on [pred y in codom f], bijective f}
1 subgoal
  
  T : finType
  T' : eqType
  f : T -> T'
  injf : injective f
  A : pred T
  x0 : T
  ============================
  {on [pred y in image f A], bijective f}
1 subgoal
  
  T : finType
  T' : eqType
  f : T -> T'
  s : seq T'
  ============================
  {subset s <= codom f} -> [seq f i | i <- preim_seq s] = s
1 subgoal
  
  aT : finType
  rT : eqType
  A : aT -> seq_predType rT
  P : pred aT
  y : rT
  ============================
  reflect (exists2 x : aT, x \in P & y \in A x)
    (y \in flatten [seq A x | x in P])
1 subgoal
  
  T, T' : finType
  f : T -> T'
  A : pred T
  ============================
  #|image f A| <= #|A|
1 subgoal
  
  T, T' : finType
  f : T -> T'
  A : pred T
  ============================
  {in A &, injective f} -> #|image f A| = #|A|
1 subgoal
  
  T, T' : finType
  f : T -> T'
  A : pred T
  ============================
  reflect {in A &, injective f} (#|image f A| == #|A|)
1 subgoal
  
  T, T' : finType
  f : T -> T'
  injf : injective f
  A : pred T
  ============================
  #|image f A| = #|A|
1 subgoal
  
  T, T' : finType
  f : T -> T'
  injf : injective f
  ============================
  #|codom f| = #|T|
1 subgoal
  
  T, T' : finType
  f : T -> T'
  injf : injective f
  B : pred T'
  ============================
  #|[preim f of B]| = #|[predI codom f & B]|
1 subgoal
  
  T, T' : finType
  f : T -> T'
  injf : injective f
  card_range : #|T| = #|T'|
  y : T'
  ============================
  y \in codom f
1 subgoal
  
  T, T' : finType
  f : T -> T'
  injf : injective f
  card_range : #|T| = #|T'|
  ============================
  bijective f
1 subgoal
  
  T : finType
  f, g : T -> T
  injf : injective f
  y : T
  ============================
  y \in codom f
1 subgoal
  
  T : finType
  f, g : T -> T
  injf : injective f
  ============================
  cancel f invF
1 subgoal
  
  T : finType
  f, g : T -> T
  injf : injective f
  ============================
  cancel invF f
1 subgoal
  
  T : finType
  f, g : T -> T
  injf : injective f
  ============================
  bijective f
1 subgoal
  
  T : finType
  f, g : T -> T
  fK : cancel f g
  ============================
  cancel g f
1 subgoal
  
  T : finType
  f, g : T -> T
  fK : cancel f g
  x, y : T
  ============================
  x = g y -> f x = y
1 subgoal
  
  T : finType
  f, g : T -> T
  fK : cancel f g
  x, y : T
  ============================
  g x = y -> x = f y
1 subgoal
  
  T : finType
  f, g : T -> T
  fK : cancel f g
  x : T
  y : T
  ============================
  (f x == y) = (x == g y)
1 subgoal
  
  T : finType
  f, g : T -> T
  fK : cancel f g
  ============================
  g =1 invF (can_inj fK)
1 subgoal
  
  T : finType
  T' : Type
  A, B : pred T
  f, g : T -> T'
  ============================
  A =i B -> f =1 g -> image f A = image g B
1 subgoal
  
  T : finType
  T' : Type
  f, g : T -> T'
  ============================
  f =1 g -> codom f = codom g
1 subgoal
  
  T : finType
  T' : Type
  f, g : T -> T
  injf : injective f
  injg : injective g
  ============================
  f =1 g -> invF injf =1 invF injg
1 subgoal
  
  ============================
  Finite.axiom [:: tt]
1 subgoal
  
  ============================
  #|{: unit}| = 1
1 subgoal
  
  ============================
  Finite.axiom [:: true; false]
1 subgoal
  
  ============================
  #|{: bool}| = 2
1 subgoal
  
  T : finType
  ============================
  Finite.axiom option_enum
1 subgoal
  
  T : finType
  ============================
  #|{: option T}| = #|T|.+1
1 subgoal
  
  eT : countType
  fT : finType
  f : eT -> fT
  g : fT -> option eT
  ============================
  pcancel f g -> Finite.axiom (undup (pmap g (enumF fT)))
1 subgoal
  
  T : Choice.Exports.choiceType
  P : pred T
  sT : subFinType
  x : T
  ============================
  (x \in codom (val : sT -> T)) = P x
1 subgoal
  
  T : finType
  P : pred T
  sT : subCountType P
  u : sub_eqType sT
  ============================
  u \in sub_enum
1 subgoal
  
  T : finType
  P : pred T
  sT : subCountType P
  ============================
  uniq sub_enum
1 subgoal
  
  T : finType
  P : pred T
  sT : subCountType P
  ============================
  [seq val i | i <- sub_enum] = enum P
1 subgoal
  
  T : finType
  P : pred T
  sT : subCountType P
  sfT : subFinType P
  ============================
  #|sfT| = #|[pred x | P x]|
1 subgoal
  
  T : finType
  P : pred T
  sT : subCountType P
  sfT : subFinType P
  A : pred sfT
  ============================
  A =i predT -> #|A| = #|[pred x | P x]|
1 subgoal
  
  T : finType
  P : pred T
  ============================
  #|{: {x : T | P x}}| = #|[pred x | P x]|
1 subgoal
  
  T : eqType
  s : seq T
  x : seq_sub_eqType
  ============================
  x \in seq_sub_enum
1 subgoal
  
  T : eqType
  s : seq T
  ============================
  uniq s -> [seq val i | i <- seq_sub_enum] = s
1 subgoal
  
  T : eqType
  s : seq T
  ============================
  pcancel seq_sub_pickle seq_sub_unpickle
1 subgoal
  
  T : eqType
  s : seq T
  ============================
  Finite.axiom seq_sub_enum
1 subgoal
  
  T : choiceType
  s : seq T
  ============================
  uniq s -> #|{: sT}| = size s
1 subgoal
  
  n : nat
  i : ordinal
  ============================
  i < n
1 subgoal
  
  n : nat
  ============================
  injective nat_of_ord
1 subgoal
  
  n : nat
  ============================
  [seq val i | i <- ord_enum] = iota 0 n
1 subgoal
  
  n : nat
  ============================
  uniq ord_enum
1 subgoal
  
  n : nat
  i : ordinal_eqType
  ============================
  i \in ord_enum
1 subgoal
  
  n : nat
  ============================
  [seq val i | i <- enum 'I_n] = iota 0 n
1 subgoal
  
  n : nat
  ============================
  size (enum 'I_n) = n
1 subgoal
  
  n : nat
  ============================
  #|'I_n| = n
1 subgoal
  
  n : nat
  i0 : ordinal_finType n
  m : nat
  ============================
  m < n -> nth i0 (enum 'I_n) m = m
1 subgoal
  
  n : nat
  i0, i : 'I_n
  ============================
  nth i0 (enum 'I_n) i = i
1 subgoal
  
  n : nat
  i : 'I_n
  ============================
  index i (enum 'I_n) = i
1 subgoal
  
  n, m : nat
  i : 'I_n
  ============================
  n <= m -> i < m
1 subgoal
  
  n, m : nat
  i : 'I_n
  ============================
  n = m -> i < m
1 subgoal
  
  n : nat
  eq_n : n = n
  i : 'I_n
  ============================
  cast_ord eq_n i = i
1 subgoal
  
  n1, n2, n3 : nat
  eq_n2 : n1 = n2
  eq_n3 : n2 = n3
  i : 'I_n1
  ============================
  cast_ord eq_n3 (cast_ord eq_n2 i) = cast_ord (etrans eq_n2 eq_n3) i
1 subgoal
  
  n1, n2 : nat
  eq_n : n1 = n2
  ============================
  cancel (cast_ord eq_n) (cast_ord (esym eq_n))
1 subgoal
  
  n1, n2 : nat
  eq_n : n1 = n2
  ============================
  cancel (cast_ord (esym eq_n)) (cast_ord eq_n)
1 subgoal
  
  n1, n2 : nat
  eq_n : n1 = n2
  ============================
  injective (cast_ord eq_n)
1 subgoal
  
  n : nat
  i : 'I_n
  ============================
  n - i.+1 < n
1 subgoal
  
  n : nat
  ============================
  involutive (rev_ord (n:=n))
1 subgoal
  
  n : nat
  ============================
  injective (rev_ord (n:=n))
1 subgoal
  
  T : finType
  x0 : T
  A : pred T
  ============================
  x0 \in A -> 0 < #|A|
1 subgoal
  
  T : finType
  A : pred T
  ============================
  'I_#|A| -> T
1 subgoal
  
  T : finType
  A : pred T
  i : 'I_#|[eta A]|
  ============================
  enum_val i \in A
1 subgoal
  
  T : finType
  A : pred T
  x : T
  i : 'I_#|[eta A]|
  ============================
  enum_val i = nth x (enum A) i
1 subgoal
  
  T : finType
  T' : Type
  y0 : T'
  f : T -> T'
  A : pred T
  i : 'I_#|A|
  ============================
  nth y0 [seq f x | x in A] i = f (enum_val i)
1 subgoal
  
  T : finType
  T' : Type
  y0 : T'
  f : T -> T'
  i : 'I_#|T|
  ============================
  nth y0 (codom f) i = f (enum_val i)
1 subgoal
  
  T : finType
  x00, x0 : T
  A : pred T
  Ax0 : x0 \in A
  ============================
  {in A, cancel (enum_rank_in Ax0)
           (fun n : ordinal_subType #|[eta A]| => nth x00 (enum A) n)}
1 subgoal
  
  T : finType
  x0 : T
  ============================
  cancel enum_rank (fun n : ordinal_subType #|[eta T]| => nth x0 (enum T) n)
1 subgoal
  
  T : finType
  x0 : T
  A : pred T
  Ax0 : x0 \in A
  ============================
  {in A, cancel (enum_rank_in Ax0) enum_val}
1 subgoal
  
  T : finType
  ============================
  cancel enum_rank enum_val
1 subgoal
  
  T : finType
  x0 : T
  A : pred T
  Ax0 : x0 \in A
  ============================
  cancel enum_val (enum_rank_in Ax0)
1 subgoal
  
  T : finType
  ============================
  cancel enum_val enum_rank
1 subgoal
  
  T : finType
  ============================
  injective enum_rank
1 subgoal
  
  T : finType
  A : pred T
  ============================
  injective enum_val
1 subgoal
  
  T : finType
  x0 : T
  A : pred T
  ============================
  x0 \in A -> {on A, bijective enum_val}
1 subgoal
  
  T : finType
  ============================
  bijective enum_rank
1 subgoal
  
  T : finType
  ============================
  bijective enum_val
1 subgoal
  
  T : finType
  U : T -> Type
  P : forall x : T, U x -> Prop
  ============================
  (forall x : T, exists u : U x, P x u) ->
  exists u : forall x : T, U x, forall x : T, P x (u x)
1 subgoal
  
  T : finType
  U : T -> Type
  P, Q : forall x : T, U x -> Prop
  ============================
  (forall x : T, exists2 u : U x, P x u & Q x u) ->
  exists2 u : forall x : T, U x,
    forall x : T, P x (u x) & forall x : T, Q x (u x)
1 subgoal
  
  n : nat
  i : ordinal_finType n
  ============================
  enum_rank i = cast_ord (esym (card_ord n)) i
1 subgoal
  
  n : nat
  i : 'I_#|[eta xpredT]|
  ============================
  enum_val i = cast_ord (card_ord n) i
1 subgoal
  
  h : nat
  ============================
  cancel (bump h) (unbump h)
1 subgoal
  
  h : nat_eqType
  i : nat
  ============================
  h != bump h i
1 subgoal
  
  h, i : nat
  ============================
  bump h (unbump h i) = (i == h) + i
1 subgoal
  
  h : nat_eqType
  ============================
  {in predC1 h, cancel (unbump h) (bump h)}
1 subgoal
  
  h, i, k : nat
  ============================
  bump (k + h) (k + i) = k + bump h i
1 subgoal
  
  h, i : nat
  ============================
  bump h.+1 i.+1 = (bump h i).+1
1 subgoal
  
  h, i, k : nat
  ============================
  unbump (k + h) (k + i) = k + unbump h i
1 subgoal
  
  h, i : nat
  ============================
  unbump h.+1 i.+1 = (unbump h i).+1
1 subgoal
  
  h, i, j : nat
  ============================
  (i <= bump h j) = (unbump h i <= j)
1 subgoal
  
  h, i, j : nat
  ============================
  (bump h i <= bump h j) = (i <= j)
1 subgoal
  
  h1, h2, i : nat
  ============================
  bump h1 (bump h2 i) = bump (bump h1 h2) (bump (unbump h2 h1) i)
1 subgoal
  
  n, h : nat
  i : 'I_n.-1
  ============================
  bump h i < n
1 subgoal
  
  n : nat
  h : 'I_n
  u : {j : ordinal_eqType n | j != h}
  ============================
  unbump h (val u) < n.-1
1 subgoal
  
  n : nat
  h, i : 'I_n
  ============================
  unlift_spec h i (unlift h i)
1 subgoal
  
  n : nat
  h : 'I_n
  i : 'I_n.-1
  ============================
  h != lift h i
1 subgoal
  
  n : nat
  h : 'I_n
  ============================
  unlift h h = None
1 subgoal
  
  n : nat
  h, i : 'I_n
  ============================
  h != i -> {j : 'I_n.-1 | i = lift h j & unlift h i = Some j}
1 subgoal
  
  n : nat
  h : 'I_n
  ============================
  injective (lift h)
1 subgoal
  
  n : nat
  h : 'I_n
  ============================
  pcancel (lift h) (unlift h)
1 subgoal
  
  m, n : nat
  i : 'I_m
  ============================
  i < m + n
1 subgoal
  
  m, n : nat
  i : 'I_n
  ============================
  m + i < m + n
1 subgoal
  
  m, n : nat
  i : 'I_(m + n)
  ============================
  m <= i -> i - m < n
1 subgoal
  
  m, n : nat
  i : 'I_(m + n)
  ============================
  split_spec i (split i) (i < m)
1 subgoal
  
  m, n : nat
  jk : 'I_m + 'I_n
  ============================
  (unsplit jk < m) = jk
1 subgoal
  
  m, n : nat
  ============================
  cancel split unsplit
1 subgoal
  
  m, n : nat
  ============================
  cancel unsplit split
1 subgoal
  
  n' : nat
  i : 'I_n'.+1
  ============================
  i <= n'
1 subgoal
  
  n', m : nat
  ============================
  n' - m < n'.+1
1 subgoal
  
  n' : nat
  i : 'I_n'.+1
  ============================
  n' - (n' - i) = i
1 subgoal
  
  n', m : nat
  ============================
  m < n'.+1 -> inord m = m
1 subgoal
  
  n' : nat
  i : 'I_n'.+1
  ============================
  inord i = i
1 subgoal
  
  n' : nat
  ============================
  enum 'I_n'.+1 = ord0 :: [seq lift ord0 i | i <- enum 'I_n']
1 subgoal
  
  n' : nat
  i : 'I_n'
  ============================
  lift ord_max i = i
1 subgoal
  
  n' : nat
  i : 'I_n'
  ============================
  lift ord0 i = i.+1
1 subgoal
  
  T1, T2 : finType
  A1 : pred T1
  A2 : pred T2
  ============================
  count [predX A1 & A2] prod_enum = #|A1| * #|A2|
1 subgoal
  
  T1, T2 : finType
  ============================
  Finite.axiom prod_enum
1 subgoal
  
  T1, T2 : finType
  A1 : pred T1
  A2 : pred T2
  ============================
  #|[predX A1 & A2]| = #|A1| * #|A2|
1 subgoal
  
  T1, T2 : finType
  ============================
  #|{: T1 * T2}| = #|T1| * #|T2|
1 subgoal
  
  T1, T2 : finType
  A : pred (T1 * T2)
  ============================
  A =i predT -> #|A| = #|T1| * #|T2|
1 subgoal
  
  I : finType
  T_ : I -> finType
  ============================
  Finite.axiom tag_enum
1 subgoal
  
  I : finType
  T_ : I -> finType
  ============================
  #|{: {i : I & T_ i}}| = sumn [seq #|T_ i| | i <- enum I]
1 subgoal
  
  T1, T2 : finType
  ============================
  uniq sum_enum
1 subgoal
  
  T1, T2 : finType
  u : sum_eqType T1 T2
  ============================
  u \in sum_enum
1 subgoal
  
  T1, T2 : finType
  ============================
  #|{: T1 + T2}| = #|T1| + #|T2|
COQC fingraph.v
1 subgoal
  
  T : finType
  g : T -> seq T
  n : nat
  v, a : seq T
  ============================
  v \subset foldl (dfs n) v a
1 subgoal
  
  T : finType
  g : T -> seq T
  n : nat
  x, y : T
  v : seq T
  ============================
  #|T| <= #|v| + n ->
  y \notin v -> reflect (dfs_path v x y) (y \in dfs n v x)
1 subgoal
  
  T : finType
  g : T -> seq T
  x, y : T
  ============================
  reflect (exists2 p : seq T, path (grel g) x p & y = last x p)
    (y \in dfs #|T| [::] x)
1 subgoal
  
  T : finType
  e : rel T
  ============================
  grel rgraph =2 e
1 subgoal
  
  T : finType
  e : rel T
  x, y : T
  ============================
  reflect (exists2 p : seq T, path e x p & y = last x p) (connect x y)
1 subgoal
  
  T : finType
  e : rel T
  ============================
  transitive connect
1 subgoal
  
  T : finType
  e : rel T
  x : T
  ============================
  connect x x
1 subgoal
  
  T : finType
  e : rel T
  x, y : T
  ============================
  x = y -> connect x y
1 subgoal
  
  T : finType
  e : rel T
  x, y : T
  ============================
  e x y -> connect x y
1 subgoal
  
  T : finType
  e : rel T
  x : T
  p : seq T
  ============================
  path e x p -> subpred (mem (x :: p)) (connect x)
1 subgoal
  
  T : finType
  e : rel T
  x : T
  ============================
  connect x (root x)
1 subgoal
  
  T : finType
  e : rel T
  sym_e : connect_sym
  ============================
  left_transitive connect
1 subgoal
  
  T : finType
  e : rel T
  sym_e : connect_sym
  ============================
  right_transitive connect
1 subgoal
  
  T : finType
  e : rel T
  sym_e : connect_sym
  x, y : T
  ============================
  e x y -> connect x =1 connect y
1 subgoal
  
  T : finType
  e : rel T
  sym_e : connect_sym
  x, y : T
  ============================
  e x y -> connect^~ x =1 connect^~ y
1 subgoal
  
  T : finType
  e : rel T
  sym_e : connect_sym
  x, y : T
  ============================
  reflect (root x = root y) (connect x y)
1 subgoal
  
  T : finType
  e : rel T
  sym_e : connect_sym
  x : T
  ============================
  root (root x) = root x
1 subgoal
  
  T : finType
  e : rel T
  sym_e : connect_sym
  x : T
  ============================
  roots (root x)
1 subgoal
  
  T : finType
  e : rel T
  sym_e : connect_sym
  x, y : T
  ============================
  (root x == root y) = connect x y
1 subgoal
  
  T : finType
  e, e' : rel T
  ============================
  subrel e (connect e') -> subrel (connect e) (connect e')
1 subgoal
  
  T : finType
  e, e' : rel T
  ============================
  connect_sym e -> connect_sym e' -> connect_sym (relU e e')
1 subgoal
  
  T : finType
  e, e' : rel T
  ============================
  e =2 e' -> connect e =2 connect e'
1 subgoal
  
  T : finType
  e, e' : rel T
  ============================
  connect e =2 connect e' -> n_comp_mem e =1 n_comp_mem e'
1 subgoal
  
  T : finType
  e : rel T
  a, a' : pred T
  ============================
  a =i a' -> n_comp e a = n_comp e a'
1 subgoal
  
  T : finType
  a : pred T
  e : rel T
  ============================
  n_comp e T = n_comp e a + n_comp e [predC a]
1 subgoal
  
  T : finType
  e, e' : rel T
  ============================
  e =2 e' -> root e =1 root e'
1 subgoal
  
  T : finType
  e, e' : rel T
  ============================
  e =2 e' -> roots e =1 roots e'
1 subgoal
  
  T : finType
  e : rel T
  sym_e : connect_sym e
  ============================
  connect e =2 connect (fun x : T => e^~ x)
1 subgoal
  
  T : finType
  e : rel T
  sym_e : connect_sym e
  a : pred T
  ============================
  (forall x y : T, e x y -> x \in a -> y \in a) -> closed e a
1 subgoal
  
  T : finType
  e : rel T
  sym_e : connect_sym e
  a : pred T
  ============================
  closed e a -> forall x y : T, connect e x y -> (x \in a) = (y \in a)
1 subgoal
  
  T : finType
  e : rel T
  sym_e : connect_sym e
  x : T
  ============================
  closed e (connect e x)
1 subgoal
  
  T : finType
  e : rel T
  sym_e : connect_sym e
  a : pred T
  ============================
  closed e a -> closed e [predC a]
1 subgoal
  
  T : finType
  e : rel T
  sym_e : connect_sym e
  a : pred T
  ============================
  closed e (closure e a)
1 subgoal
  
  T : finType
  e : rel T
  sym_e : connect_sym e
  a : pred T
  ============================
  {subset a <= closure e a}
1 subgoal
  
  T : finType
  e : rel T
  sym_e : connect_sym e
  a : pred T
  ============================
  a \subset closure e a
1 subgoal
  
  T : finType
  e : rel T
  sym_e : connect_sym e
  x, y : T
  ============================
  n_comp e (closure e (pred2 x y)) = (~~ connect e x y).+1
1 subgoal
  
  T : finType
  e : rel T
  sym_e : connect_sym e
  x : T
  ============================
  n_comp e (connect e x) = 1
1 subgoal
  
  T : finType
  f : T -> T
  n : nat
  x : T
  ============================
  (fconnect f) x (iter n f x)
1 subgoal
  
  T : finType
  f : T -> T
  x : T
  ============================
  (fconnect f) x (f x)
1 subgoal
  
  T : finType
  f : T -> T
  x : T
  ============================
  (fconnect f) x (finv x)
1 subgoal
  
  T : finType
  f : T -> T
  x : T
  ============================
  (order x).-1.+1 = order x
1 subgoal
  
  T : finType
  f : T -> T
  x : T
  ============================
  size (orbit x) = order x
1 subgoal
  
  T : finType
  f : T -> T
  x : T
  ============================
  looping f x (order x)
1 subgoal
  
  T : finType
  f : T -> T
  x, y : T
  ============================
  (fconnect f) x y = (y \in orbit x)
1 subgoal
  
  T : finType
  f : T -> T
  x : T
  ============================
  uniq (orbit x)
1 subgoal
  
  T : finType
  f : T -> T
  x, y : T
  ============================
  (fconnect f) x y -> findex x y < order x
1 subgoal
  
  T : finType
  f : T -> T
  x : T
  i : nat
  ============================
  i < order x -> findex x (iter i f x) = i
1 subgoal
  
  T : finType
  f : T -> T
  x, y : T
  ============================
  (fconnect f) x y -> iter (findex x y) f x = y
1 subgoal
  
  T : finType
  f : T -> T
  x : T
  ============================
  findex x x = 0
1 subgoal
  
  T : finType
  f : T -> T
  T' : eqType
  k : T -> T'
  ============================
  invariant f k =1 xpredT -> forall x y : T, (fconnect f) x y -> k x = k y
1 subgoal
  
  T : finType
  f : T -> T
  p : seq T
  f_p : (fcycle f) p
  Up : uniq p
  x : T
  p_x : x \in p
  y : T
  ============================
  (fconnect f) x y = (y \in p)
1 subgoal
  
  T : finType
  f : T -> T
  p : seq T
  f_p : (fcycle f) p
  Up : uniq p
  x : T
  p_x : x \in p
  ============================
  order x = size p
1 subgoal
  
  T : finType
  f : T -> T
  p : seq T
  f_p : (fcycle f) p
  Up : uniq p
  x : T
  p_x : x \in p
  ============================
  {i : nat | orbit x = rot i p}
1 subgoal
  
  T : finType
  f : T -> T
  S : pred_class
  f_in : {in S, forall x : T, f x \in S}
  injf : {in S &, injective f}
  ============================
  {in S, forall (x : T) (i : nat), iter i f x \in S}
1 subgoal
  
  T : finType
  f : T -> T
  S : pred_class
  f_in : {in S, forall x : T, f x \in S}
  injf : {in S &, injective f}
  ============================
  {in S, forall x : T, finv x \in S}
1 subgoal
  
  T : finType
  f : T -> T
  S : pred_class
  f_in : {in S, forall x : T, f x \in S}
  injf : {in S &, injective f}
  ============================
  {in S, cancel finv f}
1 subgoal
  
  T : finType
  f : T -> T
  S : pred_class
  f_in : {in S, forall x : T, f x \in S}
  injf : {in S &, injective f}
  ============================
  {in S, cancel f finv}
1 subgoal
  
  T : finType
  f : T -> T
  S : pred_class
  f_in : {in S, forall x : T, f x \in S}
  injf : {in S &, injective f}
  ============================
  {in S &, injective finv}
1 subgoal
  
  T : finType
  f : T -> T
  S : pred_class
  f_in : {in S, forall x : T, f x \in S}
  injf : {in S &, injective f}
  ============================
  {in S &, forall x y : T, (fconnect f) x y = (fconnect f) y x}
1 subgoal
  
  T : finType
  f : T -> T
  S : pred_class
  f_in : {in S, forall x : T, f x \in S}
  injf : {in S &, injective f}
  ============================
  {in S, forall x : T, iter (order x) f x = x}
1 subgoal
  
  T : finType
  f : T -> T
  S : pred_class
  f_in : {in S, forall x : T, f x \in S}
  injf : {in S &, injective f}
  n : nat
  ============================
  {in S, forall x : T, n <= order x -> iter n finv x = iter (order x - n) f x}
1 subgoal
  
  T : finType
  f : T -> T
  S : pred_class
  f_in : {in S, forall x : T, f x \in S}
  injf : {in S &, injective f}
  ============================
  {in S, forall x : T, (fcycle f) (orbit x)}
1 subgoal
  
  T : finType
  f : T -> T
  S : pred_class
  f_in : {in S, forall x : T, f x \in S}
  injf : {in S &, injective f}
  p : seq T
  x : T
  ============================
  (x \in S) && (fpath finv) x p =
  (last x p \in S) && (fpath f) (last x p) (rev (belast x p))
1 subgoal
  
  T : finType
  f : T -> T
  S : pred_class
  f_in : {in S, forall x : T, f x \in S}
  injf : {in S &, injective f}
  p : seq T
  ============================
  {in S, forall x : T,
         (fpath finv) x p -> (fpath f) (last x p) (rev (belast x p))}
1 subgoal
  
  T : finType
  f : T -> T
  S : pred_class
  f_in : {in S, forall x : T, f x \in S}
  injf : {in S &, injective f}
  p : seq T
  x : T
  ============================
  last x p \in S ->
  (fpath f) (last x p) (rev (belast x p)) -> (fpath finv) x p
1 subgoal
  
  T : finType
  f : T -> T
  injf : injective f
  ============================
  cancel finv f
1 subgoal
  
  T : finType
  f : T -> T
  injf : injective f
  ============================
  cancel f finv
1 subgoal
  
  T : finType
  f : T -> T
  injf : injective f
  ============================
  bijective f
1 subgoal
  
  T : finType
  f : T -> T
  injf : injective f
  ============================
  bijective finv
1 subgoal
  
  T : finType
  f : T -> T
  injf : injective f
  ============================
  injective finv
1 subgoal
  
  T : finType
  f : T -> T
  injf : injective f
  x, y : T
  ============================
  (fconnect f) x y = (fconnect f) y x
1 subgoal
  
  T : finType
  f : T -> T
  injf : injective f
  symf := fconnect_sym : forall x y : T, (fconnect f) x y = (fconnect f) y x
  x : T
  ============================
  iter (order x) f x = x
1 subgoal
  
  T : finType
  f : T -> T
  injf : injective f
  symf := fconnect_sym : forall x y : T, (fconnect f) x y = (fconnect f) y x
  n : nat
  x : T
  ============================
  n <= order x -> iter n finv x = iter (order x - n) f x
1 subgoal
  
  T : finType
  f : T -> T
  injf : injective f
  symf := fconnect_sym : forall x y : T, (fconnect f) x y = (fconnect f) y x
  x : T
  ============================
  (fcycle f) (orbit x)
1 subgoal
  
  T : finType
  f : T -> T
  injf : injective f
  symf := fconnect_sym : forall x y : T, (fconnect f) x y = (fconnect f) y x
  x : T
  p : seq T
  ============================
  (fpath finv) x p = (fpath f) (last x p) (rev (belast x p))
1 subgoal
  
  T : finType
  f : T -> T
  injf : injective f
  symf := fconnect_sym : forall x y : T, (fconnect f) x y = (fconnect f) y x
  ============================
  fconnect finv =2 fconnect f
1 subgoal
  
  T : finType
  f : T -> T
  injf : injective f
  symf := fconnect_sym : forall x y : T, (fconnect f) x y = (fconnect f) y x
  ============================
  fcard_mem finv =1 fcard_mem f
1 subgoal
  
  T : finType
  f : T -> T
  injf : injective f
  symf := fconnect_sym : forall x y : T, (fconnect f) x y = (fconnect f) y x
  n : nat_eqType
  a : pred T
  ============================
  a \subset order_set n -> fclosed f a -> fcard f a * n = #|a|
1 subgoal
  
  T : finType
  f : T -> T
  injf : injective f
  symf := fconnect_sym : forall x y : T, (fconnect f) x y = (fconnect f) y x
  a : pred T
  ============================
  fclosed f a -> forall x : T, (x \in a) = (f x \in a)
1 subgoal
  
  T : finType
  f : T -> T
  injf : injective f
  symf := fconnect_sym : forall x y : T, (fconnect f) x y = (fconnect f) y x
  x : T
  ============================
  (fconnect f) x =1 (fconnect f) (f x)
1 subgoal
  
  T : finType
  f : T -> T
  injf : injective f
  symf := fconnect_sym : forall x y : T, (fconnect f) x y = (fconnect f) y x
  x, y : T
  ============================
  (fconnect f) x y = (fconnect f) x (f y)
1 subgoal
  
  T : finType
  x : T
  ============================
  (fconnect id) x =1 xpred1 x
1 subgoal
  
  T : finType
  x : T
  ============================
  order id x = 1
1 subgoal
  
  T : finType
  x : T
  ============================
  orbit id x = [:: x]
1 subgoal
  
  T : finType
  x : T
  ============================
  (froots id) x
1 subgoal
  
  T : finType
  x : T
  ============================
  (froot id) x = x
1 subgoal
  
  T : finType
  a : pred T
  ============================
  fcard id a = #|a|
1 subgoal
  
  T : finType
  f, f' : T -> T
  ============================
  cancel f f' -> finv f =1 f'
1 subgoal
  
  T : finType
  f, f' : T -> T
  eq_f : f =1 f'
  eq_rf := eq_frel eq_f : frel f =2 frel f'
  ============================
  fconnect f =2 fconnect f'
1 subgoal
  
  T : finType
  f, f' : T -> T
  eq_f : f =1 f'
  eq_rf := eq_frel eq_f : frel f =2 frel f'
  ============================
  fcard_mem f =1 fcard_mem f'
1 subgoal
  
  T : finType
  f, f' : T -> T
  eq_f : f =1 f'
  eq_rf := eq_frel eq_f : frel f =2 frel f'
  ============================
  finv f =1 finv f'
1 subgoal
  
  T : finType
  f, f' : T -> T
  eq_f : f =1 f'
  eq_rf := eq_frel eq_f : frel f =2 frel f'
  ============================
  froot f =1 froot f'
1 subgoal
  
  T : finType
  f, f' : T -> T
  eq_f : f =1 f'
  eq_rf := eq_frel eq_f : frel f =2 frel f'
  ============================
  froots f =1 froots f'
1 subgoal
  
  T : finType
  f : T -> T
  injf : injective f
  ============================
  finv (finv f) =1 f
1 subgoal
  
  T : finType
  f : T -> T
  injf : injective f
  ============================
  order (finv f) =1 order f
1 subgoal
  
  T : finType
  f : T -> T
  injf : injective f
  n : nat_eqType
  ============================
  order_set (finv f) n =i order_set f n
1 subgoal
  
  T, T' : finType
  h : T' -> T
  e : rel T
  e' : rel T'
  sym_e : connect_sym e
  sym_e' : connect_sym e'
  a : pred T
  cl_a : closed e a
  h' : forall x : T, x \in a -> T'
  ============================
  (forall (x : T) (a_x : x \in a),
   connect e x (h (h' x a_x)) /\
   (forall (y : T) (a_y : y \in a), e x y -> connect e' (h' x a_x) (h' y a_y))) ->
  (forall (x' : T') (a_x : h x' \in a),
   connect e' x' (h' (h x') a_x) /\
   (forall y' : T', e' x' y' -> connect e (h x') (h y'))) -> rel_adjunction
1 subgoal
  
  T, T' : finType
  h : T' -> T
  e : rel T
  e' : rel T'
  sym_e : connect_sym e
  sym_e' : connect_sym e'
  a : pred T
  cl_a : closed e a
  ============================
  injective h ->
  a \subset codom h -> rel_base h e e' [predC a] -> rel_adjunction
1 subgoal
  
  T, T' : finType
  h : T' -> T
  e : rel T
  e' : rel T'
  sym_e : connect_sym e
  sym_e' : connect_sym e'
  a : pred T
  cl_a : closed e a
  ccl_a := closed_connect cl_a
   : forall x y : T, connect e x y -> (x \in a) = (y \in a)
  ============================
  rel_adjunction -> closed e' [preim h of a]
1 subgoal
  
  T, T' : finType
  h : T' -> T
  e : rel T
  e' : rel T'
  sym_e : connect_sym e
  sym_e' : connect_sym e'
  a : pred T
  cl_a : closed e a
  ccl_a := closed_connect cl_a
   : forall x y : T, connect e x y -> (x \in a) = (y \in a)
  ============================
  rel_adjunction -> n_comp e a = n_comp e' [preim h of a]
COQC tuple.v
1 subgoal
  
  n : nat
  T : Type
  t : tuple_of
  ============================
  size t = n
1 subgoal
  
  n : nat
  T : Type
  t : tuple_of
  ============================
  'I_n -> T
1 subgoal
  
  n : nat
  T : Type
  x : T
  t : tuple_of
  i : 'I_n
  ============================
  tnth t i = nth x t i
1 subgoal
  
  n : nat
  T : Type
  t : tuple_of
  ============================
  [seq tnth t i | i <- enum 'I_n] = t
1 subgoal
  
  n : nat
  T : Type
  t1, t2 : tuple_of
  ============================
  tnth t1 =1 tnth t2 -> t1 = t2
1 subgoal
  
  n : nat
  T : Type
  t : tuple_of
  ============================
  tuple [eta Tuple (tval:=t)] = t
1 subgoal
  
  T : Type
  m, n : nat
  eq_mn : m = n
  t : m.-tuple T
  i : 'I_n
  ============================
  tnth (tcast eq_mn t) i = tnth t (cast_ord (esym eq_mn) i)
1 subgoal
  
  T : Type
  n : nat
  eq_nn : n = n
  t : n.-tuple T
  ============================
  tcast eq_nn t = t
1 subgoal
  
  T : Type
  m, n : nat
  eq_mn : m = n
  ============================
  cancel (tcast eq_mn) (tcast (esym eq_mn))
1 subgoal
  
  T : Type
  m, n : nat
  eq_mn : m = n
  ============================
  cancel (tcast (esym eq_mn)) (tcast eq_mn)
1 subgoal
  
  T : Type
  m, n, p : nat
  eq_mn : m = n
  eq_np : n = p
  t : m.-tuple T
  ============================
  tcast (etrans eq_mn eq_np) t = tcast eq_np (tcast eq_mn t)
1 subgoal
  
  T : Type
  n : nat
  t : n.-tuple T
  ============================
  in_tuple t = tcast (esym (size_tuple t)) t
1 subgoal
  
  T : Type
  s : seq T
  ============================
  in_tuple s = s
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  t : n.-tuple T
  x : T
  ============================
  size (rcons t x) == n.+1
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  x : T
  ============================
  size (nseq n x) == n
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  ============================
  size (iota m n) == n
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  t : n.-tuple T
  ============================
  size (behead t) == n.-1
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  x : T
  t : n.-tuple T
  ============================
  size (belast x t) == n
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  t : n.-tuple T
  u : m.-tuple T
  ============================
  size (t ++ u) == n + m
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  t : n.-tuple T
  ============================
  size (take m t) == minn m n
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  t : n.-tuple T
  ============================
  size (drop m t) == n - m
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  t : n.-tuple T
  ============================
  size (rev t) == n
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  t : n.-tuple T
  ============================
  size (rot m t) == n
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  t : n.-tuple T
  ============================
  size (rotr m t) == n
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  f : T -> rT
  t : n.-tuple T
  ============================
  size [seq f i | i <- t] == n
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  f : rT -> T -> rT
  x : rT
  t : n.-tuple T
  ============================
  size (scanl f x t) == n
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  f : T -> T -> rT
  x : T
  t : n.-tuple T
  ============================
  size (pairmap f x t) == n
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  t : n.-tuple T
  u : n.-tuple U
  ============================
  size (zip t u) == n
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  f : T -> U -> rT
  t : n.-tuple T
  u : m.-tuple U
  ============================
  size [seq f i j | i <- t, j <- u] == n * m
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  x : T
  t : n.-tuple T
  ============================
  tnth [tuple of x :: t] ord0 = x
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  x : T
  t : n.-tuple T
  ============================
  thead [tuple of x :: t] = x
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  ============================
  all_equal_to ([tuple] : 0.-tuple T)
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  u : (n.+1).-tuple T
  ============================
  tuple1_spec u
1 subgoal
  
  n, m : nat
  T, U, rT : Type
  f : T -> rT
  t : n.-tuple T
  i : 'I_n
  ============================
  tnth [tuple of [seq f i | i <- t]] i = f (tnth t i)
1 subgoal
  
  n : nat
  T : Type
  t : (n.+1).-tuple T
  i : 'I_n.+1.-1
  ============================
  tnth [tuple of behead t] i = tnth t (inord i.+1)
1 subgoal
  
  n : nat
  T : Type
  t : (n.+1).-tuple T
  ============================
  t = [tuple of thead t :: behead t]
1 subgoal
  
  n : nat
  T : Type
  a : pred T
  t : n.-tuple T
  ============================
  [forall i, a (tnth t i)] = all a t
1 subgoal
  
  n : nat
  T : Type
  a : pred T
  t : n.-tuple T
  ============================
  [exists i, a (tnth t i)] = has a t
1 subgoal
  
  n : nat
  T : Type
  a : pred T
  t : n.-tuple T
  ============================
  reflect (forall i : 'I_n, a (tnth t i)) (all a t)
1 subgoal
  
  n : nat
  T : Type
  a : pred T
  t : n.-tuple T
  ============================
  reflect (exists i : 'I_n, a (tnth t i)) (has a t)
1 subgoal
  
  n : nat
  T : eqType
  t : n.-tuple T
  ============================
  mem t = mem t
1 subgoal
  
  n : nat
  T : eqType
  i : 'I_n
  t : n.-tuple T
  ============================
  tnth t i \in t
1 subgoal
  
  n : nat
  T : eqType
  x0 : T
  t : n.-tuple T
  i : nat
  ============================
  i < n -> nth x0 t i \in t
1 subgoal
  
  n : nat
  T : eqType
  t : n.-tuple T
  x : T
  ============================
  reflect (exists i : 'I_n, x = tnth t i) (x \in t)
1 subgoal
  
  n : nat
  T : eqType
  s : seq T
  x : T
  ============================
  x \in s -> {i : 'I_(size s) | x = tnth (in_tuple s) i}
1 subgoal
  
  n : nat
  T : finType
  ============================
  Finite.axiom enum
1 subgoal
  
  n : nat
  T : finType
  ============================
  size enum = #|T| ^ n
1 subgoal
  
  n : nat
  T : finType
  ============================
  #|{: n.-tuple T}| = #|T| ^ n
1 subgoal
  
  n : nat
  T : finType
  A : pred T
  ============================
  size (enum A) == #|A|
1 subgoal
  
  n : nat
  T : finType
  ============================
  val ord_tuple = enum 'I_n
1 subgoal
  
  n : nat
  T : finType
  U : Type
  t : n.-tuple U
  ============================
  t = [tuple of [seq tnth t i | i <- ord_tuple]]
1 subgoal
  
  n : nat
  T : finType
  i : 'I_n
  ============================
  tnth ord_tuple i = i
1 subgoal
  
  n : nat
  T : finType
  T' : Type
  f : 'I_n -> T'
  i : 'I_n
  ============================
  tnth mktuple i = f i
1 subgoal
  
  n : nat
  T : finType
  T' : Type
  f : 'I_n -> T'
  x0 : T'
  i : 'I_n
  ============================
  nth x0 mktuple i = f i
COQC finfun.v
1 subgoal
  
  ============================
  fun_of_fin = fun_of_fin_def
1 subgoal
  
  ============================
  finfun = finfun_def
1 subgoal
  
  aT : finType
  rT : Type
  f : {ffun aT -> rT}
  i : 'I_#|aT|
  ============================
  tnth (fgraph f) i = fun_of_fin f (enum_val i)
1 subgoal
  
  aT : finType
  rT : Type
  g : aT -> rT
  ============================
  [ffun x => g x] =1 g
1 subgoal
  
  aT : finType
  rT : Type
  f : {ffun aT -> rT}
  ============================
  fgraph f = codom_tuple (fun_of_fin f)
1 subgoal
  
  aT : finType
  rT : Type
  f : {ffun aT -> rT}
  ============================
  codom (fun_of_fin f) = val f
1 subgoal
  
  aT : finType
  rT : Type
  f1, f2 : {ffun aT -> rT}
  ============================
  fun_of_fin f1 =1 fun_of_fin f2 <-> f1 = f2
1 subgoal
  
  aT : finType
  rT : Type
  ============================
  cancel (fun_of_fin (rT:=rT)) (finfun (rT:=rT))
1 subgoal
  
  aT : finType
  rT : Type
  pT : predType rT
  F : aT -> pT
  f : {ffun aT -> rT}
  ============================
  reflect (forall x : aT, fun_of_fin f x \in F x) (f \in family_mem (fmem F))
1 subgoal
  
  aT : finType
  rT : Type
  R : pred rT
  f : {ffun aT -> rT}
  ============================
  reflect (forall x : aT, fun_of_fin f x \in R) (f \in ffun_on_mem (mem R))
1 subgoal
  
  T : Type
  n : nat
  x0 : T
  i : 'I_n
  f : finfun_type (ordinal_finType n) T
  ============================
  nth x0 (fgraph f) i = fun_of_fin f i
1 subgoal
  
  aT : Type
  rT : eqType
  x : aT
  y : rT
  f : aT -> rT
  ============================
  (x \in support_for y f) = (f x != y)
1 subgoal
  
  aT : finType
  rT : eqType
  y : rT
  D : pred aT
  g : aT -> rT
  ============================
  reflect (forall x : aT, x \notin D -> g x = y) (y.-support g \subset D)
1 subgoal
  
  aT : finType
  rT : eqType
  pT : predType rT
  y : rT
  D : pred aT
  F : aT -> pT
  f : {ffun aT -> rT}
  ============================
  reflect
    (y.-support (fun_of_fin f) \subset D /\
     {in D, forall x : aT, fun_of_fin f x \in F x})
    (f \in pfamily_mem y (mem D) (fmem F))
1 subgoal
  
  aT : finType
  rT : eqType
  y : rT
  D : pred aT
  R : pred rT
  f : {ffun aT -> rT}
  ============================
  reflect
    (y.-support (fun_of_fin f) \subset D /\
     {subset image (fun_of_fin f) D <= R})
    (f \in pffun_on_mem y (mem D) (mem R))
1 subgoal
  
  aT, rT : finType
  y0 : rT
  D : pred aT
  F : aT -> pred rT
  ============================
  #|pfamily y0 D F| = foldr muln 1 [seq #|F x| | x in D]
1 subgoal
  
  aT, rT : finType
  F : aT -> pred rT
  ============================
  #|family F| = foldr muln 1 [seq #|F x| | x in aT]
1 subgoal
  
  aT, rT : finType
  y0 : rT
  D : pred aT
  R : pred rT
  ============================
  #|pffun_on y0 D R| = #|R| ^ #|D|
1 subgoal
  
  aT, rT : finType
  R : pred rT
  ============================
  #|ffun_on R| = #|R| ^ #|aT|
1 subgoal
  
  aT, rT : finType
  ============================
  #|{ffun aT -> rT}| = #|rT| ^ #|aT|
COQC bigop.v
1 subgoal
  
  T : Type
  zero, one : T
  mul, add : T -> T -> T
  inv : T -> T
  mulC : commutative mul
  ============================
  left_id one mul -> right_id one mul
1 subgoal
  
  T : Type
  zero, one : T
  mul, add : T -> T -> T
  inv : T -> T
  mulC : commutative mul
  ============================
  left_zero zero mul -> right_zero zero mul
1 subgoal
  
  T : Type
  zero, one : T
  mul, add : T -> T -> T
  inv : T -> T
  mulC : commutative mul
  ============================
  left_distributive mul add -> right_distributive mul add
1 subgoal
  
  T : Type
  idm : T
  mul : law idm
  ============================
  left_id idm mul
1 subgoal
  
  T : Type
  idm : T
  mul : law idm
  ============================
  right_id idm mul
1 subgoal
  
  T : Type
  idm : T
  mul : law idm
  ============================
  associative mul
1 subgoal
  
  T : Type
  idm : T
  mul : law idm
  n : nat
  x : T
  ============================
  iterop n mul x idm = iter n (mul x) idm
1 subgoal
  
  T : Type
  idm : T
  mul : com_law idm
  ============================
  commutative mul
1 subgoal
  
  T : Type
  idm : T
  mul : com_law idm
  ============================
  left_commutative mul
1 subgoal
  
  T : Type
  idm : T
  mul : com_law idm
  ============================
  right_commutative mul
1 subgoal
  
  T : Type
  idm : T
  mul : com_law idm
  ============================
  interchange mul mul
1 subgoal
  
  T : Type
  idm : T
  mul : mul_law idm
  ============================
  left_zero idm mul
1 subgoal
  
  T : Type
  idm : T
  mul : mul_law idm
  ============================
  right_zero idm mul
1 subgoal
  
  T : Type
  idm : T
  mul : T -> T -> T
  add : add_law idm mul
  ============================
  associative add
1 subgoal
  
  T : Type
  idm : T
  mul : T -> T -> T
  add : add_law idm mul
  ============================
  commutative add
1 subgoal
  
  T : Type
  idm : T
  mul : T -> T -> T
  add : add_law idm mul
  ============================
  left_commutative add
1 subgoal
  
  T : Type
  idm : T
  mul : T -> T -> T
  add : add_law idm mul
  ============================
  right_commutative add
1 subgoal
  
  T : Type
  idm : T
  mul : T -> T -> T
  add : add_law idm mul
  ============================
  left_id idm add
1 subgoal
  
  T : Type
  idm : T
  mul : T -> T -> T
  add : add_law idm mul
  ============================
  right_id idm add
1 subgoal
  
  T : Type
  idm : T
  mul : T -> T -> T
  add : add_law idm mul
  ============================
  left_distributive mul add
1 subgoal
  
  T : Type
  idm : T
  mul : T -> T -> T
  add : add_law idm mul
  ============================
  right_distributive mul add
1 subgoal
  
  ============================
  bigop = reducebig
1 subgoal
  
  m, n : nat
  i : nat_eqType
  ============================
  (i \in index_iota m n) = (m <= i) && (i < n)
1 subgoal
  
  T : finType
  i : T
  ============================
  i \in index_enum T
1 subgoal
  
  T : finType
  P : pred T
  ============================
  [seq x <- index_enum T | P x] = enum P
1 subgoal
  
  R : Type
  K : R -> Type
  K' : R -> Type
  idx : R
  op : R -> R -> R
  I : Type
  r : seq I
  P : pred I
  F : I -> R
  ============================
  K (\big[op/idx]_(i <- r | P i) F i) * K' (\big[op/idx]_(i <- r | P i) F i) ->
  K' (\big[op/idx]_(i <- r | P i) F i)
1 subgoal
  
  R1, R2, R3 : Type
  K : R1 -> R2 -> R3 -> Type
  id1 : R1
  op1 : R1 -> R1 -> R1
  id2 : R2
  op2 : R2 -> R2 -> R2
  id3 : R3
  op3 : R3 -> R3 -> R3
  Kid : K id1 id2 id3
  I : Type
  r : seq I
  P : pred I
  F1 : I -> R1
  F2 : I -> R2
  F3 : I -> R3
  K_F : forall (i : I) (y1 : R1) (y2 : R2) (y3 : R3),
        P i ->
        K y1 y2 y3 -> K (op1 (F1 i) y1) (op2 (F2 i) y2) (op3 (F3 i) y3)
  ============================
  K (\big[op1/id1]_(i <- r | P i) F1 i) (\big[op2/id2]_(i <- r | P i) F2 i)
    (\big[op3/id3]_(i <- r | P i) F3 i)
1 subgoal
  
  R1, R2, R3 : Type
  K : R1 -> R2 -> R3 -> Type
  id1 : R1
  op1 : R1 -> R1 -> R1
  id2 : R2
  op2 : R2 -> R2 -> R2
  id3 : R3
  op3 : R3 -> R3 -> R3
  Kid : K id1 id2 id3
  Kop : forall (x1 : R1) (x2 : R2) (x3 : R3) (y1 : R1) (y2 : R2) (y3 : R3),
        K x1 x2 x3 -> K y1 y2 y3 -> K (op1 x1 y1) (op2 x2 y2) (op3 x3 y3)
  I : Type
  r : seq I
  P : pred I
  F1 : I -> R1
  F2 : I -> R2
  F3 : I -> R3
  K_F : forall i : I, P i -> K (F1 i) (F2 i) (F3 i)
  ============================
  K (\big[op1/id1]_(i <- r | P i) F1 i) (\big[op2/id2]_(i <- r | P i) F2 i)
    (\big[op3/id3]_(i <- r | P i) F3 i)
1 subgoal
  
  R1, R2 : Type
  K : R1 -> R2 -> Type
  f : R2 -> R1
  id1 : R1
  op1 : R1 -> R1 -> R1
  id2 : R2
  op2 : R2 -> R2 -> R2
  Kid : K id1 id2
  I : Type
  r : seq I
  P : pred I
  F1 : I -> R1
  F2 : I -> R2
  K_F : forall (i : I) (y1 : R1) (y2 : R2),
        P i -> K y1 y2 -> K (op1 (F1 i) y1) (op2 (F2 i) y2)
  ============================
  K (\big[op1/id1]_(i <- r | P i) F1 i) (\big[op2/id2]_(i <- r | P i) F2 i)
1 subgoal
  
  R1, R2 : Type
  K : R1 -> R2 -> Type
  f : R2 -> R1
  id1 : R1
  op1 : R1 -> R1 -> R1
  id2 : R2
  op2 : R2 -> R2 -> R2
  Kid : K id1 id2
  Kop : forall (x1 : R1) (x2 : R2) (y1 : R1) (y2 : R2),
        K x1 x2 -> K y1 y2 -> K (op1 x1 y1) (op2 x2 y2)
  I : Type
  r : seq I
  P : pred I
  F1 : I -> R1
  F2 : I -> R2
  K_F : forall i : I, P i -> K (F1 i) (F2 i)
  ============================
  K (\big[op1/id1]_(i <- r | P i) F1 i) (\big[op2/id2]_(i <- r | P i) F2 i)
1 subgoal
  
  R1, R2 : Type
  K : R1 -> R2 -> Type
  f : R2 -> R1
  id1 : R1
  op1 : R1 -> R1 -> R1
  id2 : R2
  op2 : R2 -> R2 -> R2
  Kid : K id1 id2
  Kop : forall (x1 : R1) (x2 : R2) (y1 : R1) (y2 : R2),
        K x1 x2 -> K y1 y2 -> K (op1 x1 y1) (op2 x2 y2)
  f_op : {morph f : x y / op2 x y >-> op1 x y}
  f_id : f id2 = id1
  I : Type
  r : seq I
  P : pred I
  F : I -> R2
  ============================
  f (\big[op2/id2]_(i <- r | P i) F i) = \big[op1/id1]_(i <- r | P i) f (F i)
1 subgoal
  
  R : Type
  K : R -> Type
  f : R -> R
  idx : R
  op, op' : R -> R -> R
  Kid : K idx
  I : Type
  r : seq I
  P : pred I
  F : I -> R
  Kop : forall (i : I) (x : R), P i -> K x -> K (op (F i) x)
  ============================
  K (\big[op/idx]_(i <- r | P i) F i)
1 subgoal
  
  R : Type
  K : R -> Type
  f : R -> R
  idx : R
  op, op' : R -> R -> R
  Kid : K idx
  Kop : forall x y : R, K x -> K y -> K (op x y)
  I : Type
  r : seq I
  P : pred I
  F : I -> R
  K_F : forall i : I, P i -> K (F i)
  ============================
  K (\big[op/idx]_(i <- r | P i) F i)
1 subgoal
  
  R : Type
  K : R -> Type
  f : R -> R
  idx : R
  op, op' : R -> R -> R
  Kid : K idx
  Kop : forall x y : R, K x -> K y -> K (op x y)
  Kop' : forall x y : R, K x -> K y -> op x y = op' x y
  I : Type
  r : seq I
  P : pred I
  F : I -> R
  K_F : forall i : I, P i -> K (F i)
  ============================
  \big[op/idx]_(i <- r | P i) F i = \big[op'/idx]_(i <- r | P i) F i
1 subgoal
  
  R : Type
  K : R -> Type
  f : R -> R
  idx : R
  op, op' : R -> R -> R
  Kid : K idx
  Kop : forall x y : R, K x -> K y -> K (op x y)
  Kop' : forall x y : R, K x -> K y -> op x y = op' x y
  fM : {morph f : x y / op x y}
  f_id : f idx = idx
  I : Type
  r : seq I
  P : pred I
  F : I -> R
  ============================
  f (\big[op/idx]_(i <- r | P i) F i) = \big[op/idx]_(i <- r | P i) f (F i)
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  r : seq I
  P : pred I
  F : I -> R
  ============================
  \big[op/idx]_(i <- [seq x <- r | P x]) F i =
  \big[op/idx]_(i <- r | P i) F i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  r : seq I
  P1, P2 : pred I
  F : I -> R
  ============================
  \big[op/idx]_(i <- [seq x <- r | P1 x] | P2 i) F i =
  \big[op/idx]_(i <- r | P1 i && P2 i) F i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  r : seq I
  P1, P2 : pred I
  F : I -> R
  ============================
  P1 =1 P2 ->
  \big[op/idx]_(i <- r | P1 i) F i = \big[op/idx]_(i <- r | P2 i) F i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  r : seq I
  P, Q : pred I
  F : I -> R
  ============================
  \big[op/idx]_(i <- r | P i && Q i) F i =
  \big[op/idx]_(i <- r | Q i && P i) F i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  r : seq I
  P : pred I
  F1, F2 : I -> R
  ============================
  (forall i : I, P i -> F1 i = F2 i) ->
  \big[op/idx]_(i <- r | P i) F1 i = \big[op/idx]_(i <- r | P i) F2 i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  r : seq I
  P1, P2 : pred I
  F1, F2 : I -> R
  ============================
  P1 =1 P2 ->
  (forall i : I, P1 i -> F1 i = F2 i) ->
  \big[op/idx]_(i <- r | P1 i) F1 i = \big[op/idx]_(i <- r | P2 i) F2 i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  r1, r2 : seq I
  P1, P2 : pred I
  F1, F2 : I -> R
  ============================
  r1 = r2 ->
  P1 =1 P2 ->
  (forall i : I, P1 i -> F1 i = F2 i) ->
  \big[op/idx]_(i <- r1 | P1 i) F1 i = \big[op/idx]_(i <- r2 | P2 i) F2 i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  P : pred I
  F : I -> R
  ============================
  \big[op/idx]_(i <- [::] | P i) F i = idx
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  i : I
  r : seq I
  P : pred I
  F : I -> R
  ============================
  let x := \big[op/idx]_(j <- r | P j) F j in
  \big[op/idx]_(j <- (i :: r) | P j) F j = (if P i then op (F i) x else x)
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  J : Type
  h : J -> I
  r : seq J
  P : pred I
  F : I -> R
  ============================
  \big[op/idx]_(i <- [seq h i | i <- r] | P i) F i =
  \big[op/idx]_(j <- r | P (h j)) F (h j)
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  x0 : I
  r : seq I
  P : pred I
  F : I -> R
  ============================
  \big[op/idx]_(i <- r | P i) F i =
  \big[op/idx]_(0 <= i < size r | P (nth x0 r i)) F (nth x0 r i)
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  r : seq I
  P : pred I
  F : I -> R
  ============================
  ~~ has P r -> \big[op/idx]_(i <- r | P i) F i = idx
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  r : seq I
  F : I -> R
  ============================
  \big[op/idx]_(i <- r | false) F i = idx
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  r : seq I
  P : pred I
  F : I -> R
  ============================
  P =1 xpred0 -> \big[op/idx]_(i <- r | P i) F i = idx
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  r1, r2 : seq I
  P : pred I
  F : I -> R
  ============================
  let x := \big[op/idx]_(i <- r2 | P i) F i in
  \big[op/idx]_(i <- (r1 ++ r2) | P i) F i = \big[op/x]_(i <- r1 | P i) F i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  r1, r2 : seq I
  P : pred I
  F : I -> R
  ============================
  ~~ has P r2 ->
  \big[op/idx]_(i <- (r1 ++ r2) | P i) F i = \big[op/idx]_(i <- r1 | P i) F i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  r1, r2 : seq I
  P : pred I
  F : I -> R
  ============================
  ~~ has P r1 ->
  \big[op/idx]_(i <- (r1 ++ r2) | P i) F i = \big[op/idx]_(i <- r2 | P i) F i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  r : seq I
  P : pred I
  x : R
  ============================
  \big[op/idx]_(i <- r | P i) x = iter (count P r) (op x) idx
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : eqType
  r : seq I
  P : pred I
  F : I -> R
  ============================
  \big[op/idx]_(i <- r | P i) F i =
  \big[op/idx]_(i <- r | (i \in r) && P i) F i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : eqType
  r : seq I
  F : I -> R
  ============================
  \big[op/idx]_(i <- r) F i = \big[op/idx]_(i <- r | i \in r) F i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : eqType
  r : seq I
  F1, F2 : I -> R
  ============================
  {in r, F1 =1 F2} -> \big[op/idx]_(i <- r) F1 i = \big[op/idx]_(i <- r) F2 i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  m, n : nat
  P : pred nat
  F : nat -> R
  ============================
  \big[op/idx]_(m <= i < n | P i) F i =
  \big[op/idx]_(m <= i < n | (m <= i) && (i < n) && P i) F i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  m, n : nat
  F : nat -> R
  ============================
  \big[op/idx]_(m <= i < n) F i =
  \big[op/idx]_(m <= i < n | (m <= i) && (i < n)) F i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  m1, n1, m2, n2 : nat
  P1, P2 : nat -> bool
  F1, F2 : nat -> R
  ============================
  m1 = m2 ->
  n1 = n2 ->
  (forall i : nat, (m1 <= i) && (i < n2) -> P1 i = P2 i) ->
  (forall i : nat, [&& P1 i, m1 <= i & i < n2] -> F1 i = F2 i) ->
  \big[op/idx]_(m1 <= i < n1 | P1 i) F1 i =
  \big[op/idx]_(m2 <= i < n2 | P2 i) F2 i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  m, n : nat
  F1, F2 : nat -> R
  ============================
  (forall i : nat, (m <= i) && (i < n) -> F1 i = F2 i) ->
  \big[op/idx]_(m <= i < n) F1 i = \big[op/idx]_(m <= i < n) F2 i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  m, n : nat
  P : pred nat
  F : nat -> R
  ============================
  n <= m -> \big[op/idx]_(m <= i < n | P i) F i = idx
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  m, n : nat
  P : pred nat
  F : nat -> R
  ============================
  m < n ->
  let x := \big[op/idx]_(m.+1 <= i < n | P i) F i in
  \big[op/idx]_(m <= i < n | P i) F i = (if P m then op (F m) x else x)
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  m, n : nat
  F : nat -> R
  ============================
  m < n ->
  \big[op/idx]_(m <= i < n) F i = op (F m) (\big[op/idx]_(m.+1 <= i < n) F i)
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  m, n, a : nat
  P : pred nat
  F : nat -> R
  ============================
  \big[op/idx]_(m + a <= i < n | P i) F i =
  \big[op/idx]_(m <= i < n - a | P (i + a)) F (i + a)
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  m, n : nat
  P : pred nat
  F : nat -> R
  ============================
  \big[op/idx]_(m.+1 <= i < n | P i) F i =
  \big[op/idx]_(m <= i < n.-1 | P i.+1) F i.+1
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  n, m : nat
  F : nat -> R
  ============================
  m <= n ->
  \big[op/idx]_(m <= i < n.+1) F i =
  op (F m) (\big[op/idx]_(m <= i < n) F i.+1)
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  n : nat
  P : pred nat
  F : nat -> R
  ============================
  \big[op/idx]_(0 <= i < n | P i) F i = \big[op/idx]_(i < n | P i) F i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  m, n1, n2 : nat
  P : pred nat
  F : nat -> R
  ============================
  n1 <= n2 ->
  \big[op/idx]_(m <= i < n1 | P i) F i =
  \big[op/idx]_(m <= i < n2 | P i && (i < n1)) F i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  n1, n2 : nat
  P : pred nat
  F : nat -> R
  ============================
  n1 <= n2 ->
  \big[op/idx]_(i < n1 | P i) F i =
  \big[op/idx]_(i < n2 | P i && (i < n1)) F i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  n1, n2 : nat
  F : nat -> R
  ============================
  n1 <= n2 -> \big[op/idx]_(i < n1) F i = \big[op/idx]_(i < n2 | i < n1) F i
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  n1, n2 : nat
  P : pred 'I_n1.+1
  F : 'I_n1.+1 -> R
  ============================
  n1 < n2 ->
  \big[op/idx]_(i < n1.+1 | P i) F i =
  \big[op/idx]_(i < n2 | P (inord i) && (i <= n1)) F (inord i)
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  P : 'I_0 -> bool
  F : 'I_0 -> R
  ============================
  \big[op/idx]_(i < 0 | P i) F i = idx
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  r : seq I
  P : pred I
  F : I -> R
  ============================
  let r_ := tnth (in_tuple r) in
  \big[op/idx]_(i <- r | P i) F i =
  \big[op/idx]_(i < size r | P (r_ i)) F (r_ i)
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : eqType
  r : seq I
  E : 'I_(size r) -> R
  ============================
  uniq r ->
  \big[op/idx]_i E i = \big[op/idx]_(x <- r) oapp E idx (insub (index x r))
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  n : nat
  t : n.-tuple I
  P : pred I
  F : I -> R
  ============================
  \big[op/idx]_(i <- t | P i) F i =
  \big[op/idx]_(i < n | P (tnth t i)) F (tnth t i)
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  n1, n2 : nat
  P : pred 'I_n2
  F : 'I_n2 -> R
  le_n12 : n1 <= n2
  ============================
  let w := widen_ord le_n12 in
  \big[op/idx]_(i < n2 | P i && (i < n1)) F i =
  \big[op/idx]_(i < n1 | P (w i)) F (w i)
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  n1, n2 : nat
  P : pred 'I_n2.+1
  F : 'I_n2.+1 -> R
  le_n12 : n1 <= n2
  ============================
  let w := widen_ord le_n12 in
  \big[op/idx]_(i < n2.+1 | P i && (i <= n1)) F i =
  \big[op/idx]_(i < n1.+1 | P (w i)) F (w i)
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  n1, n2 : nat
  F : 'I_n2 -> R
  le_n12 : n1 <= n2
  ============================
  let w := widen_ord le_n12 in
  \big[op/idx]_(i < n2 | i < n1) F i = \big[op/idx]_(i < n1) F (w i)
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  n1, n2 : nat
  F : 'I_n2.+1 -> R
  le_n12 : n1 <= n2
  ============================
  let w := widen_ord le_n12 in
  \big[op/idx]_(i < n2.+1 | i <= n1) F i = \big[op/idx]_(i < n1.+1) F (w i)
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  n : nat
  F : 'I_n.+1 -> R
  ============================
  \big[op/idx]_(i < n.+1) F i =
  op (F ord0) (\big[op/idx]_(i < n) F (lift ord0 i))
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : finType
  A : pred I
  x : R
  ============================
  \big[op/idx]_(i in A) x = iter #|A| (op x) idx
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  m, n : nat
  x : R
  ============================
  \big[op/idx]_(m <= i < n) x = iter (n - m) (op x) idx
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  n : nat
  x : R
  ============================
  \big[op/idx]_(i < n) x = iter n (op x) idx
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  n : nat
  a : I
  P : pred I
  F : I -> R
  ============================
  \big[op/idx]_(i <- nseq n a | P i) F i =
  (if P a then iter n (op (F a)) idx else idx)
1 subgoal
  
  R : Type
  idx : R
  op : R -> R -> R
  I : Type
  n : nat
  a : I
  F : I -> R
  ============================
  \big[op/idx]_(i <- nseq n a) F i = iter n (op (F a)) idx
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law 1
  idx' : R
  I : Type
  r : seq I
  P : pred I
  F : I -> R
  ============================
  right_id idx' *%M ->
  has P r ->
  \big[*%M/idx']_(i <- r | P i) F i = \big[*%M/1]_(i <- r | P i) F i
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law 1
  idx' : R
  I : finType
  i0 : I
  P : pred I
  F : I -> R
  ============================
  P i0 ->
  right_id idx' *%M ->
  \big[*%M/idx']_(i | P i) F i = \big[*%M/1]_(i | P i) F i
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law 1
  I : Type
  r : seq I
  P : pred I
  ============================
  \big[*%M/1]_(i <- r | P i) 1 = 1
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law 1
  I : Type
  r : seq I
  P : pred I
  F : I -> R
  ============================
  (forall i : I, P i -> F i = 1) -> \big[*%M/1]_(i <- r | P i) F i = 1
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law 1
  I : eqType
  r : seq_predType I
  P : pred I
  F : I -> R
  ============================
  (forall i : I, P i && (i \in r) -> F i = 1) ->
  \big[*%M/1]_(i <- r | P i) F i = 1
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law 1
  I : Type
  i : I
  F : I -> R
  ============================
  \big[*%M/1]_(j <- [:: i]) F j = F i
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law 1
  I : Type
  r : seq I
  P : pred I
  F : I -> R
  ============================
  \big[*%M/1]_(i <- r | P i) F i =
  \big[*%M/1]_(i <- r) (if P i then F i else 1)
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law 1
  I : Type
  r : seq I
  P, Q : pred I
  F : I -> R
  ============================
  \big[*%M/1]_(i <- r | P i && Q i) F i =
  \big[*%M/1]_(i <- r | P i) (if Q i then F i else 1)
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law 1
  I : Type
  r : seq I
  P, Q : pred I
  F : I -> R
  ============================
  \big[*%M/1]_(i <- r | P i && Q i) F i =
  \big[*%M/1]_(i <- r | Q i) (if P i then F i else 1)
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law 1
  I : Type
  r1, r2 : seq I
  P : pred I
  F : I -> R
  ============================
  \big[*%M/1]_(i <- (r1 ++ r2) | P i) F i =
  \big[*%M/1]_(i <- r1 | P i) F i * \big[*%M/1]_(i <- r2 | P i) F i
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law 1
  I1 : Type
  I2 : Type
  r1 : seq I1
  r2 : seq I2
  F : I1 * I2 -> R
  ============================
  \big[*%M/1]_(i <- [seq (i1, i2) | i1 <- r1, i2 <- r2]) F i =
  \big[*%M/1]_(i1 <- r1) \big[*%M/1]_(i2 <- r2) F (i1, i2)
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law 1
  I : finType
  i : I
  F : I -> R
  ============================
  \big[*%M/1]_(j | j == i) F j = F i
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law 1
  I : finType
  i : I
  P : pred I
  F : I -> R
  ============================
  P =1 pred1 i -> \big[*%M/1]_(j | P j) F j = F i
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law 1
  n, m, p : nat
  P : pred nat
  F : nat -> R
  ============================
  m <= n ->
  n <= p ->
  \big[*%M/1]_(m <= i < p | P i) F i =
  \big[*%M/1]_(m <= i < n | P i) F i * \big[*%M/1]_(n <= i < p | P i) F i
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law 1
  n : nat
  F : nat -> R
  ============================
  \big[*%M/1]_(n <= i < n.+1) F i = F n
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law 1
  n, m : nat
  F : nat -> R
  ============================
  m <= n ->
  \big[*%M/1]_(m <= i < n.+1) F i = \big[*%M/1]_(m <= i < n) F i * F n
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law 1
  n : nat
  F : 'I_n.+1 -> R
  ============================
  \big[*%M/1]_(i < n.+1) F i =
  \big[*%M/1]_(i < n) F (widen_ord (leqnSn n) i) * F ord_max
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law 1
  I1, I2 : finType
  P : pred (I1 + I2)
  F : sum_finType I1 I2 -> R
  ============================
  \big[*%M/1]_(i | P i) F i =
  \big[*%M/1]_(i | P (inl i)) F (inl i) *
  \big[*%M/1]_(i | P (inr i)) F (inr i)
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law 1
  m, n : nat
  P : pred 'I_(m + n)
  F : ordinal_finType (m + n) -> R
  ============================
  \big[*%M/1]_(i | P i) F i =
  \big[*%M/1]_(i | P (lshift n i)) F (lshift n i) *
  \big[*%M/1]_(i | P (rshift m i)) F (rshift m i)
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law 1
  I : Type
  rr : seq (seq I)
  P : pred I
  F : I -> R
  ============================
  \big[*%M/1]_(i <- flatten rr | P i) F i =
  \big[*%M/1]_(r <- rr) \big[*%M/1]_(i <- r | P i) F i
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I : eqType
  r1, r2 : seq I
  P : pred I
  F : I -> R
  ============================
  perm_eq r1 r2 ->
  \big[*%M/1]_(i <- r1 | P i) F i = \big[*%M/1]_(i <- r2 | P i) F i
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I : finType
  r : seq I
  F : I -> R
  ============================
  uniq r -> \big[*%M/1]_(i <- r) F i = \big[*%M/1]_(i in r) F i
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I : eqType
  r : seq_predType I
  x : I
  P : pred I
  F : I -> R
  ============================
  x \in r ->
  \big[*%M/1]_(y <- r | P y) F y =
  (if P x then F x else 1) * \big[*%M/1]_(y <- rem x r | P y) F y
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I : eqType
  r : seq I
  P : pred I
  F : I -> R
  ============================
  idempotent *%M ->
  \big[*%M/1]_(i <- undup r | P i) F i = \big[*%M/1]_(i <- r | P i) F i
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I : eqType
  r1, r2 : seq I
  P : pred I
  F : I -> R
  ============================
  idempotent *%M ->
  r1 =i r2 ->
  \big[*%M/1]_(i <- r1 | P i) F i = \big[*%M/1]_(i <- r2 | P i) F i
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I : eqType
  r : seq I
  P : pred I
  F : I -> R
  ============================
  \big[*%M/1]_(i <- undup r | P i) iterop ((count_mem i) r) *%M (F i) 1 =
  \big[*%M/1]_(i <- r | P i) F i
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I : Type
  r : seq I
  P : pred I
  F1, F2 : I -> R
  ============================
  \big[*%M/1]_(i <- r | P i) (F1 i * F2 i) =
  \big[*%M/1]_(i <- r | P i) F1 i * \big[*%M/1]_(i <- r | P i) F2 i
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I : Type
  r : seq I
  a, P : pred I
  F : I -> R
  ============================
  \big[*%M/1]_(i <- r | P i) F i =
  \big[*%M/1]_(i <- r | P i && a i) F i *
  \big[*%M/1]_(i <- r | P i && ~~ a i) F i
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I : finType
  A, B : pred I
  F : I -> R
  ============================
  [disjoint A & B] ->
  \big[*%M/1]_(i in [predU A & B]) F i =
  \big[*%M/1]_(i in A) F i * \big[*%M/1]_(i in B) F i
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I : finType
  j : I
  P : pred I
  F : I -> R
  ============================
  P j ->
  \big[*%M/1]_(i | P i) F i = F j * \big[*%M/1]_(i | P i && (i != j)) F i
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I : eqType
  r : seq I
  j : I
  F : I -> R
  ============================
  j \in r ->
  uniq r ->
  \big[*%M/1]_(i <- r) F i = F j * \big[*%M/1]_(i <- r | i != j) F i
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I : finType
  A : pred I
  j : I
  ============================
  A j -> #|[pred x | A x]| = 1 + #|[pred i | A i & i != j]|
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I, J : finType
  P : pred I
  p : I -> J
  Q : pred J
  F : I -> R
  ============================
  (forall i : I, P i -> Q (p i)) ->
  \big[*%M/1]_(i | P i) F i =
  \big[*%M/1]_(j | Q j) \big[*%M/1]_(i | P i && (p i == j)) F i
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I, J : finType
  h : J -> I
  h' : I -> J
  P : pred I
  F : I -> R
  ============================
  (forall i : I, P i -> h (h' i) = i) ->
  \big[*%M/1]_(i | P i) F i =
  \big[*%M/1]_(j | P (h j) && (h' (h j) == j)) F (h j)
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I, J : finType
  h : J -> I
  P : pred I
  F : I -> R
  ============================
  {on [pred i | P i], bijective h} ->
  \big[*%M/1]_(i | P i) F i = \big[*%M/1]_(j | P (h j)) F (h j)
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I : finType
  h : I -> I
  P : pred I
  F : I -> R
  ============================
  injective h ->
  \big[*%M/1]_(i | P i) F i = \big[*%M/1]_(j | P (h j)) F (h j)
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  m, n : nat
  P : nat -> bool
  F : nat -> R
  ============================
  \big[*%M/1]_(m <= i < n | P i) F i =
  \big[*%M/1]_(m <= i < n | P (m + n - i.+1)) F (m + n - i.+1)
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I, J : finType
  P : pred I
  Q : I -> pred J
  F : I -> J -> R
  ============================
  \big[*%M/1]_(i | P i) \big[*%M/1]_(j | Q i j) F i j =
  \big[*%M/1]_(p | P p.1 && Q p.1 p.2) F p.1 p.2
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I, J : finType
  P : pred I
  Q : pred J
  F : I -> J -> R
  ============================
  \big[*%M/1]_(i | P i) \big[*%M/1]_(j | Q j) F i j =
  \big[*%M/1]_(p | P p.1 && Q p.2) F p.1 p.2
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I, J : finType
  F : I -> J -> R
  ============================
  \big[*%M/1]_i \big[*%M/1]_j F i j = \big[*%M/1]_p F p.1 p.2
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I : Type
  J : Type
  rI : seq I
  rJ : seq J
  P : pred I
  Q : I -> pred J
  xQ : pred J
  F : I -> J -> R
  ============================
  (forall (i : I) (j : J), P i -> Q i j -> xQ j) ->
  \big[*%M/1]_(i <- rI | P i) \big[*%M/1]_(j <- rJ | Q i j) F i j =
  \big[*%M/1]_(j <- rJ | xQ j) \big[*%M/1]_(i <- rI | P i && Q i j) F i j
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  I : Type
  J : Type
  rI : seq I
  rJ : seq J
  P : pred I
  Q : pred J
  F : I -> J -> R
  ============================
  \big[*%M/1]_(i <- rI | P i) \big[*%M/1]_(j <- rJ | Q j) F i j =
  \big[*%M/1]_(j <- rJ | Q j) \big[*%M/1]_(i <- rI | P i) F i j
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  m1, n1, m2, n2 : nat
  P : pred nat
  Q : rel nat
  xQ : pred nat
  F : nat -> nat -> R
  ============================
  (forall i j : nat,
   (m1 <= i) && (i < n1) -> (m2 <= j) && (j < n2) -> P i -> Q i j -> xQ j) ->
  \big[*%M/1]_(m1 <= i < n1 | P i) \big[*%M/1]_(m2 <= j < n2 | Q i j) F i j =
  \big[*%M/1]_(m2 <= j < n2 | xQ j) \big[*%M/1]_(m1 <= i < n1 | 
                                    P i && Q i j) 
                                    F i j
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.com_law 1
  m1, n1, m2, n2 : nat
  P, Q : pred nat
  F : nat -> nat -> R
  ============================
  \big[*%M/1]_(m1 <= i < n1 | P i) \big[*%M/1]_(m2 <= j < n2 | Q j) F i j =
  \big[*%M/1]_(m2 <= j < n2 | Q j) \big[*%M/1]_(m1 <= i < n1 | P i) F i j
1 subgoal
  
  R : Type
  zero, one : R
  times : Monoid.mul_law 0
  plus : Monoid.add_law 0 *%M
  I : Type
  r : seq I
  a : R
  P : pred I
  F : I -> R
  ============================
  \big[+%M/0]_(i <- r | P i) F i * a = \big[+%M/0]_(i <- r | P i) (F i * a)
1 subgoal
  
  R : Type
  zero, one : R
  times : Monoid.mul_law 0
  plus : Monoid.add_law 0 *%M
  I : Type
  r : seq I
  a : R
  P : pred I
  F : I -> R
  ============================
  a * \big[+%M/0]_(i <- r | P i) F i = \big[+%M/0]_(i <- r | P i) (a * F i)
1 subgoal
  
  R : Type
  zero, one : R
  times : Monoid.mul_law 0
  plus : Monoid.add_law 0 *%M
  I : Type
  J : Type
  rI : seq I
  rJ : seq J
  pI : pred I
  pJ : pred J
  F : I -> R
  G : J -> R
  ============================
  \big[+%M/0]_(i <- rI | pI i) F i * \big[+%M/0]_(j <- rJ | pJ j) G j =
  \big[+%M/0]_(i <- rI | pI i) \big[+%M/0]_(j <- rJ | pJ j) (F i * G j)
1 subgoal
  
  R : Type
  zero, one : R
  times : Monoid.mul_law 0
  plus : Monoid.add_law 0 *%M
  I, J : finType
  j0 : J
  P : pred I
  Q : I -> pred J
  F : I -> J -> R
  ============================
  \big[*%M/1]_(i | P i) \big[+%M/0]_(j | Q i j) F i j =
  \big[+%M/0]_(f in pfamily j0 P Q)
     \big[*%M/1]_(i | P i) F i (fun_of_fin f i)
1 subgoal
  
  R : Type
  zero, one : R
  times : Monoid.mul_law 0
  plus : Monoid.add_law 0 *%M
  I, J : finType
  j0 : J
  P : pred I
  Q : pred J
  F : I -> J -> R
  ============================
  \big[*%M/1]_(i | P i) \big[+%M/0]_(j | Q j) F i j =
  \big[+%M/0]_(f in pffun_on j0 P Q)
     \big[*%M/1]_(i | P i) F i (fun_of_fin f i)
1 subgoal
  
  R : Type
  zero, one : R
  times : Monoid.mul_law 0
  plus : Monoid.add_law 0 *%M
  I, J : finType
  Q : I -> pred J
  F : I -> J -> R
  ============================
  \big[*%M/1]_i \big[+%M/0]_(j | Q i j) F i j =
  \big[+%M/0]_(f in family Q) \big[*%M/1]_i F i (fun_of_fin f i)
1 subgoal
  
  R : Type
  zero, one : R
  times : Monoid.mul_law 0
  plus : Monoid.add_law 0 *%M
  I, J : finType
  Q : pred J
  F : I -> J -> R
  ============================
  \big[*%M/1]_i \big[+%M/0]_(j | Q j) F i j =
  \big[+%M/0]_(f in ffun_on Q) \big[*%M/1]_i F i (fun_of_fin f i)
1 subgoal
  
  R : Type
  zero, one : R
  times : Monoid.mul_law 0
  plus : Monoid.add_law 0 *%M
  I, J : finType
  F : I -> J -> R
  ============================
  \big[*%M/1]_i \big[+%M/0]_j F i j =
  \big[+%M/0]_f \big[*%M/1]_i F i (fun_of_fin f i)
1 subgoal
  
  I : Type
  r : seq I
  P, B : pred I
  ============================
  \big[orb/false]_(i <- r) B i = has B r
1 subgoal
  
  I : Type
  r : seq I
  P, B : pred I
  ============================
  \big[andb/true]_(i <- r) B i = all B r
1 subgoal
  
  I : Type
  r : seq I
  P, B : pred I
  ============================
  \big[orb/false]_(i <- r | P i) B i = has (predI P B) r
1 subgoal
  
  I : Type
  r : seq I
  P, B : pred I
  ============================
  \big[andb/true]_(i <- r | P i) B i = all [pred i | P i ==> B i] r
1 subgoal
  
  I : finType
  P, B : pred I
  ============================
  \big[orb/false]_(i | P i) B i = [exists (i | P i), B i]
1 subgoal
  
  I : finType
  P, B : pred I
  ============================
  \big[andb/true]_(i | P i) B i = [forall (i | P i), B i]
1 subgoal
  
  I : finType
  A : pred I
  n : nat
  ============================
  \big[addn/0]_(i in A) n = #|A| * n
1 subgoal
  
  I : finType
  A : pred I
  ============================
  \big[addn/0]_(i in A) 1 = #|A|
1 subgoal
  
  I : finType
  A : pred I
  J : Type
  r : seq J
  a : pred J
  ============================
  \big[addn/0]_(j <- r | a j) 1 = count a r
1 subgoal
  
  I : finType
  A : pred I
  J : Type
  r : seq J
  ============================
  \big[addn/0]_(j <- r) 1 = size r
1 subgoal
  
  I : finType
  A : pred I
  n : nat
  ============================
  \big[muln/1]_(i in A) n = n ^ #|A|
1 subgoal
  
  I : finType
  A : pred I
  n1, n2, n : nat
  ============================
  \big[addn/0]_(n1 <= i < n2) n = (n2 - n1) * n
1 subgoal
  
  I : finType
  A : pred I
  n1, n2, n : nat
  ============================
  \big[muln/1]_(n1 <= i < n2) n = n ^ (n2 - n1)
1 subgoal
  
  I : finType
  P, C : pred I
  E1, E2 : I -> nat
  ============================
  (forall i : I, P i -> E1 i <= E2 i ?= iff C i) ->
  \sum_(i | P i) E1 i <= \sum_(i | P i) E2 i ?= iff [forall (i | P i), C i]
1 subgoal
  
  I : Type
  r : seq I
  P : pred I
  E1, E2 : I -> nat
  ============================
  (forall i : I, P i -> E1 i <= E2 i) ->
  \sum_(i <- r | P i) E1 i <= \sum_(i <- r | P i) E2 i
1 subgoal
  
  I : finType
  P : pred I
  E : I -> nat
  ============================
  (\big[addn/0]_(i | P i) E i == 0) = [forall (i | P i), E i == 0]
1 subgoal
  
  I : Type
  r : seq I
  P : pred I
  F : I -> nat
  ============================
  (forall i : I, P i -> 0 < F i) -> 0 < \prod_(i <- r | P i) F i
1 subgoal
  
  I : Type
  r : seq I
  P : pred I
  F : I -> nat
  ============================
  (forall i : I, 0 < F i) -> 0 < \prod_(i <- r | P i) F i
1 subgoal
  
  I : finType
  P : pred I
  F : I -> nat
  i0 : I
  ============================
  P i0 -> F i0 <= \max_(i | P i) F i
1 subgoal
  
  I : finType
  F : I -> nat
  i0 : I
  ============================
  F i0 <= \max_i F i
1 subgoal
  
  I : finType
  P : pred I
  m : nat
  F : I -> nat
  ============================
  reflect (forall i : I, P i -> F i <= m) (\max_(i | P i) F i <= m)
1 subgoal
  
  I : finType
  i0 : I
  P : pred I
  m : nat
  F : I -> nat
  ============================
  P i0 -> m <= F i0 -> m <= \max_(i | P i) F i
1 subgoal
  
  I : finType
  i0 : I
  P : pred I
  F : I -> nat
  ============================
  P i0 -> \big[maxn/0]_(i | P i) F i = F [arg max_(i > i0 | P i) F i]
1 subgoal
  
  I : finType
  A : pred I
  F : I -> nat
  ============================
  0 < #|A| -> {i0 : I | i0 \in A & \big[maxn/0]_(i in A) F i = F i0}
1 subgoal
  
  I : finType
  F : I -> nat
  ============================
  0 < #|I| -> {i0 : I | \big[maxn/0]_i F i = F i0}
1 subgoal
  
  m : nat
  I : Type
  r : seq I
  P : pred I
  F : I -> nat
  ============================
  m ^ (\sum_(i <- r | P i) F i) = \big[muln/1]_(i <- r | P i) m ^ F i
1 subgoal
  
  I : finType
  P : pred I
  F : I -> nat
  m : nat
  ============================
  reflect (forall i : I, P i -> F i %| m) (\big[lcmn/1]_(i | P i) F i %| m)
1 subgoal
  
  I : finType
  i0 : I
  P : pred I
  F : I -> nat
  m : nat
  ============================
  P i0 -> m %| F i0 -> m %| \big[lcmn/1]_(i | P i) F i
1 subgoal
  
  I : finType
  P : pred I
  F : I -> nat
  m : nat
  ============================
  reflect (forall i : I, P i -> m %| F i) (m %| \big[gcdn/0]_(i | P i) F i)
1 subgoal
  
  I : finType
  i0 : I
  P : pred I
  F : I -> nat
  m : nat
  ============================
  P i0 -> F i0 %| m -> \big[gcdn/0]_(i | P i) F i %| m
COQC prime.v
1 subgoal
  
  n : nat
  ============================
  edivn_spec n 2 (edivn2 0 n)
1 subgoal
  
  n : nat
  ============================
  elogn2_spec n.+1 (elogn2 0 n n)
1 subgoal
  
  T : Type
  n : nat
  x, y : T
  ============================
  ifnz_spec n x y (ifnz n x y)
1 subgoal
  
  ============================
  let pd_val :=
    (BigOp.bigop 1)^~ (fun f : nat * nat =>
                       BigBody f muln true (pfactor f.1 f.2)) in
  let lb_dvd := fun q m : nat => ~~ has [pred d | d %| m] (index_iota 2 q) in
  let pf_ok := fun f : nat * nat => lb_dvd f.1 f.1 && (0 < f.2) in
  let pd_ord :=
    fun (q : nat) (pd : seq (nat * nat)) => path ltn q (unzip1 pd) in
  let pd_ok :=
    fun (q n : nat) (pd : seq (nat * nat)) =>
    [/\ n = pd_val pd, all pf_ok pd & pd_ord q pd] in
  forall n : nat, 0 < n -> pd_ok 1 n (prime_decomp n)
1 subgoal
  
  n : nat
  ============================
  reflect (n < 2 \/ (exists2 d : nat, (1 < d) && (d < n) & d %| n))
    (~~ prime n)
1 subgoal
  
  p : nat
  ============================
  reflect (1 < p /\ (forall d : nat, d %| p -> xpred2 1 p d)) (prime p)
1 subgoal
  
  d : nat_eqType
  p : nat
  ============================
  prime p -> d != 1 -> reflect (d = p) (d %| p)
1 subgoal
  
  p : nat
  ============================
  prime p -> 1 < p
1 subgoal
  
  p : nat
  ============================
  prime p -> 0 < p
1 subgoal
  
  n : nat
  ============================
  0 < n -> n = \big[muln/1]_(f <- prime_decomp n) f.1 ^ f.2
1 subgoal
  
  p : nat
  ============================
  prime p -> p = 2 \/ odd p
1 subgoal
  
  p : nat
  ============================
  prime p -> reflect (p = 2) (~~ odd p)
1 subgoal
  
  p : nat
  ============================
  odd p -> prime p -> 2 < p
1 subgoal
  
  n : nat
  p, e : nat_eqType
  ============================
  (p, e) \in prime_decomp n -> [/\ prime p, 0 < e & p ^ e %| n]
1 subgoal
  
  p, m : nat
  ============================
  prime p -> coprime p m = ~~ (p %| m)
1 subgoal
  
  p, q : nat
  ============================
  prime p -> prime q -> (p %| q) = (p == q)
1 subgoal
  
  m, n, p : nat
  ============================
  prime p -> (p %| m * n) = (p %| m) || (p %| n)
1 subgoal
  
  p : nat
  ============================
  prime p -> (p %| 1) = false
1 subgoal
  
  m, n, p : nat
  ============================
  prime p -> (p %| m ^ n) = (p %| m) && (0 < n)
1 subgoal
  
  p : nat_eqType
  n : nat
  ============================
  (p \in primes n) = [&& prime p, 0 < n & p %| n]
1 subgoal
  
  n : nat
  ============================
  sorted ltn (primes n)
1 subgoal
  
  m, n : nat
  ============================
  primes m =i primes n <-> primes m = primes n
1 subgoal
  
  n : nat
  ============================
  uniq (primes n)
1 subgoal
  
  n : nat
  ============================
  (pdiv n \in \pi(n)) = (1 < n)
1 subgoal
  
  n : nat
  ============================
  1 < n -> prime (pdiv n)
1 subgoal
  
  n : nat
  ============================
  pdiv n %| n
1 subgoal
  
  n : nat
  ============================
  (max_pdiv n \in \pi(n)) = (1 < n)
1 subgoal
  
  n : nat
  ============================
  1 < n -> prime (max_pdiv n)
1 subgoal
  
  n : nat
  ============================
  max_pdiv n %| n
1 subgoal
  
  n : nat
  ============================
  0 < n -> pdiv n <= n
1 subgoal
  
  n : nat
  ============================
  0 < n -> max_pdiv n <= n
1 subgoal
  
  n : nat
  ============================
  0 < pdiv n
1 subgoal
  
  n : nat
  ============================
  0 < max_pdiv n
1 subgoal
  
  m, d : nat
  ============================
  1 < d -> d %| m -> pdiv m <= d
1 subgoal
  
  n : pi_unwrapped_arg
  p : nat
  ============================
  p \in \pi(n) -> p <= max_pdiv n
1 subgoal
  
  n : nat
  ============================
  0 < n -> n < pdiv n ^ 2 -> prime n
1 subgoal
  
  n : nat
  ============================
  reflect (n < 2 \/ (exists p : nat, [/\ prime p, p ^ 2 <= n & p %| n]))
    (~~ prime n)
1 subgoal
  
  n : nat
  ============================
  1 < n -> {p : nat | prime p & p %| n}
1 subgoal
  
  m, n : nat
  p : nat_eqType
  ============================
  0 < m ->
  0 < n -> (p \in primes (m * n)) = (p \in primes m) || (p \in primes n)
1 subgoal
  
  m, n : nat
  ============================
  0 < n -> primes (m ^ n) = primes m
1 subgoal
  
  p : nat
  ============================
  prime p -> primes p = [:: p]
1 subgoal
  
  m, n : nat
  ============================
  0 < m -> 0 < n -> coprime m n = ~~ has (mem (primes m)) (primes n)
1 subgoal
  
  p : nat
  ============================
  prime p -> pdiv p = p
1 subgoal
  
  p, k : nat
  ============================
  prime p -> pdiv (p ^ k.+1) = p
1 subgoal
  
  m : nat
  ============================
  {p : nat | m < p & prime p}
1 subgoal
  
  p, m : nat
  ============================
  logn p m =
  (if [&& prime p, 0 < m & p %| m] then (logn p (m %/ p)).+1 else 0)
1 subgoal
  
  p, n : nat
  ============================
  (0 < logn p n) = (p \in primes n)
1 subgoal
  
  p, n : nat
  ============================
  n < p -> logn p n = 0
1 subgoal
  
  p : nat
  ============================
  logn p 0 = 0
1 subgoal
  
  p : nat
  ============================
  logn p 1 = 0
1 subgoal
  
  p, n : nat
  ============================
  0 < p ^ logn p n
1 subgoal
  
  p, n, m : nat
  ============================
  prime p -> 0 < m -> (p ^ n %| m) = (n <= logn p m)
1 subgoal
  
  p, n : nat
  ============================
  p ^ logn p n %| n
1 subgoal
  
  p, q : nat
  ============================
  prime q -> logn p q = (p == q)
1 subgoal
  
  p, n : nat
  ============================
  prime p -> 0 < n -> {m : nat | coprime p m & n = m * p ^ logn p n}
1 subgoal
  
  p, n : nat
  ============================
  prime p -> logn p (p ^ n) = n
1 subgoal
  
  p, n : nat
  ============================
  prime p -> logn (pdiv (p ^ n)) (p ^ n) = n
1 subgoal
  
  p, m, n : nat
  ============================
  0 < n -> m %| n -> logn p m <= logn p n
1 subgoal
  
  p, n : nat
  ============================
  0 < n -> logn p n < n
1 subgoal
  
  p, m, n : nat
  ============================
  coprime p m -> logn p (m * n) = logn p n
1 subgoal
  
  p, m, n : nat
  ============================
  0 < m -> 0 < n -> logn p (m * n) = logn p m + logn p n
1 subgoal
  
  p, m, n : nat
  ============================
  logn p (m ^ n) = n * logn p m
1 subgoal
  
  p, m, n : nat
  ============================
  m %| n -> logn p (n %/ m) = logn p n - logn p m
1 subgoal
  
  p, d, n : nat
  ============================
  prime p -> reflect (exists2 m : nat, m <= n & d = p ^ m) (d %| p ^ n)
1 subgoal
  
  n : nat
  ============================
  prime_decomp n = [seq (p, logn p n) | p <- primes n]
1 subgoal
  
  d, n : nat
  ============================
  n %/ d = \big[addn/0]_(1 <= i < n.+1) (d %| i)
1 subgoal
  
  p, n : nat
  ============================
  prime p -> logn p n = \big[addn/0]_(1 <= k < n) (p ^ k %| n)
1 subgoal
  
  p, n : nat
  ============================
  1 < p -> 0 < n -> let k := trunc_log p n in (p ^ k <= n) && (n < p ^ k.+1)
1 subgoal
  
  p, n : nat
  ============================
  1 < p -> n < p ^ (trunc_log p n).+1
1 subgoal
  
  p, n : nat
  ============================
  1 < p -> 0 < n -> p ^ trunc_log p n <= n
1 subgoal
  
  p, k, j : nat
  ============================
  1 < p -> p ^ j <= k -> j <= trunc_log p k
1 subgoal
  
  pi : nat_pred
  ============================
  (pi^')^' =i pi
1 subgoal
  
  pi1, pi2 : nat_pred
  ============================
  pi1 =i pi2 -> pi1^' =i pi2^'
1 subgoal
  
  m : pi_unwrapped_arg
  n : nat
  ============================
  \pi(m) =i \pi(n) <-> \pi(m) = \pi(n)
1 subgoal
  
  pi : nat_pred
  n : nat
  ============================
  0 < n`_pi
1 subgoal
  
  pi1, pi2 : nat_pred
  n : nat
  ============================
  {in \pi(n), {subset pi1 <= pi2}} -> n`_pi1 %| n`_pi2
1 subgoal
  
  pi1, pi2 : nat_pred
  n : nat
  ============================
  {in \pi(n), pi1 =i pi2} -> n`_pi1 = n`_pi2
1 subgoal
  
  pi1, pi2 : nat_pred
  n : nat
  ============================
  pi1 =i pi2 -> n`_pi1 = n`_pi2
1 subgoal
  
  pi : nat_pred
  n : nat
  ============================
  n`_(pi^')^' = n`_pi
1 subgoal
  
  m : nat
  pi : nat_pred
  n : nat
  ============================
  n <= m -> n`_pi = \big[muln/1]_(0 <= p < m.+1 | p \in pi) p ^ logn p n
1 subgoal
  
  pi : nat_pred
  ============================
  0`_pi = 1
1 subgoal
  
  pi : nat_pred
  ============================
  1`_pi = 1
1 subgoal
  
  pi : nat_pred
  m, n : nat
  ============================
  0 < m -> 0 < n -> (m * n)`_pi = m`_pi * n`_pi
1 subgoal
  
  pi : nat_pred
  m, n : nat
  ============================
  (m ^ n)`_pi = m`_pi ^ n
1 subgoal
  
  pi : nat_pred
  m, n : nat
  ============================
  0 < n -> m %| n -> m`_pi %| n`_pi
1 subgoal
  
  p, n : nat
  ============================
  n`_p = p ^ logn p n
1 subgoal
  
  p, n : nat
  ============================
  (n`_p == 1) = (p \notin \pi(n))
1 subgoal
  
  p, n : nat
  ============================
  (1 < n`_p) = (p \in \pi(n))
1 subgoal
  
  pi : nat_pred
  n : nat
  ============================
  primes n`_pi = [seq x <- primes n | (mem pi) x]
1 subgoal
  
  n, m : nat
  ============================
  n < m -> [seq x <- index_iota 0 m | \pi(n) x] = primes n
1 subgoal
  
  n : nat
  ============================
  0 < n -> n`_\pi(n) = n
1 subgoal
  
  n : nat
  ============================
  0 < n -> n`_predT = n
1 subgoal
  
  pi : nat_pred
  n : nat
  ============================
  0 < n -> n`_pi * n`_pi^' = n
1 subgoal
  
  pi : nat_pred
  n : nat
  ============================
  n`_pi %| n
1 subgoal
  
  p, m : nat
  ============================
  logn p m`_p = logn p m
1 subgoal
  
  pi : nat_pred
  m, n : nat
  ============================
  0 < m -> 0 < n -> (lcmn m n)`_pi = lcmn m`_pi n`_pi
1 subgoal
  
  pi : nat_pred
  m, n : nat
  ============================
  0 < m -> 0 < n -> (gcdn m n)`_pi = gcdn m`_pi n`_pi
1 subgoal
  
  I : finType
  P : pred I
  F : I -> nat
  pi : nat_pred
  ============================
  (forall i : I, P i -> 0 < F i) ->
  (\big[lcmn/1]_(i | P i) F i)`_pi = \big[lcmn/1]_(i | P i) (F i)`_pi
1 subgoal
  
  I : finType
  P : pred I
  F : I -> nat
  pi : nat_pred
  ============================
  0 < #|[pred x | P x]| ->
  (forall i : I, P i -> 0 < F i) ->
  (\big[gcdn/0]_(i | P i) F i)`_pi = \big[gcdn/0]_(i | P i) (F i)`_pi
1 subgoal
  
  pi, rho : nat_pred
  n : nat
  ============================
  {in \pi(n), {subset pi <= rho}} -> pi.-nat n -> rho.-nat n
1 subgoal
  
  pi, rho : nat_pred
  n : nat
  ============================
  {in \pi(n), pi =i rho} -> pi.-nat n = rho.-nat n
1 subgoal
  
  pi, rho : nat_pred
  n : nat
  ============================
  pi =i rho -> pi.-nat n = rho.-nat n
1 subgoal
  
  pi : nat_pred
  n : nat
  ============================
  ((pi^')^').-nat n = pi.-nat n
1 subgoal
  
  pi, rho : nat_pred
  n : nat
  ============================
  [predI pi & rho].-nat n = pi.-nat n && rho.-nat n
1 subgoal
  
  pi : nat_pred
  m, n : nat
  ============================
  pi.-nat (m * n) = pi.-nat m && pi.-nat n
1 subgoal
  
  pi : nat_pred
  m, n : nat
  ============================
  pi.-nat (m ^ n) = pi.-nat m || (n == 0)
1 subgoal
  
  pi : nat_pred
  n : nat
  ============================
  pi.-nat n`_pi
1 subgoal
  
  pi : nat_pred
  p : nat
  ============================
  prime p -> pi.-nat p = (p \in pi)
1 subgoal
  
  p : nat
  ============================
  prime p -> p.-nat p
1 subgoal
  
  m, n : nat
  ============================
  0 < m -> 0 < n -> coprime m n = ((\pi(m))^').-nat n
1 subgoal
  
  n : nat
  ============================
  0 < n -> (\pi(n)).-nat n
1 subgoal
  
  m, n : nat
  ============================
  m %| n -> 0 < n -> {subset \pi(m) <= \pi(n)}
1 subgoal
  
  m, n : nat
  ============================
  0 < m -> 0 < n -> \pi(m * n) =i [predU \pi(m) & \pi(n)]
1 subgoal
  
  pi : nat_pred
  n : nat
  ============================
  0 < n -> \pi(n`_pi) =i [predI \pi(n) & pi]
1 subgoal
  
  p, n : nat
  ============================
  0 < n -> \pi(p ^ n) = \pi(p)
1 subgoal
  
  p : nat
  ============================
  prime p -> \pi(p) =i (p : nat_pred)
1 subgoal
  
  p, n : nat
  ============================
  0 < n -> (p^').-nat n = (p \notin \pi(n))
1 subgoal
  
  p, n : nat
  ============================
  prime p -> (p^').-nat n = ~~ (p %| n)
1 subgoal
  
  pi : nat_pred
  n, p : nat
  ============================
  pi.-nat n -> p \in \pi(n) -> p \in pi
1 subgoal
  
  m, n : nat
  pi : nat_pred
  ============================
  m %| n -> pi.-nat n -> pi.-nat m
1 subgoal
  
  m, n : nat
  pi : nat_pred
  ============================
  m %| n -> pi.-nat n -> pi.-nat (n %/ m)
1 subgoal
  
  pi : nat_pred
  m, n : nat
  ============================
  pi.-nat m -> (pi^').-nat n -> coprime m n
1 subgoal
  
  pi : nat_pred
  m, n : nat
  ============================
  (pi^').-nat m -> pi.-nat n -> coprime m n
1 subgoal
  
  pi, rho : nat_pred
  m, n : nat
  ============================
  {subset rho <= pi^'} -> pi.-nat m -> rho.-nat n -> coprime m n
1 subgoal
  
  pi : nat_pred
  m, n : nat
  ============================
  coprime m`_pi n`_pi^'
1 subgoal
  
  pi : nat_pred
  n : nat
  ============================
  pi.-nat n -> (pi^').-nat n -> n = 1
1 subgoal
  
  pi : nat_pred
  n : nat
  ============================
  pi.-nat n -> n`_pi = n
1 subgoal
  
  pi : nat_pred
  n : nat
  ============================
  (pi^').-nat n -> n`_pi = 1
1 subgoal
  
  pi : nat_pred
  n : nat
  ============================
  0 < n -> (n`_pi == 1) = (pi^').-nat n
1 subgoal
  
  pi : nat_pred
  n : nat
  ============================
  0 < n ->
  reflect (forall p : nat, prime p -> p %| n -> p \in pi) (pi.-nat n)
1 subgoal
  
  pi : nat_pred
  p, n : nat
  ============================
  p.-nat n -> p \in pi -> pi.-nat n
1 subgoal
  
  p, n : nat
  ============================
  p.-nat n -> {k : nat | n = p ^ k}
1 subgoal
  
  pi : nat_pred
  p, n : nat
  ============================
  (pi^').-nat n -> p \in pi -> (p^').-nat n
1 subgoal
  
  p : nat
  pi : nat_pred
  n : nat
  ============================
  pi.-nat n -> p \in pi^' -> (p^').-nat n
1 subgoal
  
  pi, rho : nat_pred
  n : nat
  ============================
  {subset pi <= rho} -> n`_rho`_pi = n`_pi
1 subgoal
  
  pi, rho : nat_pred
  n : nat
  ============================
  n`_[predI pi & rho] = n`_pi`_rho
1 subgoal
  
  n : nat
  ============================
  odd n = (2^').-nat n
1 subgoal
  
  n : nat
  ============================
  0 < n ->
  [/\ uniq (divisors n), sorted leq (divisors n)
    & forall d : nat_eqType, (d \in divisors n) = (d %| n)]
1 subgoal
  
  n : nat
  ============================
  sorted leq (divisors n)
1 subgoal
  
  n : nat
  ============================
  uniq (divisors n)
1 subgoal
  
  n : nat
  ============================
  sorted ltn (divisors n)
1 subgoal
  
  d, m : nat
  ============================
  0 < m -> (d %| m) = (d \in divisors m)
1 subgoal
  
  n : nat
  ============================
  1 \in divisors n
1 subgoal
  
  n : nat
  ============================
  0 < n -> n \in divisors n
1 subgoal
  
  d : nat
  I : Type
  r : seq I
  K : pred I
  F : I -> nat
  ============================
  (forall i : I, K i -> d %| F i) -> d %| \sum_(i <- r | K i) F i
1 subgoal
  
  n, m : nat
  ============================
  0 < n -> reflect (forall p : nat, p \in \pi(n) -> n`_p %| m) (n %| m)
1 subgoal
  
  n, a, b : nat
  ============================
  0 < n ->
  reflect (forall p : nat, p \in \pi(n) -> a = b %[mod n`_p])
    (a %% n == b %% n)
1 subgoal
  
  n : nat
  ============================
  0 < n ->
  totient n = \big[muln/1]_(p <- primes n) (p.-1 * p ^ (logn p n).-1)
1 subgoal
  
  n : nat
  ============================
  (0 < totient n) = (0 < n)
1 subgoal
  
  p, e : nat
  ============================
  prime p -> 0 < e -> totient (p ^ e) = p.-1 * p ^ e.-1
1 subgoal
  
  m, n : nat
  ============================
  coprime m n -> totient (m * n) = totient m * totient n
1 subgoal
  
  n : nat
  ============================
  totient n = \big[addn/0]_(0 <= d < n) coprime n d
COQC finset.v
1 subgoal
  
  ============================
  finset = finset_def
1 subgoal
  
  ============================
  pred_of_set =
  (fun (T : finType) (A : set_type T) => fun_of_fin (val A) : T -> bool)
1 subgoal
  
  T : finType
  pA : pred T
  x : T
  ============================
  (x \in [set x | pA x]) = pA x
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  pred_of_set A =i pred_of_set B <-> A = B
1 subgoal
  
  T : finType
  x : T
  ============================
  x \in pred_of_set (setTfor (Phant T))
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  {A = B} + {A != B}
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  (A == B) =
  (pred_of_set A \subset pred_of_set B) &&
  (pred_of_set B \subset pred_of_set A)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  (pred_of_set A \subset pred_of_set B) =
  (A == B) || (pred_of_set A \proper pred_of_set B)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  pred_of_set A \subset pred_of_set B ->
  A = B \/ pred_of_set A \proper pred_of_set B
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  (pred_of_set A \proper pred_of_set B) =
  (A != B) && (pred_of_set A \subset pred_of_set B)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  pred_of_set A \proper pred_of_set B -> A != B
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  (A == B) =
  (pred_of_set A \subset pred_of_set B) &&
  ~~ (pred_of_set A \proper pred_of_set B)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  (A == B) =
  (pred_of_set A \subset pred_of_set B) &&
  (#|pred_of_set B| <= #|pred_of_set A|)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  (pred_of_set A \proper pred_of_set B) =
  (pred_of_set A \subset pred_of_set B) &&
  (#|pred_of_set A| < #|pred_of_set B|)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  pred_of_set A \subset pred_of_set B ->
  #|pred_of_set A| <= #|pred_of_set B| ?= iff (A == B)
1 subgoal
  
  T : finType
  x : T
  ============================
  (x \in pred_of_set set0) = false
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  pred_of_set set0 \subset pred_of_set A
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  (pred_of_set A \subset pred_of_set set0) = (A == set0)
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  (pred_of_set set0 \proper pred_of_set A) = (A != set0)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  pred_of_set A \subset pred_of_set B -> A != set0 -> B != set0
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  (A = set0) + {x : T | x \in pred_of_set A}
1 subgoal
  
  T : finType
  ============================
  enum (pred_of_set set0) = [::]
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  pred_of_set A \subset [set: T]
1 subgoal
  
  T : finType
  mA : mem_pred T
  ============================
  subset mA (mem [set: T])
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  ([set: T] \subset pred_of_set A) = (A == [set: T])
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  (pred_of_set A \proper [set: T]) = (A != [set: T])
1 subgoal
  
  T : finType
  x, a : T
  ============================
  reflect (x = a) (x \in [set a])
1 subgoal
  
  T : finType
  ============================
  enum [set: T] = Finite.enum T
1 subgoal
  
  T : finType
  x, a : T
  ============================
  (x \in [set a]) = (x == a)
1 subgoal
  
  T : finType
  x : T
  ============================
  x \in [set x]
1 subgoal
  
  T : finType
  ============================
  injective (set1 (T:=T))
1 subgoal
  
  T : finType
  a : T
  ============================
  enum [set a] = [:: a]
1 subgoal
  
  T : finType
  x, a : T
  B : {set T}
  ============================
  reflect (x = a \/ x \in pred_of_set B) (x \in a |: B)
1 subgoal
  
  T : finType
  x, a : T
  B : {set T}
  ============================
  (x \in a |: B) = (x == a) || (x \in pred_of_set B)
1 subgoal
  
  T : finType
  a : T
  s : seq T
  ============================
  [set x in a :: s] = a |: [set x in s]
1 subgoal
  
  T : finType
  x : T
  B : {set T}
  ============================
  x \in x |: B
1 subgoal
  
  T : finType
  x, a : T
  B : {set T}
  ============================
  x \in pred_of_set B -> x \in a |: B
1 subgoal
  
  T : finType
  x : T
  A : {set T}
  b : T
  ============================
  x \in pred_of_set A -> x \in A :|: [set b]
1 subgoal
  
  T : finType
  A : {set T}
  b : T
  ============================
  b \in A :|: [set b]
1 subgoal
  
  T : finType
  x, a : T
  ============================
  (x \in [set~ a]) = (x != a)
1 subgoal
  
  T : finType
  x : T
  ============================
  (x \in [set~ x]) = false
1 subgoal
  
  T : finType
  x : T
  A : {set T}
  b : T
  ============================
  reflect (x != b /\ x \in pred_of_set A) (x \in A :\ b)
1 subgoal
  
  T : finType
  x : T
  A : {set T}
  b : T
  ============================
  (x \in A :\ b) = (x != b) && (x \in pred_of_set A)
1 subgoal
  
  T : finType
  b : T
  A : {set T}
  ============================
  (b \in A :\ b) = false
1 subgoal
  
  T : finType
  a : T
  A : {set T}
  ============================
  a \in pred_of_set A -> a |: A :\ a = A
1 subgoal
  
  T : finType
  a : T
  B : {set T}
  ============================
  a \notin pred_of_set B -> (a |: B) :\ a = B
1 subgoal
  
  T : finType
  x, a, b : T
  ============================
  reflect (x = a \/ x = b) (x \in [set a; b])
1 subgoal
  
  T : finType
  x, a, b : T
  ============================
  (x \in [set a; b]) = (x == a) || (x == b)
1 subgoal
  
  T : finType
  a, b : T
  ============================
  a \in [set a; b]
1 subgoal
  
  T : finType
  a, b : T
  ============================
  b \in [set a; b]
1 subgoal
  
  T : finType
  x : T
  A, B : {set T}
  ============================
  reflect (x \in pred_of_set A \/ x \in pred_of_set B) (x \in A :|: B)
1 subgoal
  
  T : finType
  x : T
  A, B : {set T}
  ============================
  (x \in A :|: B) = (x \in pred_of_set A) || (x \in pred_of_set B)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  A :|: B = B :|: A
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  pred_of_set A \subset pred_of_set B -> C :|: A \subset C :|: B
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  pred_of_set A \subset pred_of_set B -> A :|: C \subset B :|: C
1 subgoal
  
  T : finType
  A, B, C, D : {set T}
  ============================
  pred_of_set A \subset pred_of_set C ->
  pred_of_set B \subset pred_of_set D -> A :|: B \subset C :|: D
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  set0 :|: A = A
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  A :|: set0 = A
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  A :|: (B :|: C) = A :|: B :|: C
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  A :|: (B :|: C) = B :|: (A :|: C)
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  A :|: B :|: C = A :|: C :|: B
1 subgoal
  
  T : finType
  A, B, C, D : {set T}
  ============================
  A :|: B :|: (C :|: D) = A :|: C :|: (B :|: D)
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  [set: T] :|: A = [set: T]
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  A :|: [set: T] = [set: T]
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  A :|: A = A
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  A :|: B :|: C = A :|: C :|: (B :|: C)
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  A :|: (B :|: C) = A :|: B :|: (A :|: C)
1 subgoal
  
  T : finType
  x : T
  pA, pB : pred T
  ============================
  reflect (pA x /\ pB x) (x \in [set y | pA y & pB y])
1 subgoal
  
  T : finType
  x : T
  pA, pB, pC : pred T
  ============================
  reflect [/\ pA x, pB x & pC x] (x \in [set y | pA y & pB y && pC y])
1 subgoal
  
  T : finType
  A : {set T}
  pB : pred T
  ============================
  [set x in pred_of_set A | pB x] = A :&: [set x | pB x]
1 subgoal
  
  T : finType
  x : T
  A, B : {set T}
  ============================
  reflect (x \in pred_of_set A /\ x \in pred_of_set B) (x \in A :&: B)
1 subgoal
  
  T : finType
  x : T
  A, B : {set T}
  ============================
  (x \in A :&: B) = (x \in pred_of_set A) && (x \in pred_of_set B)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  A :&: B = B :&: A
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  pred_of_set A \subset pred_of_set B -> C :&: A \subset C :&: B
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  pred_of_set A \subset pred_of_set B -> A :&: C \subset B :&: C
1 subgoal
  
  T : finType
  A, B, C, D : {set T}
  ============================
  pred_of_set A \subset pred_of_set C ->
  pred_of_set B \subset pred_of_set D -> A :&: B \subset C :&: D
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  [set: T] :&: A = A
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  A :&: [set: T] = A
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  set0 :&: A = set0
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  A :&: set0 = set0
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  A :&: (B :&: C) = A :&: B :&: C
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  A :&: (B :&: C) = B :&: (A :&: C)
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  A :&: B :&: C = A :&: C :&: B
1 subgoal
  
  T : finType
  A, B, C, D : {set T}
  ============================
  A :&: B :&: (C :&: D) = A :&: C :&: (B :&: D)
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  A :&: A = A
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  A :&: B :&: C = A :&: C :&: (B :&: C)
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  A :&: (B :&: C) = A :&: B :&: (A :&: C)
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  A :&: (B :|: C) = A :&: B :|: A :&: C
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  (A :|: B) :&: C = A :&: C :|: B :&: C
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  A :|: B :&: C = (A :|: B) :&: (A :|: C)
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  A :&: B :|: C = (A :|: C) :&: (B :|: C)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  (A :|: B) :&: A = A
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  A :&: (B :|: A) = A
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  A :&: B :|: A = A
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  A :|: B :&: A = A
1 subgoal
  
  T : finType
  x : T
  A : {set T}
  ============================
  reflect (~ x \in pred_of_set A) (x \in ~: A)
1 subgoal
  
  T : finType
  x : T
  A : {set T}
  ============================
  (x \in ~: A) = (x \notin pred_of_set A)
1 subgoal
  
  T : finType
  ============================
  involutive (setC (T:=T))
1 subgoal
  
  T : finType
  ============================
  injective (setC (T:=T))
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  (pred_of_set A \subset pred_of_set B) = [disjoint pred_of_set A & ~: B]
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  [disjoint pred_of_set A & pred_of_set B] = (pred_of_set A \subset ~: B)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  (A \in pred_of_set (powerset (~: B))) =
  [disjoint pred_of_set A & pred_of_set B]
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  (~: A \subset ~: B) = (pred_of_set B \subset pred_of_set A)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  ~: (A :|: B) = ~: A :&: ~: B
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  ~: (A :&: B) = ~: A :|: ~: B
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  A :|: ~: A = [set: T]
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  A :&: ~: A = set0
1 subgoal
  
  T : finType
  ============================
  ~: set0 = [set: T]
1 subgoal
  
  T : finType
  ============================
  ~: [set: T] = set0
1 subgoal
  
  T : finType
  A, B : {set T}
  x : T
  ============================
  reflect (x \in pred_of_set A /\ x \notin pred_of_set B) (x \in A :\: B)
1 subgoal
  
  T : finType
  A, B : {set T}
  x : T
  ============================
  (x \in A :\: B) = (x \notin pred_of_set B) && (x \in pred_of_set A)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  A :\: B = A :&: ~: B
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  pred_of_set A \subset pred_of_set B -> A :\: C \subset B :\: C
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  pred_of_set A \subset pred_of_set B -> C :\: B \subset C :\: A
1 subgoal
  
  T : finType
  A, B, C, D : {set T}
  ============================
  pred_of_set A \subset pred_of_set C ->
  pred_of_set D \subset pred_of_set B -> A :\: B \subset C :\: D
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  A :\: set0 = A
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  set0 :\: A = set0
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  A :\: [set: T] = set0
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  [set: T] :\: A = ~: A
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  A :\: A = set0
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  ~: (A :\: B) = ~: A :|: B
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  A :&: B :|: A :\: B = A
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  (A :|: B) :\: C = A :\: C :|: B :\: C
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  A :\: (B :|: C) = (A :\: B) :&: (A :\: C)
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  A :&: B :\: C = (A :\: C) :&: (B :\: C)
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  A :&: (B :\: C) = A :&: B :\: C
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  (A :\: B) :&: C = A :&: C :\: B
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  A :\: B :&: C = A :\: B :|: A :\: C
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  A :\: B :\: C = A :\: (B :|: C)
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  A :\: (B :\: C) = A :\: B :|: A :&: C
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  (A \in pred_of_set (powerset B)) = (pred_of_set A \subset pred_of_set B)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  (pred_of_set (powerset A) \subset pred_of_set (powerset B)) =
  (pred_of_set A \subset pred_of_set B)
1 subgoal
  
  T : finType
  ============================
  powerset set0 = [set set0]
1 subgoal
  
  T : finType
  ============================
  powerset [set: T] = [set: {set T}]
1 subgoal
  
  T : finType
  P : {set set_of_finType T}
  A : {set T}
  ============================
  P :&: powerset A = P ::&: A
1 subgoal
  
  T : finType
  pA : pred T
  ============================
  #|[set x in pA]| = #|pA|
1 subgoal
  
  T : finType
  pA : pred T
  ============================
  \big[addn/0]_(x | pA x) 1 = #|[set x | pA x]|
1 subgoal
  
  T : finType
  pA : pred T
  n : nat
  ============================
  \big[addn/0]_(x | pA x) n = #|[set x | pA x]| * n
1 subgoal
  
  T : finType
  ============================
  #|pred_of_set set0| = 0
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  (#|pred_of_set A| == 0) = (A == set0)
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  reflect (exists x : T, x \in pred_of_set A) (A != set0)
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  (0 < #|pred_of_set A|) = (A != set0)
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  #|pred_of_set A| = 0 -> A = set0
1 subgoal
  
  T : finType
  x : T
  ============================
  #|[set x]| = 1
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  #|A :|: B| + #|A :&: B| = #|pred_of_set A| + #|pred_of_set B|
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  #|A :|: B| = #|pred_of_set A| + #|pred_of_set B| - #|A :&: B|
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  #|A :&: B| = #|pred_of_set A| + #|pred_of_set B| - #|A :|: B|
1 subgoal
  
  T : finType
  ============================
  #|[set: T]| = #|T|
1 subgoal
  
  T : finType
  B, A : {set T}
  ============================
  #|A :&: B| + #|A :\: B| = #|pred_of_set A|
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  #|A :\: B| = #|pred_of_set A| - #|A :&: B|
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  #|pred_of_set A| + #|~: A| = #|T|
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  #|pred_of_set A| = #|T| - #|~: A|
1 subgoal
  
  T : finType
  a : T
  A : {set T}
  ============================
  #|a |: A| = (a \notin pred_of_set A) + #|pred_of_set A|
1 subgoal
  
  T : finType
  a, b : T
  ============================
  #|[set a; b]| = (a != b).+1
1 subgoal
  
  T : finType
  a : T
  ============================
  #|[set~ a]| = #|T|.-1
1 subgoal
  
  T : finType
  a : T
  A : {set T}
  ============================
  #|pred_of_set A| = (a \in pred_of_set A) + #|A :\ a|
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  A :&: B \subset pred_of_set A
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  A :&: B \subset pred_of_set B
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  pred_of_set A \subset A :|: B
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  pred_of_set B \subset A :|: B
1 subgoal
  
  T : finType
  x : T
  A : {set T}
  ============================
  pred_of_set A \subset x |: A
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  A :\: B \subset pred_of_set A
1 subgoal
  
  T : finType
  A : {set T}
  x : T
  ============================
  A :\ x \subset pred_of_set A
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  A :\: B \subset ~: B
1 subgoal
  
  T : finType
  A : {set T}
  x : T
  ============================
  ([set x] \subset pred_of_set A) = (x \in pred_of_set A)
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  reflect (exists x : T, A = [set x]) (#|pred_of_set A| == 1)
1 subgoal
  
  T : finType
  A : {set T}
  x : T
  ============================
  (pred_of_set A \subset [set x]) = (A == [set x]) || (A == set0)
1 subgoal
  
  T : finType
  x : T
  ============================
  powerset [set x] = [set set0; [set x]]
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  reflect (A :&: B = A) (pred_of_set A \subset pred_of_set B)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  reflect (A :&: B = B) (pred_of_set B \subset pred_of_set A)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  pred_of_set B \subset pred_of_set A ->
  #|A :\: B| = #|pred_of_set A| - #|pred_of_set B|
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  reflect (A :|: B = A) (pred_of_set B \subset pred_of_set A)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  reflect (A :|: B = B) (pred_of_set A \subset pred_of_set B)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  reflect (A :\: B = A) [disjoint pred_of_set A & pred_of_set B]
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  (pred_of_set B \subset pred_of_set A)
  || (pred_of_set C \subset pred_of_set A) -> B :&: C \subset pred_of_set A
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  (pred_of_set A \subset B :&: C) =
  (pred_of_set A \subset pred_of_set B) &&
  (pred_of_set A \subset pred_of_set C)
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  reflect
    (pred_of_set A \subset pred_of_set B /\
     pred_of_set A \subset pred_of_set C) (pred_of_set A \subset B :&: C)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  (pred_of_set A \subset A :&: B) = (pred_of_set A \subset pred_of_set B)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  (pred_of_set B \subset A :&: B) = (pred_of_set B \subset pred_of_set A)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  powerset (A :&: B) = powerset A :&: powerset B
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  (B :|: C \subset pred_of_set A) =
  (pred_of_set B \subset pred_of_set A) &&
  (pred_of_set C \subset pred_of_set A)
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  (pred_of_set A \subset pred_of_set B)
  || (pred_of_set A \subset pred_of_set C) -> pred_of_set A \subset B :|: C
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  reflect
    (pred_of_set A \subset pred_of_set C /\
     pred_of_set B \subset pred_of_set C) (A :|: B \subset pred_of_set C)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  (pred_of_set A \subset ~: B) = (pred_of_set B \subset ~: A)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  (~: A \subset pred_of_set B) = (~: B \subset pred_of_set A)
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  (pred_of_set A \subset B :\: C) =
  (pred_of_set A \subset pred_of_set B) &&
  [disjoint pred_of_set A & pred_of_set C]
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  (A :\: B \subset pred_of_set C) = (pred_of_set A \subset B :|: C)
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  reflect
    (pred_of_set A \subset pred_of_set B /\
     [disjoint pred_of_set A & pred_of_set C])
    (pred_of_set A \subset B :\: C)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  (A :|: B == set0) = (A == set0) && (B == set0)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  (A :\: B == set0) = (pred_of_set A \subset pred_of_set B)
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  (A :&: B == set0) = [disjoint pred_of_set A & pred_of_set B]
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  [disjoint pred_of_set A & pred_of_set B] -> A :&: B = set0
1 subgoal
  
  T : finType
  A, B : {set T}
  x : T
  ============================
  (pred_of_set A \subset B :\ x) =
  (pred_of_set A \subset pred_of_set B) && (x \notin pred_of_set A)
1 subgoal
  
  T : finType
  A, B : {set T}
  x : T
  ============================
  reflect (pred_of_set A \subset pred_of_set B /\ x \notin pred_of_set A)
    (pred_of_set A \subset B :\ x)
1 subgoal
  
  T : finType
  A : {set T}
  x : T
  ============================
  x \in pred_of_set A -> A :\ x \proper pred_of_set A
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  ~~ (pred_of_set B \subset pred_of_set A) -> A :&: B \proper pred_of_set B
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  ~~ (pred_of_set A \subset pred_of_set B) -> A :&: B \proper pred_of_set A
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  ~~ (pred_of_set A \subset pred_of_set B) -> pred_of_set B \proper A :|: B
1 subgoal
  
  T : finType
  A, B : {set T}
  ============================
  ~~ (pred_of_set B \subset pred_of_set A) -> pred_of_set A \proper A :|: B
1 subgoal
  
  T : finType
  A : {set T}
  x : T
  ============================
  [set x] \proper pred_of_set A -> x \in pred_of_set A
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  (pred_of_set B \proper pred_of_set A)
  || (pred_of_set C \proper pred_of_set A) -> B :&: C \proper pred_of_set A
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  pred_of_set A \proper B :&: C ->
  (pred_of_set A \proper pred_of_set B) &&
  (pred_of_set A \proper pred_of_set C)
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  B :|: C \proper pred_of_set A ->
  (pred_of_set B \proper pred_of_set A) &&
  (pred_of_set C \proper pred_of_set A)
1 subgoal
  
  T : finType
  A, B, C : {set T}
  ============================
  pred_of_set A \proper B :\: C ->
  (pred_of_set A \proper pred_of_set B) &&
  [disjoint pred_of_set A & pred_of_set C]
1 subgoal
  
  fT1, fT2 : finType
  A1 : {set fT1}
  A2 : {set fT2}
  x1 : fT1
  x2 : fT2
  ============================
  ((x1, x2) \in pred_of_set setX) =
  (x1 \in pred_of_set A1) && (x2 \in pred_of_set A2)
1 subgoal
  
  fT1, fT2 : finType
  A1 : {set fT1}
  A2 : {set fT2}
  x1 : fT1
  x2 : fT2
  ============================
  reflect (x1 \in pred_of_set A1 /\ x2 \in pred_of_set A2)
    ((x1, x2) \in pred_of_set setX)
1 subgoal
  
  fT1, fT2 : finType
  A1 : {set fT1}
  A2 : {set fT2}
  ============================
  #|pred_of_set setX| = #|pred_of_set A1| * #|pred_of_set A2|
1 subgoal
  
  ============================
  imset =
  (fun (aT rT : finType) (f : aT -> rT) (mD : mem_pred aT) =>
   [set y in image_mem f mD])
1 subgoal
  
  ============================
  imset2 =
  (fun (aT1 aT2 rT : finType) (f : aT1 -> aT2 -> rT) 
     (D1 : mem_pred aT1) (D2 : aT1 -> mem_pred aT2) =>
   [set y in image (prod_curry f) [pred u | D1 u.1 & (D2 u.1) u.2]])
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  D : mem_pred aT
  y : rT
  ============================
  reflect (exists2 x : aT, in_mem x D & y = f x) (y \in imset f D)
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  D1 : mem_pred aT
  D2 : aT -> mem_pred aT2
  y : rT
  ============================
  reflect (imset2_spec D1 D2 y) (y \in imset2 f2 D1 D2)
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  D : pred aT
  x : aT
  ============================
  x \in D -> f x \in [set f x | x in D]
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  ============================
  [set f x | x in pred_of_set set0] = set0
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  A : {set aT}
  ============================
  ([set f x | x in pred_of_set A] == set0) = (A == set0)
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  x : aT
  ============================
  [set f x | x in [set x]] = [set f x]
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  D : pred aT
  D2 : aT -> pred aT2
  x : aT
  x2 : aT2
  ============================
  x \in D -> x2 \in D2 x -> f2 x x2 \in [set f2 x y | x in D, y in D2 x]
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  A : pred aT
  B : pred rT
  ============================
  ([set f x | x in A] \subset B) = (A \subset f @^-1: B)
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  A, B : pred rT
  ============================
  A \subset B -> f @^-1: A \subset f @^-1: B
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  ============================
  f @^-1: pred_of_set set0 = set0
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  ============================
  f @^-1: [set: rT] = [set: aT]
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  A, B : {set rT}
  ============================
  f @^-1: (A :&: B) = f @^-1: pred_of_set A :&: f @^-1: pred_of_set B
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  A, B : {set rT}
  ============================
  f @^-1: (A :|: B) = f @^-1: pred_of_set A :|: f @^-1: pred_of_set B
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  A, B : {set rT}
  ============================
  f @^-1: (A :\: B) = f @^-1: pred_of_set A :\: f @^-1: pred_of_set B
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  A : {set rT}
  ============================
  f @^-1: (~: A) = ~: f @^-1: pred_of_set A
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  A, B : pred aT
  ============================
  A \subset B -> [set f x | x in A] \subset [set f x | x in B]
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  A, B : {set aT}
  ============================
  {in pred_of_set B &, injective f} ->
  pred_of_set A \proper pred_of_set B ->
  [set f x | x in pred_of_set A] \proper [set f x | x in pred_of_set B]
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  A, B : {set rT}
  ============================
  pred_of_set B \subset codom f ->
  pred_of_set A \proper pred_of_set B ->
  f @^-1: pred_of_set A \proper f @^-1: pred_of_set B
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  A, B : {set aT}
  ============================
  [set f x | x in A :|: B] =
  [set f x | x in pred_of_set A] :|: [set f x | x in pred_of_set B]
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  a : aT
  A : {set aT}
  ============================
  [set f x | x in a |: A] = f a |: [set f x | x in pred_of_set A]
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  A, B : {set aT}
  ============================
  {in pred_of_set A & pred_of_set B, injective f} ->
  [set f x | x in A :&: B] =
  [set f x | x in pred_of_set A] :&: [set f x | x in pred_of_set B]
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  A, B : pred aT
  C : pred aT2
  ============================
  A \subset B ->
  [set f2 x y | x in A, y in C] \subset [set f2 x y | x in B, y in C]
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  A, B : pred aT2
  C : pred aT
  ============================
  A \subset B ->
  [set f2 x y | x in C, y in A] \subset [set f2 x y | x in C, y in B]
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  f2 : aT -> aT2 -> rT
  A, B : pred aT
  A2, B2 : pred aT2
  ============================
  A \subset B ->
  A2 \subset B2 ->
  [set f2 x y | x in A, y in A2] \subset [set f2 x y | x in B, y in B2]
1 subgoal
  
  aT, aT2, rT : finType
  f, g : aT -> rT
  R : pred rT
  ============================
  f =1 g -> f @^-1: R = g @^-1: R
1 subgoal
  
  aT, aT2, rT : finType
  f, g : aT -> rT
  D : {set aT}
  ============================
  f =1 g -> [set f x | x in pred_of_set D] = [set g x | x in pred_of_set D]
1 subgoal
  
  aT, aT2, rT : finType
  f, g : aT -> rT
  D : {set aT}
  ============================
  {in pred_of_set D, f =1 g} ->
  [set f x | x in pred_of_set D] = [set g x | x in pred_of_set D]
1 subgoal
  
  aT, aT2, rT : finType
  f, g : aT -> aT2 -> rT
  D : pred aT
  D2 : pred aT2
  ============================
  {in D & D2, f =2 g} ->
  [set f x y | x in D, y in D2] = [set g x y | x in D, y in D2]
1 subgoal
  
  aT, aT2 : finType
  A : {set aT}
  B : {set aT2}
  ============================
  [set (x, y) | x in pred_of_set A, y in pred_of_set B] = setX A B
1 subgoal
  
  aT, aT2 : finType
  A1, B1 : {set aT}
  A2, B2 : {set aT2}
  ============================
  pred_of_set A1 \subset pred_of_set B1 ->
  pred_of_set A2 \subset pred_of_set B2 ->
  pred_of_set (setX A1 A2) \subset pred_of_set (setX B1 B2)
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law idx
  aop : Monoid.com_law idx
  I, J : finType
  F : I -> R
  ============================
  \big[op/idx]_(i in pred_of_set set0) F i = idx
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law idx
  aop : Monoid.com_law idx
  I, J : finType
  a : I
  F : I -> R
  ============================
  \big[op/idx]_(i in [set a]) F i = F a
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law idx
  aop : Monoid.com_law idx
  I, J : finType
  A, B : {set I}
  P : pred I
  F : I -> R
  ============================
  \big[aop/idx]_(i in pred_of_set A | P i) F i =
  aop (\big[aop/idx]_(i in A :&: B | P i) F i)
    (\big[aop/idx]_(i in A :\: B | P i) F i)
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law idx
  aop : Monoid.com_law idx
  I, J : finType
  A, B : {set I}
  F : I -> R
  ============================
  \big[aop/idx]_(i in pred_of_set A) F i =
  aop (\big[aop/idx]_(i in A :&: B) F i) (\big[aop/idx]_(i in A :\: B) F i)
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law idx
  aop : Monoid.com_law idx
  I, J : finType
  a : I
  A : {set I}
  F : I -> R
  ============================
  a \in pred_of_set A ->
  \big[aop/idx]_(i in pred_of_set A) F i =
  aop (F a) (\big[aop/idx]_(i in A :\ a) F i)
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law idx
  aop : Monoid.com_law idx
  I, J : finType
  a : I
  A : {set I}
  F : I -> R
  ============================
  a \notin pred_of_set A ->
  \big[aop/idx]_(i in (a |: A)) F i =
  aop (F a) (\big[aop/idx]_(i in pred_of_set A) F i)
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law idx
  aop : Monoid.com_law idx
  I, J : finType
  h : I -> J
  A : pred I
  G : J -> R
  ============================
  {in A &, injective h} ->
  \big[aop/idx]_(j in [set h x | x in A]) G j =
  \big[aop/idx]_(i in A) G (h i)
1 subgoal
  
  R : Type
  idx : R
  op : Monoid.law idx
  aop : Monoid.com_law idx
  I, J : finType
  h : I -> J
  A : pred I
  F : I -> R
  ============================
  \big[aop/idx]_(i in A) F i =
  \big[aop/idx]_(j in [set h x | x in A])
     \big[aop/idx]_(i in A | h i == j) F i
1 subgoal
  
  aT1, aT2, rT : finType
  f : aT1 -> aT2 -> rT
  x1 : aT1
  D2 : pred aT2
  ============================
  [set f x y | x in [set x1], y in D2] = [set f x1 x | x in D2]
1 subgoal
  
  aT1, aT2, rT : finType
  f : aT1 -> aT2 -> rT
  x2 : aT2
  D1 : pred aT1
  ============================
  [set f x y | x in D1, y in [set x2]] = [set f x x2 | x in D1]
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  g : rT -> aT
  f2 : aT -> aT2 -> rT
  D, D2 : pred aT
  ============================
  #|[set f x | x in D]| = #|image f D|
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  g : rT -> aT
  f2 : aT -> aT2 -> rT
  D, D2 : pred aT
  ============================
  #|[set f x | x in D]| <= #|D|
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  g : rT -> aT
  f2 : aT -> aT2 -> rT
  D, D2 : pred aT
  ============================
  {in D &, injective f} -> #|[set f x | x in D]| = #|D|
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  g : rT -> aT
  f2 : aT -> aT2 -> rT
  D, D2 : pred aT
  ============================
  injective f -> #|[set f x | x in D]| = #|D|
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  g : rT -> aT
  f2 : aT -> aT2 -> rT
  D, D2 : pred aT
  ============================
  reflect {in D &, injective f} (#|[set f x | x in D]| == #|D|)
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  g : rT -> aT
  f2 : aT -> aT2 -> rT
  D, D2 : pred aT
  ============================
  {in D, cancel f g} ->
  {on D, cancel g & f} -> [set f x | x in D] = g @^-1: D
1 subgoal
  
  aT, aT2, rT : finType
  f : aT -> rT
  g : rT -> aT
  f2 : aT -> aT2 -> rT
  D, D2 : pred aT
  ============================
  cancel f g -> cancel g f -> [set f x | x in D] = g @^-1: D
1 subgoal
  
  aT, rT : finType
  f : aT -> rT
  R : pred rT
  ============================
  {on R, bijective f} -> #|f @^-1: R| = #|R|
1 subgoal
  
  T : finType
  f, g : T -> T
  A : {set T}
  ============================
  cancel f g -> [set f x | x in pred_of_set A] = g @^-1: pred_of_set A
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  [set x | x in pred_of_set A] = A
1 subgoal
  
  T : finType
  f : T -> T
  A : {set T}
  ============================
  injective f -> #|f @^-1: pred_of_set A| = #|pred_of_set A|
1 subgoal
  
  T : finType
  A : {set T}
  ============================
  #|pred_of_set (powerset A)| = 2 ^ #|pred_of_set A|
1 subgoal
  
  T, T', U : finType
  f : T' -> U
  g : T -> T'
  H : pred T
  ============================
  [set (f \o g) x | x in H] = [set f x | x in [set g x | x in H]]
1 subgoal
  
  T, I : finType
  j : I
  P : pred I
  F : I -> {set T}
  ============================
  P j -> pred_of_set (F j) \subset \bigcup_(i | P i) F i
1 subgoal
  
  T, I : finType
  j : I
  U : pred T
  P : pred I
  F : I -> {set T}
  ============================
  P j -> U \subset pred_of_set (F j) -> U \subset \bigcup_(i | P i) F i
1 subgoal
  
  T, I : finType
  x : T
  P : pred I
  F : I -> {set T}
  ============================
  reflect (exists2 i : I, P i & x \in pred_of_set (F i))
    (x \in \bigcup_(i | P i) F i)
1 subgoal
  
  T, I : finType
  U : pred T
  P : pred I
  F : I -> {set T}
  ============================
  reflect (forall i : I, P i -> pred_of_set (F i) \subset U)
    (\bigcup_(i | P i) F i \subset U)
1 subgoal
  
  T, I : finType
  U : pred T
  P : pred I
  F : I -> {set T}
  ============================
  (forall i : I, P i -> [disjoint U & pred_of_set (F i)]) ->
  [disjoint U & \bigcup_(i | P i) F i]
1 subgoal
  
  T, I : finType
  A, B : {set I}
  F : I -> {set T}
  ============================
  \bigcup_(i in (A :|: B)) F i =
  \bigcup_(i in pred_of_set A) F i :|: \bigcup_(i in pred_of_set B) F i
1 subgoal
  
  T, I : finType
  r : seq I
  F : I -> {set T}
  ============================
  \bigcup_(i <- r) F i = \bigcup_(i in r) F i
1 subgoal
  
  T, I : finType
  j : I
  P : pred I
  F : I -> {set T}
  ============================
  P j -> \bigcap_(i | P i) F i \subset pred_of_set (F j)
1 subgoal
  
  T, I : finType
  j : I
  U : pred T
  P : pred I
  F : I -> {set T}
  ============================
  P j -> pred_of_set (F j) \subset U -> \bigcap_(i | P i) F i \subset U
1 subgoal
  
  T, I : finType
  U : pred T
  P : pred I
  F : I -> {set T}
  ============================
  reflect (forall i : I, P i -> U \subset pred_of_set (F i))
    (U \subset \bigcap_(i | P i) F i)
1 subgoal
  
  T, I : finType
  x : T
  P : pred I
  F : I -> {set T}
  ============================
  reflect (forall i : I, P i -> x \in pred_of_set (F i))
    (x \in \bigcap_(i | P i) F i)
1 subgoal
  
  T, I : finType
  J : Type
  r : seq J
  P : pred J
  F : J -> {set T}
  ============================
  ~: (\bigcup_(j <- r | P j) F j) = \bigcap_(j <- r | P j) ~: F j
1 subgoal
  
  T, I : finType
  J : Type
  r : seq J
  P : pred J
  F : J -> {set T}
  ============================
  ~: (\bigcap_(j <- r | P j) F j) = \bigcup_(j <- r | P j) ~: F j
1 subgoal
  
  T, I : finType
  A, B : {set I}
  F : I -> {set T}
  ============================
  \bigcap_(i in (A :|: B)) F i =
  \bigcap_(i in pred_of_set A) F i :&: \bigcap_(i in pred_of_set B) F i
1 subgoal
  
  T, I : finType
  r : seq I
  F : I -> {set T}
  ============================
  \bigcap_(i <- r) F i = \bigcap_(i in r) F i
1 subgoal
  
  aT1, aT2, rT : finType
  f : aT1 -> aT2 -> rT
  A1 : {set aT1}
  A2 : {set aT2}
  D1 : pred aT1
  D2 : pred aT2
  ============================
  [set f x y | x in pred_of_set A1, y in pred_of_set A2] =
  [set prod_curry f x | x in pred_of_set (setX A1 A2)]
1 subgoal
  
  aT1, aT2, rT : finType
  f : aT1 -> aT2 -> rT
  A1 : {set aT1}
  A2 : {set aT2}
  D1 : pred aT1
  D2 : pred aT2
  ============================
  [set f x y | x in D1, y in D2] = \bigcup_(x1 in D1) [set f x1 x | x in D2]
1 subgoal
  
  aT1, aT2, rT : finType
  f : aT1 -> aT2 -> rT
  A1 : {set aT1}
  A2 : {set aT2}
  D1 : pred aT1
  D2 : pred aT2
  ============================
  [set f x y | x in D1, y in D2] = \bigcup_(x2 in D2) [set f x x2 | x in D1]
1 subgoal
  
  aT1, aT2, rT : finType
  f : aT1 -> aT2 -> rT
  A, B : {set aT1}
  C : {set aT2}
  ============================
  [set f x y | x in A :|: B, y in pred_of_set C] =
  [set f x y | x in pred_of_set A, y in pred_of_set C]
  :|: [set f x y | x in pred_of_set B, y in pred_of_set C]
1 subgoal
  
  aT1, aT2, rT : finType
  f : aT1 -> aT2 -> rT
  A : {set aT1}
  B, C : {set aT2}
  ============================
  [set f x y | x in pred_of_set A, y in B :|: C] =
  [set f x y | x in pred_of_set A, y in pred_of_set B]
  :|: [set f x y | x in pred_of_set A, y in pred_of_set C]
1 subgoal
  
  T, I : finType
  A, B : {set T}
  ============================
  #|A :|: B| <= #|pred_of_set A| + #|pred_of_set B|
             ?= iff [disjoint pred_of_set A & pred_of_set B]
1 subgoal
  
  T, I : finType
  P : {set {set T}}
  ============================
  #|pred_of_set (cover P)| <= \sum_(A in pred_of_set P) #|pred_of_set A|
                           ?= iff trivIset P
1 subgoal
  
  T, I : finType
  P : {set {set T}}
  ============================
  reflect
    {in pred_of_set P &, forall A B : {set T},
                         A != B -> [disjoint pred_of_set A & pred_of_set B]}
    (trivIset P)
1 subgoal
  
  T, I : finType
  P, Q : {set {set T}}
  ============================
  pred_of_set P \subset pred_of_set Q -> trivIset Q -> trivIset P
1 subgoal
  
  T, I : finType
  P : {set {set T}}
  D : {set T}
  ============================
  trivIset P -> trivIset (P ::&: D)
1 subgoal
  
  T, I : finType
  P : {set {set T}}
  D : {set T}
  ============================
  pred_of_set (cover (P ::&: D)) \subset cover P :&: D
1 subgoal
  
  T, I : finType
  P : {set {set T}}
  x : T
  ============================
  (x \in pred_of_set (pblock P x)) = (x \in pred_of_set (cover P))
1 subgoal
  
  T, I : finType
  P : {set {set T}}
  x : T
  ============================
  x \in pred_of_set (cover P) -> pblock P x \in pred_of_set P
1 subgoal
  
  T, I : finType
  P : {set {set T}}
  B : {set T}
  x : T
  ============================
  trivIset P -> B \in pred_of_set P -> x \in pred_of_set B -> pblock P x = B
1 subgoal
  
  T, I : finType
  P : {set {set T}}
  x, y : T
  ============================
  trivIset P -> x \in pred_of_set (pblock P y) -> pblock P x = pblock P y
1 subgoal
  
  T, I : finType
  P : {set {set T}}
  x, y : T
  ============================
  trivIset P ->
  x \in pred_of_set (cover P) ->
  (pblock P x == pblock P y) = (y \in pred_of_set (pblock P x))
1 subgoal
  
  T, I : finType
  A : {set T}
  P : {set {set T}}
  ============================
  {in pred_of_set P, forall B : {set T},
                     [disjoint pred_of_set A & pred_of_set B]} ->
  trivIset P ->
  set0 \notin pred_of_set P -> trivIset (A |: P) /\ A \notin pred_of_set P
1 subgoal
  
  T, I : finType
  J : pred I
  F : I -> {set T}
  ============================
  cover [set F x | x in J] = \bigcup_(i in J) F i
1 subgoal
  
  T, I : finType
  J : pred I
  F : I -> {set T}
  P := [set F x | x in J] : {set set_of_finType T}
  ============================
  {in J &, forall i j : I,
           j != i -> [disjoint pred_of_set (F i) & pred_of_set (F j)]} ->
  set0 \notin pred_of_set P -> trivIset P /\ {in J &, injective F}
1 subgoal
  
  T, I : finType
  P : {set {set T}}
  D : {set T}
  ============================
  partition P D -> cover P = D
1 subgoal
  
  T, I : finType
  P : {set {set T}}
  D : {set T}
  ============================
  partition P D ->
  #|pred_of_set D| = \big[addn/0]_(A in pred_of_set P) #|pred_of_set A|
1 subgoal
  
  T, I : finType
  n : nat
  P : {set {set T}}
  D : {set T}
  ============================
  {in pred_of_set P, forall A : {set T}, #|pred_of_set A| = n} ->
  partition P D -> #|pred_of_set D| = #|pred_of_set P| * n
1 subgoal
  
  T, I : finType
  R : Type
  idx : R
  op : Monoid.com_law idx
  rhs_cond := fun (P : {set {set T}}) (K : T -> bool) (E : T -> R) =>
              \big[op/idx]_(A in pred_of_set P)
                 \big[op/idx]_(x in pred_of_set A | K x) E x
   : {set {set T}} -> (T -> bool) -> (T -> R) -> R
  rhs := fun (P : {set {set T}}) (E : T -> R) =>
         \big[op/idx]_(A in pred_of_set P)
            \big[op/idx]_(x in pred_of_set A) E x
   : {set {set T}} -> (T -> R) -> R
  P : {set {set T}}
  K : pred T
  E : T -> R
  ============================
  trivIset P ->
  \big[op/idx]_(x in pred_of_set (cover P) | K x) E x = rhs_cond P K E
1 subgoal
  
  T, I : finType
  R : Type
  idx : R
  op : Monoid.com_law idx
  rhs_cond := fun (P : {set {set T}}) (K : T -> bool) (E : T -> R) =>
              \big[op/idx]_(A in pred_of_set P)
                 \big[op/idx]_(x in pred_of_set A | K x) E x
   : {set {set T}} -> (T -> bool) -> (T -> R) -> R
  rhs := fun (P : {set {set T}}) (E : T -> R) =>
         \big[op/idx]_(A in pred_of_set P)
            \big[op/idx]_(x in pred_of_set A) E x
   : {set {set T}} -> (T -> R) -> R
  P : {set {set T}}
  E : T -> R
  ============================
  trivIset P -> \big[op/idx]_(x in pred_of_set (cover P)) E x = rhs P E
1 subgoal
  
  T, I : finType
  R : Type
  idx : R
  op : Monoid.com_law idx
  rhs_cond := fun (P : {set {set T}}) (K : T -> bool) (E : T -> R) =>
              \big[op/idx]_(A in pred_of_set P)
                 \big[op/idx]_(x in pred_of_set A | K x) E x
   : {set {set T}} -> (T -> bool) -> (T -> R) -> R
  rhs := fun (P : {set {set T}}) (E : T -> R) =>
         \big[op/idx]_(A in pred_of_set P)
            \big[op/idx]_(x in pred_of_set A) E x
   : {set {set T}} -> (T -> R) -> R
  P : {set {set T}}
  D : {set T}
  K : pred T
  E : T -> R
  ============================
  partition P D ->
  \big[op/idx]_(x in pred_of_set D | K x) E x = rhs_cond P K E
1 subgoal
  
  T, I : finType
  R : Type
  idx : R
  op : Monoid.com_law idx
  rhs_cond := fun (P : {set {set T}}) (K : T -> bool) (E : T -> R) =>
              \big[op/idx]_(A in pred_of_set P)
                 \big[op/idx]_(x in pred_of_set A | K x) E x
   : {set {set T}} -> (T -> bool) -> (T -> R) -> R
  rhs := fun (P : {set {set T}}) (E : T -> R) =>
         \big[op/idx]_(A in pred_of_set P)
            \big[op/idx]_(x in pred_of_set A) E x
   : {set {set T}} -> (T -> R) -> R
  P : {set {set T}}
  D : {set T}
  E : T -> R
  ============================
  partition P D -> \big[op/idx]_(x in pred_of_set D) E x = rhs P E
1 subgoal
  
  T, I : finType
  R : Type
  idx : R
  op : Monoid.com_law idx
  rhs_cond := fun (P : {set {set T}}) (K : T -> bool) (E : T -> R) =>
              \big[op/idx]_(A in pred_of_set P)
                 \big[op/idx]_(x in pred_of_set A | K x) E x
   : {set {set T}} -> (T -> bool) -> (T -> R) -> R
  rhs := fun (P : {set {set T}}) (E : T -> R) =>
         \big[op/idx]_(A in pred_of_set P)
            \big[op/idx]_(x in pred_of_set A) E x
   : {set {set T}} -> (T -> R) -> R
  F : I -> {set T}
  E : T -> R
  ============================
  (forall i j : I, i != j -> [disjoint pred_of_set (F i) & pred_of_set (F j)]) ->
  \big[op/idx]_(x in \bigcup_i F i) E x =
  \big[op/idx]_i \big[op/idx]_(x in pred_of_set (F i)) E x
1 subgoal
  
  T, I : finType
  R : rel T
  D : {set T}
  Px := fun x : T => [set y in pred_of_set D | R x y] : T -> {set T}
  eqiR : {in pred_of_set D & &, equivalence_rel R}
  x : T
  ============================
  x \in pred_of_set D -> x \in pred_of_set (Px x)
1 subgoal
  
  T, I : finType
  R : rel T
  D : {set T}
  Px := fun x : T => [set y in pred_of_set D | R x y] : T -> {set T}
  eqiR : {in pred_of_set D & &, equivalence_rel R}
  Pxx : forall x : T, x \in pred_of_set D -> x \in pred_of_set (Px x)
  PPx := fun x : T => [eta mem_imset Px (x:=x)]
   : forall x : T, x \in pred_of_set D -> Px x \in P
  ============================
  partition P D
1 subgoal
  
  T, I : finType
  R : rel T
  D : {set T}
  Px := fun x : T => [set y in pred_of_set D | R x y] : T -> {set T}
  eqiR : {in pred_of_set D & &, equivalence_rel R}
  Pxx : forall x : T, x \in pred_of_set D -> x \in pred_of_set (Px x)
  PPx := fun x : T => [eta mem_imset Px (x:=x)]
   : forall x : T, x \in pred_of_set D -> Px x \in P
  ============================
  {in pred_of_set D &, forall x y : T,
                       (y \in pred_of_set (pblock P x)) = R x y}
1 subgoal
  
  T, I : finType
  P : {set {set T}}
  D : {set T}
  ============================
  partition P D ->
  {in pred_of_set D & &, equivalence_rel
                           (fun x : T =>
                            (in_mem (T:=T))^~ (mem (pred_of_set (pblock P x))))}
1 subgoal
  
  T, I : finType
  P : {set {set T}}
  D : {set T}
  ============================
  partition P D ->
  equivalence_partition
    (fun x : T => (in_mem (T:=T))^~ (mem (pred_of_set (pblock P x)))) D = P
1 subgoal
  
  T, I : finType
  rT : eqType
  f : T -> rT
  D : {set T}
  ============================
  partition (preim_partition D) D
1 subgoal
  
  T, I : finType
  P : {set {set T}}
  D : {set T}
  ============================
  partition P D -> preim_partition (pblock P) D = P
1 subgoal
  
  T, I : finType
  P : {set {set T}}
  D : {set T}
  ============================
  partition P D -> is_transversal (transversal P D) P D
1 subgoal
  
  T, I : finType
  X : {set T}
  P : {set {set T}}
  D : {set T}
  trPX : is_transversal X P D
  ============================
  pred_of_set X \subset pred_of_set D
1 subgoal
  
  T, I : finType
  X : {set T}
  P : {set {set T}}
  D : {set T}
  trPX : is_transversal X P D
  ============================
  trivIset P
1 subgoal
  
  T, I : finType
  X : {set T}
  P : {set {set T}}
  D : {set T}
  trPX : is_transversal X P D
  tiP : trivIset P
  ============================
  {subset pred_of_set X <= pred_of_set (cover P)}
1 subgoal
  
  T, I : finType
  X : {set T}
  P : {set {set T}}
  D : {set T}
  trPX : is_transversal X P D
  tiP : trivIset P
  sXP : {subset pred_of_set X <= pred_of_set (cover P)}
  ============================
  {in pred_of_set P, forall B : {set T}, #|X :&: B| == 1}
1 subgoal
  
  T, I : finType
  X : {set T}
  P : {set {set T}}
  D : {set T}
  trPX : is_transversal X P D
  tiP : trivIset P
  sXP : {subset pred_of_set X <= pred_of_set (cover P)}
  trX : {in pred_of_set P, forall B : {set T}, #|X :&: B| == 1}
  x0 : T
  B : {set T}
  ============================
  B \in pred_of_set P -> X :&: B = [set transversal_repr x0 X B]
1 subgoal
  
  T, I : finType
  X : {set T}
  P : {set {set T}}
  D : {set T}
  trPX : is_transversal X P D
  tiP : trivIset P
  sXP : {subset pred_of_set X <= pred_of_set (cover P)}
  trX : {in pred_of_set P, forall B : {set T}, #|X :&: B| == 1}
  x0 : T
  B : {set T}
  ============================
  B \in pred_of_set P -> transversal_repr x0 X B \in pred_of_set B
1 subgoal
  
  T, I : finType
  X : {set T}
  P : {set {set T}}
  D : {set T}
  trPX : is_transversal X P D
  tiP : trivIset P
  sXP : {subset pred_of_set X <= pred_of_set (cover P)}
  trX : {in pred_of_set P, forall B : {set T}, #|X :&: B| == 1}
  x0 : T
  B : {set T}
  ============================
  B \in pred_of_set P -> transversal_repr x0 X B \in pred_of_set X
1 subgoal
  
  T, I : finType
  X : {set T}
  P : {set {set T}}
  D : {set T}
  trPX : is_transversal X P D
  tiP : trivIset P
  sXP : {subset pred_of_set X <= pred_of_set (cover P)}
  trX : {in pred_of_set P, forall B : {set T}, #|X :&: B| == 1}
  x0 : T
  ============================
  {in pred_of_set P, cancel (transversal_repr x0 X) (pblock P)}
1 subgoal
  
  T, I : finType
  X : {set T}
  P : {set {set T}}
  D : {set T}
  trPX : is_transversal X P D
  tiP : trivIset P
  sXP : {subset pred_of_set X <= pred_of_set (cover P)}
  trX : {in pred_of_set P, forall B : {set T}, #|X :&: B| == 1}
  x0 : T
  ============================
  {in pred_of_set X, cancel (pblock P) (transversal_repr x0 X)}
1 subgoal
  
  T, I : finType
  X : {set T}
  P : {set {set T}}
  D : {set T}
  trPX : is_transversal X P D
  tiP : trivIset P
  sXP : {subset pred_of_set X <= pred_of_set (cover P)}
  trX : {in pred_of_set P, forall B : {set T}, #|X :&: B| == 1}
  ============================
  {in pred_of_set X &, injective (pblock P)}
1 subgoal
  
  T, I : finType
  X : {set T}
  P : {set {set T}}
  D : {set T}
  trPX : is_transversal X P D
  tiP : trivIset P
  sXP : {subset pred_of_set X <= pred_of_set (cover P)}
  trX : {in pred_of_set P, forall B : {set T}, #|X :&: B| == 1}
  ============================
  [set pblock P x | x in pred_of_set X] = P
1 subgoal
  
  T, I : finType
  X : {set T}
  P : {set {set T}}
  D : {set T}
  trPX : is_transversal X P D
  tiP : trivIset P
  sXP : {subset pred_of_set X <= pred_of_set (cover P)}
  trX : {in pred_of_set P, forall B : {set T}, #|X :&: B| == 1}
  ============================
  #|pred_of_set X| = #|pred_of_set P|
1 subgoal
  
  T, I : finType
  X : {set T}
  P : {set {set T}}
  D : {set T}
  trPX : is_transversal X P D
  tiP : trivIset P
  sXP : {subset pred_of_set X <= pred_of_set (cover P)}
  trX : {in pred_of_set P, forall B : {set T}, #|X :&: B| == 1}
  x0 : T
  ============================
  [set transversal_repr x0 X x | x in pred_of_set P] = X
1 subgoal
  
  T : finType
  D : {set T}
  P : {set {set T}}
  Q : {set {set set_of_finType T}}
  ============================
  partition P D ->
  partition Q P ->
  partition [set cover x | x in pred_of_set Q] D /\
  {in pred_of_set Q &, injective cover}
1 subgoal
  
  T : finType
  P1, P2 : pred {set T}
  A : {set T}
  ============================
  P1 =1 P2 -> minset P1 A = minset P2 A
1 subgoal
  
  T : finType
  P : pred {set T}
  A : {set T}
  ============================
  reflect
    (P A /\
     (forall B : {set T}, P B -> pred_of_set B \subset pred_of_set A -> B = A))
    (minset P A)
1 subgoal
  
  T : finType
  P : pred {set T}
  A : {set T}
  ============================
  minset P A -> P A
1 subgoal
  
  T : finType
  P : pred {set T}
  A, B : {set T}
  ============================
  minset P A -> P B -> pred_of_set B \subset pred_of_set A -> B = A
1 subgoal
  
  T : finType
  P : pred {set T}
  ============================
  (exists A : {set T}, P A) -> {A : {set T} | minset P A}
1 subgoal
  
  T : finType
  P : pred {set T}
  C : {set T}
  ============================
  P C -> {A : {set T} | minset P A & pred_of_set A \subset pred_of_set C}
1 subgoal
  
  T : finType
  ============================
  unit
1 subgoal
  
  T : finType
  P1, P2 : pred {set T}
  A : {set T}
  ============================
  P1 =1 P2 -> maxset P1 A = maxset P2 A
1 subgoal
  
  T : finType
  P : pred {set T}
  A : {set T}
  ============================
  maxset P A = minset [pred B | P (~: B)] (~: A)
1 subgoal
  
  T : finType
  P : pred {set T}
  A : {set T}
  ============================
  minset P A = maxset [pred B | P (~: B)] (~: A)
1 subgoal
  
  T : finType
  P : pred {set T}
  A : {set T}
  ============================
  reflect
    (P A /\
     (forall B : {set T}, P B -> pred_of_set A \subset pred_of_set B -> B = A))
    (maxset P A)
1 subgoal
  
  T : finType
  P : pred {set T}
  A : {set T}
  ============================
  maxset P A -> P A
1 subgoal
  
  T : finType
  P : pred {set T}
  A, B : {set T}
  ============================
  maxset P A -> P B -> pred_of_set A \subset pred_of_set B -> B = A
1 subgoal
  
  T : finType
  P : pred {set T}
  ============================
  (exists A : {set T}, P A) -> {A : {set T} | maxset P A}
1 subgoal
  
  T : finType
  P : pred {set T}
  C : {set T}
  ============================
  P C -> {A : {set T} | maxset P A & pred_of_set C \subset pred_of_set A}
COQC binomial.v
1 subgoal
  
  m, n : nat
  ============================
  0 < m -> m < n -> m`! < n`!
1 subgoal
  
  n : nat
  ============================
  n`! = \big[muln/1]_(1 <= i < n.+1) i
1 subgoal
  
  p, n : nat
  ============================
  prime p -> logn p n`! = \big[addn/0]_(1 <= k < n.+1) (n %/ p ^ k)
1 subgoal
  
  p : nat
  ============================
  1 < p -> prime p = (p %| (p.-1)`!.+1)
1 subgoal
  
  ============================
  falling_factorial = ffact_rec
1 subgoal
  
  n : nat
  ============================
  n ^_ 0 = 1
1 subgoal
  
  m : nat
  ============================
  0 ^_ m = (m == 0)
1 subgoal
  
  n, m : nat
  ============================
  n ^_ m.+1 = n * n.-1 ^_ m
1 subgoal
  
  n, m : nat
  ============================
  n.+1 ^_ m.+1 = n.+1 * n ^_ m
1 subgoal
  
  n : nat
  ============================
  n ^_ 1 = n
1 subgoal
  
  n, m : nat
  ============================
  n ^_ m.+1 = n ^_ m * (n - m)
1 subgoal
  
  n, m : nat
  ============================
  (0 < n ^_ m) = (m <= n)
1 subgoal
  
  n, m : nat
  ============================
  n < m -> n ^_ m = 0
1 subgoal
  
  n : nat
  ============================
  n ^_ n = n`!
1 subgoal
  
  n, m : nat
  ============================
  m <= n -> n ^_ m * (n - m)`! = n`!
1 subgoal
  
  n, m : nat
  ============================
  m <= n -> n ^_ m = n`! %/ (n - m)`!
1 subgoal
  
  ============================
  binomial = binomial_rec
1 subgoal
  
  n : nat
  ============================
  'C(n, 0) = 1
1 subgoal
  
  m : nat
  ============================
  'C(0, m) = (m == 0)
1 subgoal
  
  n, m : nat
  ============================
  'C(n.+1, m.+1) = 'C(n, m.+1) + 'C(n, m)
1 subgoal
  
  n : nat
  ============================
  'C(n, 1) = n
1 subgoal
  
  n, m : nat
  ============================
  (0 < 'C(n, m)) = (m <= n)
1 subgoal
  
  n1, n2, m : nat
  ============================
  n1 <= n2 -> 'C(n1, m) <= 'C(n2, m)
1 subgoal
  
  n, m : nat
  ============================
  n < m -> 'C(n, m) = 0
1 subgoal
  
  n : nat
  ============================
  'C(n, n) = 1
1 subgoal
  
  n, m : nat
  ============================
  n * 'C(n.-1, m) = m.+1 * 'C(n, m.+1)
1 subgoal
  
  n, m : nat
  ============================
  m <= n -> 'C(n, m) * (m`! * (n - m)`!) = n`!
1 subgoal
  
  n, m : nat
  ============================
  0 < n -> 'C(n, m) = n`! %/ (m`! * (n - m)`!)
1 subgoal
  
  n, m : nat
  ============================
  'C(n, m) * m`! = n ^_ m
1 subgoal
  
  n, m : nat
  ============================
  'C(n, m) = n ^_ m %/ m`!
1 subgoal
  
  n, m : nat
  ============================
  m <= n -> 'C(n, n - m) = 'C(n, m)
1 subgoal
  
  n, m : nat
  ============================
  n * 'C(n.-1, m) = (n - m) * 'C(n, m)
1 subgoal
  
  n, m : nat
  ============================
  m.+1 * 'C(n, m.+1) = (n - m) * 'C(n, m)
1 subgoal
  
  n : nat
  ============================
  'C(n.+1, n) = n.+1
1 subgoal
  
  n : nat
  ============================
  'C(n, 2) = (n * n.-1)./2
1 subgoal
  
  n : nat
  ============================
  odd n -> 'C(n, 2) = n * (n.-1)./2
1 subgoal
  
  k, p : nat
  ============================
  prime p -> (0 < k) && (k < p) -> p %| 'C(p, k)
1 subgoal
  
  n : nat
  ============================
  \big[addn/0]_(0 <= i < n) i = 'C(n, 2)
1 subgoal
  
  n : nat
  ============================
  \big[addn/0]_(0 <= i < n) i = 'C(n, 2)
1 subgoal
  
  a, b, n : nat
  ============================
  (a + b) ^ n = \big[addn/0]_(i < n.+1) ('C(n, i) * (a ^ (n - i) * b ^ i))
1 subgoal
  
  k, l, i : nat
  ============================
  \big[addn/0]_(j < i.+1) ('C(k, j) * 'C(l, i - j)) = 'C(k + l, i)
1 subgoal
  
  m, n, k : nat
  ============================
  m ^ k - n ^ k = (m - n) * (\sum_(i < k) m ^ (k.-1 - i) * n ^ i)
1 subgoal
  
  m, k : nat
  ============================
  (m ^ k).-1 = m.-1 * (\sum_(i < k) m ^ i)
1 subgoal
  
  n, e : nat
  ============================
  n.-1 %| (n ^ e).-1
1 subgoal
  
  I : Type
  r : seq I
  P : pred I
  F : I -> nat
  d : nat
  ============================
  \sum_(i <- r | P i) F i %% d = \sum_(i <- r | P i) F i %[mod d]
1 subgoal
  
  T : finType
  n : nat
  A : pred T
  ============================
  #|[set t | all A t & uniq t]| = #|A| ^_ n
1 subgoal
  
  D, T : finType
  R : pred T
  ============================
  #|[set f in ffun_on R | injectiveb (fun_of_fin f)]| = #|R| ^_ #|D|
1 subgoal
  
  D, T : finType
  ============================
  #|[set f | injectiveb (fun_of_fin f)]| = #|T| ^_ #|D|
1 subgoal
  
  T : finType
  B : {set T}
  k : nat_eqType
  ============================
  #|[set A | pred_of_set A \subset pred_of_set B & 
  #|pred_of_set A| == k]| = 'C(#|pred_of_set B|, k)
1 subgoal
  
  T : finType
  k : nat_eqType
  ============================
  #|[set A | #|pred_of_set A| == k]| = 'C(#|T|, k)
1 subgoal
  
  m, n : nat
  ============================
  #|[set t | sorted ltn [seq val i | i <- t]]| = 'C(n, m)
1 subgoal
  
  m, n : nat
  ============================
  #|[set t | sorted leq [seq val i | i <- t]]| = 'C(m + n, m)
1 subgoal
  
  m, n : nat
  ============================
  #|[set t | \sum_(i <- t) i <= n]| = 'C(m + n, m)
1 subgoal
  
  m, n : nat
  ============================
  #|[set t | \big[addn/0]_(i <- t) i == n]| = 'C(m + n, m)
COQC generic_quotient.v
1 subgoal
  
  T : Type
  qT : quotType
  ============================
  cancel repr_of (pi_phant (Phant qT))
1 subgoal
  
  T : Type
  qT : quotType T
  ============================
  cancel repr \pi_(qT)
1 subgoal
  
  T : Type
  qT : quotType T
  x : T
  ============================
  pi_spec x (repr (\pi_(qT) x))
1 subgoal
  
  T : Type
  qT : quotType T
  ============================
  \mpi =1 \pi_(qT)
1 subgoal
  
  T : Type
  qT : quotType T
  P : qT -> Type
  ============================
  (forall y : T, P (\pi_(qT) y)) -> forall x : qT, P x
1 subgoal
  
  T : Type
  qT : quotType T
  P : qT -> Type
  ============================
  (forall y : T, repr (\pi_(qT) y) = y -> P (\pi_(qT) y)) ->
  forall x : qT, P x
1 subgoal
  
  T : Type
  x : T
  m : equal_to x
  ============================
  equal_val m = x
1 subgoal
  
  T, U : Type
  qT : quotType T
  qU : quotType U
  f : T -> T
  g : T -> T -> T
  p : T -> U
  r : T -> T -> U
  fq : qT -> qT
  gq : qT -> qT -> qT
  pq : qT -> U
  rq : qT -> qT -> U
  h : T -> U
  hq : qT -> qU
  pi_f : {morph \pi_(qT) : x / f x >-> fq x}
  pi_g : {morph \pi_(qT) : x y / g x y >-> gq x y}
  pi_p : {mono \pi_(qT) : x / p x >-> pq x}
  pi_r : {mono \pi_(qT) : x y / r x y >-> rq x y}
  pi_h : forall x : T, \pi_(qU) (h x) = hq (\pi_(qT) x)
  a, b : T
  x : equal_to (\pi_(qT) a)
  y : equal_to (\pi_(qT) b)
  ============================
  \pi_(qT) (f a) = fq (equal_val x)
1 subgoal
  
  T, U : Type
  qT : quotType T
  qU : quotType U
  f : T -> T
  g : T -> T -> T
  p : T -> U
  r : T -> T -> U
  fq : qT -> qT
  gq : qT -> qT -> qT
  pq : qT -> U
  rq : qT -> qT -> U
  h : T -> U
  hq : qT -> qU
  pi_f : {morph \pi_(qT) : x / f x >-> fq x}
  pi_g : {morph \pi_(qT) : x y / g x y >-> gq x y}
  pi_p : {mono \pi_(qT) : x / p x >-> pq x}
  pi_r : {mono \pi_(qT) : x y / r x y >-> rq x y}
  pi_h : forall x : T, \pi_(qU) (h x) = hq (\pi_(qT) x)
  a, b : T
  x : equal_to (\pi_(qT) a)
  y : equal_to (\pi_(qT) b)
  ============================
  \pi_(qT) (g a b) = gq (equal_val x) (equal_val y)
1 subgoal
  
  T, U : Type
  qT : quotType T
  qU : quotType U
  f : T -> T
  g : T -> T -> T
  p : T -> U
  r : T -> T -> U
  fq : qT -> qT
  gq : qT -> qT -> qT
  pq : qT -> U
  rq : qT -> qT -> U
  h : T -> U
  hq : qT -> qU
  pi_f : {morph \pi_(qT) : x / f x >-> fq x}
  pi_g : {morph \pi_(qT) : x y / g x y >-> gq x y}
  pi_p : {mono \pi_(qT) : x / p x >-> pq x}
  pi_r : {mono \pi_(qT) : x y / r x y >-> rq x y}
  pi_h : forall x : T, \pi_(qU) (h x) = hq (\pi_(qT) x)
  a, b : T
  x : equal_to (\pi_(qT) a)
  y : equal_to (\pi_(qT) b)
  ============================
  p a = pq (equal_val x)
1 subgoal
  
  T, U : Type
  qT : quotType T
  qU : quotType U
  f : T -> T
  g : T -> T -> T
  p : T -> U
  r : T -> T -> U
  fq : qT -> qT
  gq : qT -> qT -> qT
  pq : qT -> U
  rq : qT -> qT -> U
  h : T -> U
  hq : qT -> qU
  pi_f : {morph \pi_(qT) : x / f x >-> fq x}
  pi_g : {morph \pi_(qT) : x y / g x y >-> gq x y}
  pi_p : {mono \pi_(qT) : x / p x >-> pq x}
  pi_r : {mono \pi_(qT) : x y / r x y >-> rq x y}
  pi_h : forall x : T, \pi_(qU) (h x) = hq (\pi_(qT) x)
  a, b : T
  x : equal_to (\pi_(qT) a)
  y : equal_to (\pi_(qT) b)
  ============================
  r a b = rq (equal_val x) (equal_val y)
1 subgoal
  
  T, U : Type
  qT : quotType T
  qU : quotType U
  f : T -> T
  g : T -> T -> T
  p : T -> U
  r : T -> T -> U
  fq : qT -> qT
  gq : qT -> qT -> qT
  pq : qT -> U
  rq : qT -> qT -> U
  h : T -> U
  hq : qT -> qU
  pi_f : {morph \pi_(qT) : x / f x >-> fq x}
  pi_g : {morph \pi_(qT) : x y / g x y >-> gq x y}
  pi_p : {mono \pi_(qT) : x / p x >-> pq x}
  pi_r : {mono \pi_(qT) : x y / r x y >-> rq x y}
  pi_h : forall x : T, \pi_(qU) (h x) = hq (\pi_(qT) x)
  a, b : T
  x : equal_to (\pi_(qT) a)
  y : equal_to (\pi_(qT) b)
  ============================
  \pi_(qU) (h a) = hq (equal_val x)
1 subgoal
  
  T : Type
  T' : Type
  e : T -> T'
  ============================
  e =1 locked [eta e]
1 subgoal
  
  T : Type
  eq_quot_op : rel T
  eqT : eqQuotType
  ============================
  {mono \pi_(eqT) : x y / eq_quot_op x y >-> x == y}
1 subgoal
  
  T : eqType
  qT : quotType T
  x : T
  Px : repr (\pi_(qT) x) == x
  ============================
  repr (Sub Px) = x
1 subgoal
  
  T : eqType
  qT : quotType T
  x : qT
  ============================
  repr (\pi_(qT) (repr x)) == repr x
1 subgoal
  
  T : eqType
  qT : quotType T
  x : qT
  ============================
  x = Sub (sortPx x)
1 subgoal
  
  T : eqType
  qT : quotType T
  K : qT -> Type
  PK : forall (x : T) (Px : repr (\pi_(qT) x) == x), K (Sub Px)
  u : qT
  ============================
  K u
1 subgoal
  
  T : Type
  e : rel T
  ============================
  symmetric e -> transitive e -> left_transitive e
1 subgoal
  
  T : Type
  e : rel T
  ============================
  symmetric e -> transitive e -> right_transitive e
1 subgoal
  
  T : Type
  e : equiv_rel
  x : T
  ============================
  e x x
1 subgoal
  
  T : Type
  e : equiv_rel
  ============================
  symmetric e
1 subgoal
  
  T : Type
  e : equiv_rel
  ============================
  transitive e
1 subgoal
  
  T : Type
  e : equiv_rel
  T' : eqType
  ============================
  transitive eq_op
1 subgoal
  
  T : Type
  e : equiv_rel
  ============================
  left_transitive e
1 subgoal
  
  T : Type
  e : equiv_rel
  ============================
  right_transitive e
1 subgoal
  
  D, E : Type
  ED : E -> D
  DE : D -> E
  e : rel D
  r : encModRel
  x : D
  ============================
  r x x -> r (ED (DE x)) x
1 subgoal
  
  D, E : Type
  ED : E -> D
  DE : D -> E
  e : rel D
  r : encModRel
  ============================
  r =2 e
1 subgoal
  
  D, E : Type
  ED : E -> D
  DE : D -> E
  e : equiv_rel D
  r : encModRel ED DE e
  ============================
  equiv_class_of r
1 subgoal
  
  D, E : Type
  ED : E -> D
  DE : D -> E
  e : equiv_rel D
  r : encModRel ED DE e
  x : D
  ============================
  r (ED (DE x)) x
1 subgoal
  
  D, E : Type
  ED : E -> D
  DE : D -> E
  e : equiv_rel D
  r : encModRel ED DE e
  ============================
  e' =2 [rel x y | e (ED x) (ED y)]
1 subgoal
  
  D, E : Type
  ED : E -> D
  DE : D -> E
  e : equiv_rel D
  r : encModRel ED DE e
  ============================
  equiv_class_of e'
1 subgoal
  
  D, E : Type
  ED : E -> D
  DE : D -> E
  e : equiv_rel D
  r : encModRel ED DE e
  x : E
  ============================
  e' (DE (ED x)) x
1 subgoal
  
  D : Type
  C : choiceType
  CD : C -> D
  DC : D -> C
  eD : equiv_rel D
  encD : encModRel CD DC eD
  ============================
  forall x : C, (invariant canon canon) x
1 subgoal
  
  D : Type
  C : choiceType
  CD : C -> D
  DC : D -> C
  eD : equiv_rel D
  encD : encModRel CD DC eD
  ============================
  cancel erepr pi
1 subgoal
  
  D : Type
  C : choiceType
  CD : C -> D
  DC : D -> C
  eD : equiv_rel D
  encD : encModRel CD DC eD
  x, y : C
  ============================
  reflect (pi x = pi y) (eC x y)
1 subgoal
  
  D : Type
  C : choiceType
  CD : C -> D
  DC : D -> C
  eD : equiv_rel D
  encD : encModRel CD DC eD
  x, y : D
  ============================
  reflect (pi (DC x) = pi (DC y)) (eD x y)
1 subgoal
  
  D : Type
  C : choiceType
  CD : C -> D
  DC : D -> C
  eD : equiv_rel D
  encD : encModRel CD DC eD
  ============================
  cancel (CD \o erepr) (pi \o DC)
1 subgoal
  
  D : Type
  C : choiceType
  CD : C -> D
  DC : D -> C
  eD : equiv_rel D
  encD : encModRel CD DC eD
  x, y : D
  ============================
  reflect (x = y %[mod type_of (Phantom (rel D) encD)]) (eD x y)
1 subgoal
  
  D : Type
  C : choiceType
  CD : C -> D
  DC : D -> C
  eD : equiv_rel D
  encD : encModRel CD DC eD
  ============================
  Equality.mixin_of (type_of (Phantom (rel D) encD))
1 subgoal
  
  D : Type
  C : Choice.Exports.choiceType
  CD : C -> D
  DC : D -> C
  eD : equiv_rel D
  encD : encModRel CD DC eD
  x, y : D
  ============================
  (x == y %[mod type_of (Phantom (rel D) encD)]) = eD x y
1 subgoal
  
  D : Type
  C : countType
  CD : C -> D
  DC : D -> C
  eD : equiv_rel D
  encD : encModRel CD DC eD
  ============================
  Countable.mixin_of {eq_quot encD}
1 subgoal
  
  T : choiceType
  e : equiv_rel T
  Q : eqQuotType e
  x, y : T
  ============================
  (x == y %[mod_eq e]) = e x y
1 subgoal
  
  T : choiceType
  e : equiv_rel T
  Q : eqQuotType e
  x, y : T
  ============================
  reflect (x = y %[mod_eq e]) (e x y)
1 subgoal
  
  T : Type
  e : rel T
  Q : eqQuotType e
  x, y : T
  ============================
  (x == y %[mod Q]) = e x y
1 subgoal
  
  T : Type
  e : rel T
  Q : eqQuotType e
  x, y : T
  ============================
  reflect (x = y %[mod Q]) (e x y)
COQC all_ssreflect.v
COQC ssrmatching.v
